diff -urpBN hiopenais/src/aic_mng/aic_mng.c hiopenais_modify/src/aic_mng/aic_mng.c
--- hiopenais/src/aic_mng/aic_mng.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/aic_mng/aic_mng.c	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,1927 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <pthread.h>
+#include <unistd.h>
+
+#include "hi_ext_util.h"
+#include "mpp_help.h"
+#include "plug_mng.h"
+#include "aic_mng.h"
+
+#define PLUG_DIR_DEF            "./plugs" // 默认插件目录
+#define PLUG_UUID_MAX           256 // 插件uuid的最大字节长度
+#define PREPLUG_ID_MAX          9 // 预先加载的插件序号的最大值，从0开始
+
+#define VENC_SIZET_DEF          PIC_720P // 编码的默认size
+#define PIRIOD_LOG_INTVAL       (5 * 1000) // 期间统计信息输出间隔
+
+#define VDEC_WIDTH_MAX          2688 // 解码支持的最大width
+#define VDEC_HEIGHT_MAX         2160 // 解码支持的最大height
+#define VDEC_FPS_DEF            25 // 解码支持的默认fps
+
+#define SCENE_PARAM_FILE_DEF    "./scene_auto/param/sensor_imx335" // snssor参数文件
+#define INIT_PIC_FILE_DEF       "./res/black_640x360.jpg" // 用于UVC的初始图片
+
+#define STATUS_INFO_MAX         (128 * 1024) // status info buf的size, 暂时采用定长buf
+#define STATUS_EVT_NAME         "status" // status事件名称
+
+#define STRM_USER_MAX           8 // stream user的最大数目
+
+/*
+    AIC使用的MPP资源ID的默认值，将来可通过配置文件配置
+*/
+#define AIC_VDEC_CHN            0 // 默认使用的VDEC chn
+#define AIC_VENC_CHN            0 // 默认使用的VENC chn
+#define AIC_VPSS_GRP            0 // 默认使用的VPSS group
+#define AIC_VPSS_ZIN_CHN        0 // 默认使用的VPSS 放大通道
+#define AIC_VPSS_ZOUT_CHN       1 // 默认使用的VPSS 缩小通道
+
+#define SIZE_TO_MPP_WIDTH_1920    1920
+#define SIZE_TO_MPP_HEIGHT_1080   1080
+#define SIZE_TO_MPP_WIDTH_1280    1280
+#define SIZE_TO_MPP_HEIGHT_720    720
+#define SIZE_TO_MPP_WIDTH_640     640
+#define SIZE_TO_MPP_HEIGHT_360    360
+#define SIZE_TO_MPP_WIDTH_3840    3840
+#define SIZE_TO_MPP_HEIGHT_2160   2160
+#define SIZE_TO_MPP_WIDTH_2592    2592
+#define SIZE_TO_MPP_HEIGHT_1536   1536
+#define SIZE_TO_MPP_HEIGHT_1944   1944
+
+/**
+    订阅AIC事件的user的信息.
+*/
+typedef struct AicEvtUser {
+    struct list_head lnode;
+
+    uintptr_t cltId;
+    char evtName[TINY_BUF_SIZE];
+
+    AicEvtProc proc;
+    void *user;
+}   AicEvtUser;
+
+/**
+    订阅AI服务的user的信息.
+*/
+typedef struct AiSvcUser {
+    struct list_head lnode;
+
+    uintptr_t cltId;
+    char plugUuid[PLUG_UUID_MAX];
+
+    AiResProc proc;
+    void *user;
+}   AiSvcUser;
+
+/**
+    AI计算job.
+    表示一帧计算任务。
+*/
+typedef struct AiCalJob {
+    bool busy; // 是否正在被使用
+    int sigFd; // 完成通知信号
+
+    int res; // 执行结果
+    int grpId; // VPSS group ID
+    int chnId; // VPSS chn ID
+    VIDEO_FRAME_INFO_S frm; // [in|out]帧，待计算的帧，计算后叠加图形到该帧
+
+    char *resJson; // 插件计算后返回的resJson
+    char plugUuid[PLUG_UUID_MAX]; // 执行此job的plugUuid，由svc负责赋值
+}   AiCalJob;
+
+/**
+    AI计算服务.
+*/
+typedef struct AiCalSvc {
+    EvtMon *evtMon; // 关联的EvtMon，EvtMon关联了一个后台线程
+    int sigFd; // 指示由job添加的信号
+}   AiCalSvc;
+
+/**
+    期间统计信息.
+*/
+typedef struct PiriodStatis {
+    int64_t begTime; // 期间起始时间(ms)
+
+    int vpssOutNum; // VPSS输出的帧数，也等于VPSS输入的帧数
+    int vencOutNum; // VENC输出的帧数，也等于VENC输入的帧数
+    int aiCalNum; // AI计算的帧数
+
+    int64_t aiCalCost; // AI插件计算耗时
+    int64_t fmtFrmCost; // AI计算前帧处理(resize等)耗时
+    int64_t cvtVoFrmCost; // VENC输出帧转换为vo格式的耗时
+}   PiriodStatis;
+
+/**
+    aic stream user node.
+*/
+typedef struct AicStrmUser {
+    const IAicStrmUser *itf;
+    void *user;
+}   AicStrmUser;
+
+/**
+    AI Camera Manager.
+*/
+typedef struct AicMng {
+    bool inited; // 对象是否inited
+    bool initing; // 是否正在初始化
+
+    EvtMon *evtMon; // MainEvtMon()的快捷值
+    // UvcDevT *uvcDev; // 使用的UvcDev
+
+    // mpp可监视fd
+    int vpssFd; // 指示VPSS有输出的fd
+    int vencFd; // 指示VENC有输出的fd
+
+    // 当前MppSess使用的资源ID
+    VPSS_GRP vpssGrp;
+    VPSS_CHN vpssChn0;
+    VPSS_CHN vpssChn1;
+    VDEC_CHN vdecChn;
+    VENC_CHN vencChn;
+
+    // MppSess config
+    ViCfg viCfg;
+    VdecCfg vdecCfg;
+    VpssCfg vpssCfg;
+    VencCfg vencCfg;
+
+    // MppSess
+    MppSess *viSess; // VI(sensor)+VPSS | VDEC+VPSS
+    MppSess *vencSess; // VENC
+
+    // MppSess相关
+    OsdSet *osdSet; // OSD set，供plug在resFrm中输出OSD
+    uint32_t inFrmIdc; // 输入frame的ID计数器，用于生成mpp frame的timeRef
+
+    // vi相关
+    AicViType viType; // vi type，同时只能支持一种type
+    bool viByHost; // VI是否被host启动的
+    int64_t rxPicNum; // 一次HOST-VI接收到的图片数目
+    int viOpenRef; // sensor被打开的计数，用来表示当前有多少个user正在打开sensor
+
+    // vo相关
+    uint32_t voTypes; // vo types，可同时支持多个type
+    int voOpenRef; // vo被打开的计数，用来表示当前有多少个user正在打开vo
+
+    AiCalSvc aiCalSvc; // AI计算服务，会关联一个后台线程
+    AiCalJob aiCalJob; // AI计算任务，包含计算一帧图片的相关信息
+    char *prevResJson; // 前次AI计算返回的resJson
+
+    pthread_mutex_t plugMutex; // AiCalSvc与PlugLoadJob会同时访问插件，需要保护
+    AiPlugLib workPlug; // 当前加载的插件
+
+    struct list_head aiSvcUsers; // 当前插件AI服务的user list
+
+    struct list_head plugInfos; // 插件信息列表，元素为AicPlugInfo
+    struct list_head svcPlugs; // 正在运行管理服务的插件列表，元素为AicPlugInfo
+
+    struct list_head evtUsers; // 订阅事件的user list
+
+    int statusChgFd; // 指示状态变更的fd
+
+    int blkCallNum; // 此对象上正在执行的耗时函数的数量，并不精确，仅用于检查错误
+    PiriodStatis piriodStatis; // 期间统计信息
+
+    // 用于规避UVC问题的初始图片发送相关数据
+    bool inTxInitPic; // 正在发送初始图片
+    int initPicSent; // 这次初始图片发送操作，已发送的图片数量，仅用于log
+    uint8_t *initPicBuf; // 存储初始图片的buf
+    int initPicLen; // 初始图片的字节长度
+
+    AicStrmUser strmUserTab[STRM_USER_MAX]; // 存储stream user的table
+    size_t strmUserNum; // node number in strmUserTab
+}   AicMng;
+
+/**
+    为简化其他模块的使用，以及uvc histrm接口的限制，AicMng全局只有一个实例.
+*/
+static AicMng g_aic = { 0 };
+
+/*************************************************************************************************
+    util
+*************************************************************************************************/
+#define SP_AIC_UTIL
+
+/**
+    将UVC的size type转换为MPP的.
+*/
+static PIC_SIZE_E SizeToMpp(int width, int height)
+{
+    if (width == SIZE_TO_MPP_WIDTH_1920 && height == SIZE_TO_MPP_HEIGHT_1080) {
+        return PIC_1080P;
+    } else if (width == SIZE_TO_MPP_WIDTH_1280 && height == SIZE_TO_MPP_HEIGHT_720) {
+        return PIC_720P;
+    } else if (width == SIZE_TO_MPP_WIDTH_640 && height == SIZE_TO_MPP_HEIGHT_360) {
+        return PIC_360P;
+    } else if (width == SIZE_TO_MPP_WIDTH_3840 && height == SIZE_TO_MPP_HEIGHT_2160) {
+        return PIC_3840x2160;
+    } else if (width == SIZE_TO_MPP_WIDTH_2592 && height == SIZE_TO_MPP_HEIGHT_1536) {
+        return PIC_2592x1536;
+    } else if (width == SIZE_TO_MPP_WIDTH_2592 && height == SIZE_TO_MPP_HEIGHT_1944) {
+        return PIC_2592x1944;
+    } else {
+        LOGE("cannot map {%dx%d} to sizeType, regard 1080p\n", width, height);
+        return PIC_1080P;
+    }
+}
+
+/**
+    创建AicEvtUser.
+*/
+static AicEvtUser* AicEvtUserNew(uintptr_t cltId, const char* evtName, AicEvtProc proc, void* user)
+{
+    AicEvtUser *self = (AicEvtUser*)malloc(sizeof(*self));
+    HI_ASSERT(self);
+    self->cltId = cltId;
+    HiStrxfrm(self->evtName, evtName ? evtName : "", sizeof(self->evtName));
+    self->proc = proc;
+    self->user = user;
+    return self;
+}
+
+/**
+    创建AiSvcUser.
+*/
+static AiSvcUser* AiSvcUserNew(uintptr_t cltId, const char* plugUuid, AiResProc proc, void* user)
+{
+    AiSvcUser *self = (AiSvcUser*)malloc(sizeof(*self));
+    HI_ASSERT(self);
+    self->cltId = cltId;
+    HiStrxfrm(self->plugUuid, plugUuid ? plugUuid : "", sizeof(self->plugUuid));
+    self->proc = proc;
+    self->user = user;
+    return self;
+}
+
+/*************************************************************************************************
+    MPP session 数据处理
+*************************************************************************************************/
+#define SP_AIC_INNER
+
+/**
+    为frame分配id.
+*/
+static inline uint32_t AicGenFrmId(void)
+{
+    // 替换原来的timeRef，这样venc生存期内，vi重启，timeRef也会单向递增，避免MPP编码错误
+    // 先加2，以避免是用0，从mpp实际输出的timeRef看，其从2开始
+    while ((g_aic.inFrmIdc += 2) == 0) {}
+    return g_aic.inFrmIdc;
+}
+
+/**
+    向user分发StrmOn.
+*/
+static inline void AicDispStrmOn(PAYLOAD_TYPE_E codecType, int outWidth, int outHeight)
+{
+    if (g_aic.strmUserNum > 0) {
+        for (size_t i = 0; i < HI_ARRAY_SIZE(g_aic.strmUserTab); i++) {
+            AicStrmUser *node = &g_aic.strmUserTab[i];
+            if (node->itf && node->itf->OnStrmOn) {
+                node->itf->OnStrmOn(node->user, g_aic.vencChn, codecType, outWidth, outHeight);
+            }
+        }
+    }
+}
+
+/**
+    向user分发StrmOff.
+*/
+static inline void AicDispStrmOff(void)
+{
+    if (g_aic.strmUserNum > 0) {
+        for (size_t i = 0; i < HI_ARRAY_SIZE(g_aic.strmUserTab); i++) {
+            AicStrmUser *node = &g_aic.strmUserTab[i];
+            if (node->itf && node->itf->OnStrmOff) {
+                node->itf->OnStrmOff(node->user);
+            }
+        }
+    }
+}
+
+/**
+    向user分发VencFrm.
+*/
+static inline void AicDispVencFrm(VencFrm* frm)
+{
+    if (g_aic.strmUserNum > 0) {
+        for (size_t i = 0; i < HI_ARRAY_SIZE(g_aic.strmUserTab); i++) {
+            AicStrmUser *node = &g_aic.strmUserTab[i];
+            if (node->itf && node->itf->OnVencFrm) {
+                node->itf->OnVencFrm(node->user, frm);
+            }
+        }
+    }
+}
+
+/**
+    向user分发VideoFrm.
+*/
+static inline void AicDispVideoFrm(VIDEO_FRAME_INFO_S* frm)
+{
+    if (g_aic.strmUserNum > 0) {
+        for (size_t i = 0; i < HI_ARRAY_SIZE(g_aic.strmUserTab); i++) {
+            AicStrmUser *node = &g_aic.strmUserTab[i];
+            if (node->itf && node->itf->OnVideoFrm) {
+                node->itf->OnVideoFrm(node->user, frm);
+            }
+        }
+    }
+}
+
+/**
+    查找uuid对应的AI Plug.
+*/
+static AiPlugInfo* AicFindPlug(const char* uuid)
+{
+    AiPlugInfo *info = NULL;
+    struct list_head *node = NULL;
+
+    HiGlbLock();
+    list_for_each(node, &g_aic.plugInfos) {
+        info = list_entry(node, AiPlugInfo, lnode);
+        if (strcmp(uuid, info->uuid) == 0) {
+            HiGlbUnlock();
+            return info;
+        }
+    }
+    HiGlbUnlock();
+    return NULL;
+}
+
+/**
+    load plug only.
+*/
+static int AicLoadPlug(const char* uuid, const AiPlugInfo *info)
+{
+    HI_ASSERT(!g_aic.workPlug.itf);
+    AiPlugLib newPlug;
+    int ret;
+
+    // load插件
+    ret = PmLoadPlugLib(&newPlug, info->path);
+    if (ret < 0) {
+        LOGE("load plug FAIL, ret=%d\n", ret);
+        return ret;
+    }
+
+    // load模型
+    HI_ASSERT(g_aic.osdSet);
+    HI_ASSERT(newPlug.itf); // 增加newPlug.itf判空处理
+    HI_ASSERT(newPlug.itf->Load);
+    ret = newPlug.itf->Load(&newPlug.model, g_aic.osdSet);
+    if (ret < 0) {
+        LOGE("load plug model FAIL, ret=%d\n", ret);
+        PmUnloadPlugLib(&newPlug);
+        return ret;
+    }
+    HI_ASSERT(newPlug.model);
+
+    // 加锁更新workPlug
+    HiGlbLock();
+    g_aic.workPlug = newPlug;
+    HiGlbUnlock();
+    return 0;
+}
+
+/**
+    unload当前工作的AI plug.
+    需要在加锁plugMutex后调用此函数。
+*/
+static int AicUnloadPlug(void)
+{
+    AiPlugLib curPlug; // 用以记录当前working plug
+    int ret;
+
+    if (!g_aic.workPlug.itf) {
+        return 0;
+    }
+
+    // 加锁移出workPlug
+    HiGlbLock();
+    curPlug = g_aic.workPlug;
+    if (memset_s(&g_aic.workPlug, sizeof(g_aic.workPlug), 0, sizeof(g_aic.workPlug)) != EOK) {
+        HI_ASSERT(0);
+    }
+    HiGlbUnlock();
+
+    LOGI("AIC: unload plug '%s' ...\n", curPlug.uuid);
+    if (curPlug.model && (ret = curPlug.itf->Unload(curPlug.model)) < 0) {
+        LOGE("unload plug model FAIL, ret=%d\n", ret);
+    }
+    ret = PmUnloadPlugLib(&curPlug);
+    LOGI("AIC: unload plug done\n");
+    return ret;
+}
+
+/**
+    加载配置的plugs.
+    目前暂时只支持一个plug的加载，当成功加载到一个plug后，忽略后续的plug
+*/
+static int AicPreloadPlugs(void)
+{
+    char key[SMALL_BUF_SIZE];
+    int plugNum = 0;
+    int ret;
+
+    // 枚举conf中需要为0~REPLUG_ID_MAX的配置项，获取其plugUuid，加载插件
+    for (int i = 0; i <= PREPLUG_ID_MAX; i++) {
+        // 从conf中plug[i]对应的uuid
+        if (snprintf_s(key, sizeof(key), sizeof(key) - 1, "work_plugs:plug%d", i) < 0) {
+            HI_ASSERT(0);
+        }
+        const char* plugUuid = GetCfgStr(key, NULL);
+        if (!plugUuid || !*plugUuid) {
+            continue;
+        }
+
+        // 加载插件， 若失败，则简单忽略
+        ret = AicSetAiPlug(plugUuid, NULL, false);
+        if (ret) {
+            LOGE("load plug '%s' FAIL, ret=%d\n", plugUuid, ret);
+            continue;
+        }
+
+        // 目前暂时只支持一个plug,加载成功后即退出
+        plugNum++;
+        break;
+    }
+    return plugNum;
+}
+
+/**
+    生成status事件，并发送给订阅者.
+*/
+int AicGenStatusEvt(void)
+{
+    MemBlk *evt = MemBlkNew2(HUGE_BUF_SIZE, TINY_BUF_SIZE);
+    HI_ASSERT(evt);
+
+    int ret = AicGetStatus(evt);
+    HI_EXP_GOTO(ret < 0, END, "AicGetStatus FAIL, ret=%d\n", ret);
+
+    struct list_head *node = NULL;
+    list_for_each(node, &g_aic.evtUsers) {
+        AicEvtUser *user = list_entry(node, AicEvtUser, lnode);
+        if (!user->evtName[0] || strcmp(user->evtName, STATUS_EVT_NAME) == 0) {
+            HI_ASSERT(user->proc);
+            user->proc(user->user, user->cltId, STATUS_EVT_NAME, (char*)MemBlkData(evt), MemBlkLen(evt));
+        }
+    }
+    ret = 0;
+
+    END:
+        MemBlkDelete(evt);
+        return ret;
+}
+
+/**
+    从文件加载初始图片.
+*/
+static int AicLoadInitPic(void)
+{
+    const char* initPicFile = GetCfgStr("aic_mng:init_pic_file", INIT_PIC_FILE_DEF);
+    LOGI("AIC: load init pic '%s' ...\n", initPicFile);
+
+    HI_ASSERT(!g_aic.initPicBuf);
+    long ret = FileLoadToBuf(initPicFile, &g_aic.initPicBuf, true);
+    HI_EXP_RET(ret < 0, ret, "AIC: load init pic '%s' FAIL, err=%ld\n", initPicFile, ret);
+    HI_ASSERT(ret > 0); // 不会等于0
+    g_aic.initPicLen = ret;
+
+    LOGI("AIC: load init pic done, size=%ld\n", ret);
+    return ret;
+}
+
+/**
+    释放初始图片.
+*/
+static void AicFreeInitPic(void)
+{
+    if (g_aic.initPicBuf) {
+        free(g_aic.initPicBuf);
+        g_aic.initPicBuf = NULL;
+        g_aic.initPicLen = 0;
+    }
+}
+
+/**
+    发送初始图片.
+*/
+int AicTxInitPic(void)
+{
+    VDEC_STREAM_S vdecStrm;
+    int ret;
+
+    // 目前仅支持在vitype为BY_HOST时发送初始图片，可以根据需要调整
+    HI_ASSERT(g_aic.viOpenRef > 0 && g_aic.viType == AIC_VIT_HOST);
+
+    // 只load一次file
+    if (!g_aic.initPicBuf && AicLoadInitPic() < 0) {
+        return -1;
+    }
+
+    LOGI("AIC: tx init pic %d ...\n", g_aic.initPicSent + 1);
+    HI_ASSERT(g_aic.initPicBuf && g_aic.initPicLen > 0);
+
+    // 提交给VDEC
+    if (memset_s(&vdecStrm, sizeof(vdecStrm), 0, sizeof(vdecStrm)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    vdecStrm.u64PTS = 0;
+    vdecStrm.pu8Addr = g_aic.initPicBuf;
+    vdecStrm.u32Len = g_aic.initPicLen;
+    vdecStrm.bEndOfFrame = HI_TRUE;
+    vdecStrm.bEndOfStream = HI_FALSE;
+
+    ret = HI_MPI_VDEC_SendStream(g_aic.vdecChn, &vdecStrm, 0);
+    if (ret) {
+        LOGE("HI_MPI_VDEC_SendStream FAIL, ret=%#x\n", ret);
+        return -1;
+    }
+
+    g_aic.inTxInitPic = true;
+    g_aic.initPicSent++;
+    return 0;
+}
+
+/**
+    添加AiCalJob.
+    填充job，唤醒AI计算服务线程处理。
+*/
+static void AicAddAiJob(const VIDEO_FRAME_INFO_S* frm)
+{
+    AiCalSvc *svc = &g_aic.aiCalSvc;
+    AiCalJob *job = &g_aic.aiCalJob;
+
+    // 要先判断AiCalSvc是否ready，及是否有job正在处理
+    if (!svc->evtMon || job->busy) {
+        LOGD("discard ai-job for %s\n", (!svc->evtMon) ? "svc-offline" : "in-job");
+        int ret = HI_MPI_VPSS_ReleaseChnFrame(g_aic.vpssGrp, g_aic.vpssChn0, frm);
+        HI_EXP_LOGE(ret, "HI_MPI_VPSS_ReleaseChnFrame FAIL, err=%#x\n", ret);
+        return;
+    }
+
+    // 填充job
+    job->busy = true;
+    job->res = -1;
+    job->grpId = g_aic.vpssGrp;
+    job->chnId = g_aic.vpssChn0;
+    job->frm = *frm;
+    HI_ASSERT(!job->resJson);
+    job->resJson = NULL;
+    job->plugUuid[0] = 0;
+
+    // 唤醒AI计算服务线程处理
+    HI_ASSERT(svc->sigFd >= 0);
+    EventFdInc(svc->sigFd);
+}
+
+/**
+    执行AI计算任务.
+
+    此函数由AiCalSvc线程执行。
+    由于插件可以动态加载/卸载，此函数在执行时需要加锁plugMutex。
+
+    @param frm [in|out]，输入待计算的frame，输出叠加了结果图形的frame
+*/
+static int AicExecAiJob(AiCalJob* job)
+{
+    VIDEO_FRAME_INFO_S* frm = &job->frm;
+    VIDEO_FRAME_INFO_S srcFrm; // 满足plug需要的输入frame
+    int ret;
+
+    MutexLock(&g_aic.plugMutex);
+
+    // 先判断是否加载了插件，未加载插件是允许的，此时表示不做AI计算，透传frame
+    if (!g_aic.workPlug.itf || !g_aic.workPlug.model) { // no plug loaded
+        ret = 0;
+        goto END;
+    } else {
+        HiStrxfrm(job->plugUuid, g_aic.workPlug.uuid, sizeof(job->plugUuid));
+    }
+
+    // resize frame为插件需要的格式/像素，frm不会被修改
+    HI_ASSERT(g_aic.workPlug.width > 0 && g_aic.workPlug.height > 0);
+    ret = MppFrmResize(frm, &srcFrm, g_aic.workPlug.width, g_aic.workPlug.height);
+    HI_CHK_GOTO(ret, END, "AIC: for resize FAIL, ret=%d\n", ret);
+
+    // 调用插件计算，插件会将结果帧通过resFrm(也即frm)返回
+    VIDEO_FRAME_INFO_S *resFrm = frm; // 仅强调通过@param frm输出resFrm
+    ret = g_aic.workPlug.itf->Cal(g_aic.workPlug.model, &srcFrm, resFrm, &job->resJson);
+    MppFrmDestroy(&srcFrm);
+    HI_EXP_LOGE(ret < 0, "plug cal FAIL, ret=%d\n", ret);
+
+    END:
+        MutexUnlock(&g_aic.plugMutex);
+        job->res = ret;
+        return ret;
+}
+
+/**
+    AiCalSvc监听到有AI计算任务新增.
+
+    此函数由AiCalSvc服务线程执行。
+    主线程通过job->sigFd通知AiCalSvc服务线程。
+*/
+static void AicOnJobAdd(void* user, int fd, uint32_t evts)
+{
+    AiCalSvc *svc = &g_aic.aiCalSvc;
+    AiCalJob *job = &g_aic.aiCalJob;
+
+    HI_ASSERT(fd == svc->sigFd);
+    pthread_t ret = pthread_self();
+    pthread_t res = EmThrdId(svc->evtMon);
+    HI_ASSERT(ret == res);
+
+    EvtChkRet(evts, FDE_IN, fd);
+    LOGV("detect job-add-fd IN, fd=%d\n", fd);
+    EventFdClear(svc->sigFd);
+
+    // NOTE: 无需也不能加锁
+    HI_ASSERT(job->busy);
+    AicExecAiJob(job);
+    HI_ASSERT(job->sigFd >= 0);
+    EventFdInc(job->sigFd);
+}
+
+/**
+    监听到有AI计算任务完成.
+    将结果frame提交给VENC编码，将结果json发送给host。
+*/
+static void AicOnJobEnd(void* user, int fd, uint32_t evts)
+{
+    AiCalJob *job = &g_aic.aiCalJob;
+    int ret;
+
+    HI_ASSERT(fd == job->sigFd);
+    EvtChkRet(evts, FDE_IN, evts);
+    LOGV("detect job-end-fd IN, fd=%d\n", fd);
+    EventFdClear(job->sigFd);
+
+    // 通过busy标志来控制job的add，此函数不用也不能加锁
+    HI_ASSERT(job->busy);
+
+    // 将resFrm提交给VENC编码
+    if (g_aic.vencSess) {
+        ret = HI_MPI_VENC_SendFrame(g_aic.vencChn, &job->frm, 0);
+        HI_EXP_LOGE(ret, "HI_MPI_VENC_SendFrame failed! ERR=%#x, discard the frm\n", ret);
+    } else {
+        LOGW("venc discard, for VENC not ready\n");
+    }
+
+    // 提交resJson给订阅的user, 仅当resJson与prevResJson不同时才提交给user
+    if (job->resJson && *job->resJson &&
+        (!g_aic.prevResJson || strcmp(g_aic.prevResJson, job->resJson) != 0)) {
+        int resLen = strlen(job->resJson);
+        struct list_head *node = NULL;
+        list_for_each(node, &g_aic.aiSvcUsers) {
+            AiSvcUser *user = list_entry(node, AiSvcUser, lnode);
+            if (!user->plugUuid[0] || strcmp(user->plugUuid, job->plugUuid) == 0) {
+                HI_ASSERT(user->proc);
+                user->proc(user->user, user->cltId, job->plugUuid, job->resJson, resLen);
+            }
+        }
+    }
+
+    // 重置prevResJson
+    // NOTE: 插件可能会被卸载，但其返回的resJson在插件卸载后仍然可用，只是插件的__FILE__等
+    // NOTE: string常量会变为无效，resJson若泄漏，dump其__FILE__时会异常。
+    if (g_aic.prevResJson) {
+        free(g_aic.prevResJson);
+    }
+    g_aic.prevResJson = job->resJson;
+    job->resJson = NULL;
+
+    // 将frame提交给注册的user
+    AicDispVideoFrm(&job->frm);
+
+    ret = HI_MPI_VPSS_ReleaseChnFrame(job->grpId, job->chnId, &job->frm);
+    HI_EXP_LOGE(ret, "HI_MPI_VPSS_ReleaseChnFrame FAIL, ret=%#x\n", ret);
+    job->busy = false; // 执行完处理后才能reset busy标志
+}
+
+/**
+    监听到有VPSS有输出可用(有frame处理完成).
+*/
+static void AicOnVpssOut(void* user, int fd, uint32_t evts)
+{
+    HI_ASSERT(fd == g_aic.vpssFd);
+    EvtChkRet(evts, FDE_IN, fd);
+    LOGD("detect vpss-fd IN, fd=%d\n", fd);
+
+    VIDEO_FRAME_INFO_S frm;
+    int ret;
+
+    // 从VPSS读取frame, 读取到的frame没有map虚拟地址，后续处理需要注意
+    ret = HI_MPI_VPSS_GetChnFrame(g_aic.vpssGrp, g_aic.vpssChn0, &frm, 0);
+    HI_EXP_RET_NONE(ret, "HI_MPI_VPSS_GetChnFrame FAIL, err=%#x, grp=%d, chn=%d\n",
+        ret, g_aic.vpssGrp, g_aic.vpssChn0);
+
+    // VO未开启时，discard frame
+    if (g_aic.voOpenRef <= 0) {
+        LOGD("discard vpss-out frm, for no VO working\n");
+        ret = HI_MPI_VPSS_ReleaseChnFrame(g_aic.vpssGrp, g_aic.vpssChn0, &frm);
+        HI_EXP_LOGE(ret, "HI_MPI_VPSS_ReleaseChnFrame FAIL, err=%#x\n", ret);
+        return;
+    }
+
+    // 替换原来的timeRef，这样venc生存期内，vi重启，timeRef也会单向递增，避免MPP 编码错误
+    // 先加2，以避免是用0，从mpp实际输出的timeRef看，其从2开始
+    while ((g_aic.inFrmIdc += 2) == 0) {}
+    frm.stVFrame.u32TimeRef = g_aic.inFrmIdc;
+
+    // 可以优化为在这里检查是否加载了插件，未加载时，直接通过venc输出
+    AicAddAiJob(&frm);
+}
+
+/**
+    监听到VENC有输出可用(有frame编码完成).
+*/
+static void AicOnVencOut(void* user, int fd, uint32_t evts)
+{
+    HI_ASSERT(fd == g_aic.vencFd);
+    EvtChkRet(evts, FDE_IN, fd);
+    LOGV("detect venc-fd IN, fd=%d\n", fd);
+
+    VencFrm *vstrm = NULL;
+    int ret;
+
+    // 从VENC get frame
+    ret = VencGetFrmx(&vstrm, g_aic.vencChn);
+    HI_EXP_GOTO(ret, END, "VencGetFrm FAIL, ret=%#x\n", ret);
+
+    // 先复位此标志，user在处理此frame时可能会调用AicInitTxReq，而重置该标志.
+    g_aic.inTxInitPic = false;
+
+    // 将frame提交给注册的user
+    AicDispVencFrm(vstrm);
+
+    END:
+        if (vstrm) {
+            // 移动到VencStrmDefRef中了
+            VencFrmDelRef(vstrm);
+        }
+}
+
+/**
+    监听到status改变.
+*/
+static void AicOnStatusChg(void* user, int fd, uint32_t evts)
+{
+    HI_ASSERT(fd == g_aic.statusChgFd);
+    EvtChkRet(evts, FDE_IN, fd);
+    LOGV("detect status-chg IN, fd=%d\n", fd);
+
+    EventFdClear(fd);
+    AicGenStatusEvt();
+}
+
+/**
+    启动AI计算服务.
+*/
+static void AicStartAiSvc(void)
+{
+    // create AlCalJob
+    AiCalJob *job = &g_aic.aiCalJob;
+    HI_ASSERT(!job->busy);
+    HI_ASSERT(job->sigFd < 0);
+    job->sigFd = EventFdCreate();
+    HI_ASSERT(job->sigFd >= 0);
+    if (EmAddFd(g_aic.evtMon, job->sigFd, FDE_IN, AicOnJobEnd, &g_aic) < 0) {
+        HI_ASSERT(0);
+    }
+    HI_ASSERT(!job->resJson);
+
+    // create AlCalSvc
+    AiCalSvc *svc = &g_aic.aiCalSvc;
+    HI_ASSERT(!svc->evtMon);
+    HI_ASSERT(svc->sigFd < 0);
+    svc->sigFd = EventFdCreate();
+    HI_ASSERT(svc->sigFd >= 0);
+
+    // start AlCalSvc
+    if (EmCreate(&svc->evtMon) < 0) {
+        HI_ASSERT(0);
+    }
+    if (EmAddFd(svc->evtMon, svc->sigFd, FDE_IN, AicOnJobAdd, &g_aic) < 0) {
+        HI_ASSERT(0);
+    }
+    EmStart(svc->evtMon); // 其会创建后台线程，并开始服务
+}
+
+/**
+    终止AI计算服务.
+*/
+static void AicStopAiSvc(void)
+{
+    // stop and destroy AlCalSvc ...
+    AiCalSvc *svc = &g_aic.aiCalSvc;
+    EmStop(svc->evtMon); // 其会请求终止并等待后台线程结束
+
+    // NOTE: 需要先stop，再DelFd
+    HI_ASSERT(svc->sigFd >= 0);
+    if (EmDelFd(svc->evtMon, svc->sigFd) < 0) {
+        HI_ASSERT(0);
+    }
+    if (close(svc->sigFd) < 0) {
+        HI_ASSERT(0);
+    }
+    svc->sigFd = -1;
+
+    EmDestroy(svc->evtMon);
+    svc->evtMon = NULL;
+
+    // destroy AlCalJob ...
+    AiCalJob *job = &g_aic.aiCalJob;
+
+    // destroy未执行的AiCalJob
+    if (job->busy) {
+        int ret = HI_MPI_VPSS_ReleaseChnFrame(job->grpId, job->chnId, &job->frm);
+        if (ret != HI_SUCCESS) {
+            LOGE("HI_MPI_VPSS_ReleaseChnFrame FAIL, ret=%#x\n", ret);
+        }
+        job->busy = false;
+    }
+
+    HI_ASSERT(job->sigFd >= 0);
+    if (EmDelFd(g_aic.evtMon, job->sigFd) < 0) {
+        HI_ASSERT(0);
+    }
+    if (close(job->sigFd) < 0) {
+        HI_ASSERT(0);
+    }
+    job->sigFd = -1;
+
+    job->res = -1;
+    job->grpId = -1;
+    job->chnId = -1;
+    if (memset_s(&job->frm, sizeof(job->frm), 0, sizeof(job->frm)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    // 有可能当前有已经完成的AI计算，但主线程还未来得及处理，需要释放相应资源
+    if (job->resJson) {
+        LOGW("free job.resJson for it not proc by main thrd\n");
+        free(job->resJson);
+        job->resJson = NULL;
+    }
+}
+
+/**
+    启动插件服务.
+    加载需要运行管理服务的插件，并启动其服务。
+    加载插件无需锁保护。
+    plug.startSvc也无需加锁，提供了管理服务的插件会自己保护资源。
+*/
+static int AicStartPlugSvcs(void)
+{
+    struct list_head *node = NULL;
+    AiPlugLib *plug = NULL;
+    int svcNum = 0;
+    int ret;
+
+    list_for_each(node, &g_aic.plugInfos) {
+        AiPlugInfo *info = list_entry(node, AiPlugInfo, lnode);
+        if (!info->mngSvc) {
+            continue;
+        }
+
+        LOGI("AIC: start mng svc of plug '%s' ...\n", info->uuid);
+
+        // 加载插件
+        plug = (AiPlugLib*)malloc(sizeof(*plug));
+        HI_ASSERT(plug);
+        ret = PmLoadPlugLib(plug, info->path);
+        if (ret < 0) {
+            LOGE("load ai plug '%s' FAIL, ret=%d\n", info->uuid, ret);
+            free(plug);
+            plug = NULL; // ensure by meeting
+            continue;
+        }
+
+        // 启动服务
+        HI_ASSERT(plug->itf && plug->itf->StartSvc);
+        ret = plug->itf->StartSvc();
+        if (ret != 0) {
+            LOGE("start plug svc of '%s' FAIL, ignore, ret=%d\n", info->uuid, ret);
+            PmUnloadPlugLib(plug);
+            free(plug);
+            plug = NULL; // ensure by meeting
+            continue;
+        }
+
+        // 添加到svcPlus中，目前是不需要加锁保护
+        list_add_tail(&plug->lnode, &g_aic.svcPlugs);
+        svcNum++;
+    }
+    return svcNum;
+}
+
+/**
+    终止已启动的插件服务.
+*/
+static int AicStopPlugSvcs(void)
+{
+    struct list_head *node = NULL;
+    struct list_head *next = NULL;
+    int svcNum = 0;
+    int ret;
+
+    // 将svcInfos中记录的所有插件的服务终止，并卸载插件
+    list_for_each_safe(node, next, &g_aic.svcPlugs) {
+        AiPlugLib *plug = list_entry(node, AiPlugLib, lnode);
+        LOGI("AIC: stop mng svc of plug '%s' ...\n", plug->uuid);
+
+        // 终止服务
+        HI_ASSERT(plug->itf && plug->itf->StopSvc);
+        ret = plug->itf->StopSvc();
+        if (ret != 0) {
+            LOGE("stop plug svc of '%s' FAIL, ignore, ret=%d\n", plug->uuid, ret);
+        }
+
+        // 从svcPlus中删除，目前是不需要加锁保护
+        list_del(&plug->lnode);
+
+        // 卸载插件
+        PmUnloadPlugLib(plug);
+        free(plug);
+        svcNum++;
+    }
+    return svcNum;
+}
+
+/**
+    获取VPSS的out chn fd，并监听之.
+*/
+static void AicMonVpss(void)
+{
+    HI_ASSERT(g_aic.vpssFd < 0);
+    g_aic.vpssFd = HI_MPI_VPSS_GetChnFd(g_aic.vpssGrp, g_aic.vpssChn0);
+    if (g_aic.vpssFd < 0) {
+        LOGE("HI_MPI_VPSS_GetChnFd, ret=%x\n", g_aic.vpssFd);
+    } else {
+        if (EmAddFd(g_aic.evtMon, g_aic.vpssFd, FDE_IN | FDE_ET, AicOnVpssOut, NULL) < 0) {
+            HI_ASSERT(0);
+        }
+    }
+}
+
+/**
+    撤销对VPSS的out chn的监听.
+*/
+static void AicUnmonVpss(void)
+{
+    if (g_aic.vpssFd < 0) {
+        return;
+    }
+
+    if (EmDelFd(g_aic.evtMon, g_aic.vpssFd) < 0) {
+        HI_ASSERT(0);
+    }
+    int ret = HI_MPI_VPSS_CloseFd();
+    if (ret != 0) {
+        LOGE("close VPSS fd FAIL, err=%#x\n", ret);
+    }
+    g_aic.vpssFd = -1;
+}
+
+/**
+    获取VENC的out chn fd，并监听之.
+*/
+static void AicMonVenc(void)
+{
+    HI_ASSERT(g_aic.vencFd < 0);
+    g_aic.vencFd = HI_MPI_VENC_GetFd(g_aic.vencChn);
+    if (g_aic.vencFd < 0) {
+        LOGE("HI_MPI_VENC_GetFd FAIL, ret=%x\n", g_aic.vencFd);
+    } else {
+        if (EmAddFd(g_aic.evtMon, g_aic.vencFd, FDE_IN | FDE_ET, AicOnVencOut, NULL) < 0) {
+            HI_ASSERT(0);
+        }
+    }
+}
+
+/**
+    撤销对VENC的out chn的监听.
+*/
+static void AicUnmonVenc(void)
+{
+    if (g_aic.vencFd < 0) {
+        return;
+    }
+
+    if (EmDelFd(g_aic.evtMon, g_aic.vencFd) < 0) {
+        HI_ASSERT(0);
+    }
+    int ret = HI_MPI_VENC_CloseFd(g_aic.vencChn);
+    if (ret) {
+        LOGE("close VENC fd FAIL, err=%#x\n", ret);
+    }
+    g_aic.vencFd = -1;
+}
+
+/**
+    create VI(SENSOR)+VPSS session.
+
+    NOTE: MPP中的VI指基于SENSOR的video input，与HiOpenais中的vi有一定差异。
+    HiOpenais中vi包含但不限于SENSOR输入。
+*/
+static HI_S32 AicCreateSnsVpss(int outWidth, int outHeight, PIXEL_FORMAT_E pixFormat)
+{
+    LOGI("start sensor->vpss, size={%dx%d}\n", outWidth, outHeight);
+    VPSS_GRP vpssGrp = AIC_VPSS_GRP;
+    VPSS_CHN vpssChn = AIC_VPSS_ZOUT_CHN; // 缩小通道
+    int ret;
+
+    // VI config
+    ViCfgInit(&g_aic.viCfg);
+    ViCfgSetDev(&g_aic.viCfg, 0, -1);
+    ViCfgSetPipe(&g_aic.viCfg, 0, -1, -1, -1, -1);
+    ViCfgSetChn(&g_aic.viCfg, 0, pixFormat, -1, -1, COMPRESS_MODE_SEG);
+
+    // VPSS config
+    SIZE_S snsMaxSize = CurSnsMaxSize(ViCfgSnsType(&g_aic.viCfg));
+    LOGI("AIC: snsMaxSize=%ux%u\n", snsMaxSize.u32Width, snsMaxSize.u32Height);
+    VpssCfgInit(&g_aic.vpssCfg);
+    VpssCfgSetGrp(&g_aic.vpssCfg, vpssGrp, NULL, snsMaxSize.u32Width, snsMaxSize.u32Height);
+    g_aic.vpssCfg.grpAttr.enPixelFormat = pixFormat;
+    VpssCfgAddChn(&g_aic.vpssCfg, vpssChn, NULL, outWidth, outHeight);
+
+    HI_ASSERT(!g_aic.viSess);
+    ret = ViVpssCreate(&g_aic.viSess, &g_aic.viCfg, &g_aic.vpssCfg);
+    if (ret != 0) {
+        LOGE("ViVpss Sess create FAIL, ret=%#x\n", ret);
+        return ret;
+    }
+
+    const char* sceneParamFile = GetCfgStr("aic_mng:scene_param_file", SCENE_PARAM_FILE_DEF);
+    ret = SceneInit(sceneParamFile);
+    if (ret != 0) {
+        LOGE("SceneInit FAIL, ret=%#x\n", ret);
+        MppSessDestroy(g_aic.viSess);
+        g_aic.viSess = NULL;
+        return ret;
+    }
+
+    g_aic.vpssGrp = vpssGrp;
+    g_aic.vpssChn0 = vpssChn;
+    return 0;
+}
+
+/**
+    create VDEC+VPSS session.
+*/
+HI_S32 AicCreateVdecVpss(int outWidth, int outHeight, PIXEL_FORMAT_E pixFormat)
+{
+    VPSS_GRP vpssGrp = AIC_VPSS_GRP;
+    VPSS_CHN vpssChn = AIC_VPSS_ZIN_CHN; // 放大通道
+    int ret;
+
+    // VPSS config
+    VpssCfgInit(&g_aic.vpssCfg);
+    VpssCfgSetGrp(&g_aic.vpssCfg, vpssGrp, NULL, VDEC_WIDTH_MAX, VDEC_HEIGHT_MAX);
+    g_aic.vpssCfg.grpAttr.enPixelFormat = pixFormat;
+    g_aic.vpssCfg.grpAttr.bNrEn = HI_FALSE;
+    VpssCfgAddChn(&g_aic.vpssCfg, vpssChn, NULL, outWidth, outHeight);
+
+    // 创建MppSess
+    HI_ASSERT(!g_aic.viSess);
+    ret = VdecVpssCreate(&g_aic.viSess, &g_aic.vdecCfg, &g_aic.vpssCfg, true);
+    HI_CHK_RET(ret, "VdecVpss Sess create FAIL, ret=%#x\n", ret);
+
+    g_aic.vpssGrp = vpssGrp;
+    g_aic.vpssChn0 = vpssChn;
+    return 0;
+}
+
+/**
+    create VENC session.
+*/
+static int AicCreateVenc(PAYLOAD_TYPE_E codecType, int width, int height)
+{
+    VENC_GOP_MODE_E enGopMode = VENC_GOPMODE_NORMALP;
+    SAMPLE_RC_E enRcMode = SAMPLE_RC_CBR;
+    PIC_SIZE_E sizeType;
+    int ret;
+
+    sizeType = SizeToMpp(width, height);
+    if (codecType == PT_H264 || codecType == PT_H265) {
+        enRcMode = SAMPLE_RC_AVBR;
+    }
+
+    VencCfgInit(&g_aic.vencCfg, g_aic.vencChn, sizeType, codecType, enGopMode, enRcMode);
+    HI_ASSERT(!g_aic.vencSess);
+    ret = VencCreate(&g_aic.vencSess, &g_aic.vencCfg);
+    HI_CHK_RET(ret, "VencCreate FAIL, ret=%#x\n", ret);
+    return 0;
+}
+
+/**
+    start vi.
+*/
+int AicStartVi(AicViType viType, bool byHost,
+    int outWidth, int outHeight, PIXEL_FORMAT_E pixFormat)
+{
+    HI_ASSERT(viType > AIC_VIT_NONE && viType < AIC_VIT_BUTT);
+    int ret;
+
+    pixFormat = (int)pixFormat < 0 ? PIXEL_FORMAT_YVU_SEMIPLANAR_420 : pixFormat;
+
+    if (g_aic.viOpenRef > 0) {
+        LOGW("AIC: start VI{%d} ignore, for viOpenRef=%d\n", viType, g_aic.viOpenRef);
+        g_aic.viOpenRef++;
+        return 0;
+    }
+
+    // create vi+vpss sess
+    if (viType == AIC_VIT_SENSOR) {
+        ret = AicCreateSnsVpss(outWidth, outHeight, pixFormat);
+    } else if (viType == AIC_VIT_HOST) {
+        ret = AicCreateVdecVpss(outWidth, outHeight, pixFormat);
+    } else {
+        HI_ASSERT(0);
+        ret = -1;
+    }
+    if (ret != 0) {
+        g_aic.viOpenRef = 0;
+        return ret;
+    }
+
+    g_aic.viOpenRef = 1;
+    g_aic.viType = viType;
+    g_aic.viByHost = byHost;
+    g_aic.rxPicNum = 0; // 实际仅对VIT_HOST有意义
+
+    AicMonVpss();
+    AicStartAiSvc(); // ai service随VI启动
+
+    // 随vi启动初始化统计信息
+    if (memset_s(&g_aic.piriodStatis, sizeof(g_aic.piriodStatis), 0, sizeof(g_aic.piriodStatis)) != EOK) {
+        HI_ASSERT(0);
+    }
+    g_aic.piriodStatis.begTime = HiClockMs();
+
+    EventFdInc(g_aic.statusChgFd); // 通知status变更
+    return 0;
+}
+
+/**
+    stop vi.
+*/
+int AicStopVi(AicViType viType, bool byHost)
+{
+    HI_ASSERT(viType > AIC_VIT_NONE && viType < AIC_VIT_BUTT);
+
+    if (g_aic.viOpenRef <= 0) {
+        LOGW("AIC: stop VO{%x} ignore, for no vi opened\n", viType);
+        return 0;
+    }
+    if (--g_aic.viOpenRef > 0) {
+        LOGW("AIC: stop VO{%x} ignore, for viOpenRef=%d\n", viType, g_aic.voOpenRef);
+        return 0;
+    }
+
+    // 终止VI
+    LOGI("AIC: stop VI{%d} ...\n", g_aic.viType);
+    HI_ASSERT(g_aic.viType > 0);
+
+    // 要先终止ai计算服务，再destroy MppSess，因为需要先destroy从MppSess中获得的buf
+    AicStopAiSvc();
+
+    AicUnmonVpss();
+    if (g_aic.viType == AIC_VIT_SENSOR) {
+        SceneExit();
+    }
+    MppSessDestroy(g_aic.viSess);
+    g_aic.viSess = NULL;
+
+    g_aic.vpssGrp = -1;
+    g_aic.vpssChn0 = -1;
+    g_aic.vpssChn1 = -1;
+
+    g_aic.viType = AIC_VIT_NONE;
+    g_aic.viByHost = false;
+
+    EventFdInc(g_aic.statusChgFd); // 通知status变更
+    LOGI("AIC: stop VI{%d} done\n", g_aic.viType);
+    return 0;
+}
+
+/**
+    start vo.
+*/
+int AicStartVo(uint32_t voType, int outWidth, int outHeight, PAYLOAD_TYPE_E codecType)
+{
+    HI_ASSERT(voType == AIC_VOT_UVC || voType == AIC_VOT_IP || voType == AIC_VOT_RTSPD);
+
+    // 支持多个VO并存
+    if (g_aic.voOpenRef > 0) {
+        LOGW("AIC: start VO{%x} ignore, for VO{%x} exist\n", voType, g_aic.voTypes);
+        g_aic.voTypes |= voType;
+        g_aic.voOpenRef++;
+        EventFdInc(g_aic.statusChgFd); // 通知status变更
+        return 0;
+    }
+
+    // 启动VENC
+    LOGI("AIC: start VENC ...\n");
+    HI_ASSERT(!g_aic.vencSess);
+
+    int ret = AicCreateVenc(codecType, outWidth, outHeight);
+    HI_CHK_RET(ret, "create VencSess FAIL, ret=%#x\n", ret);
+    g_aic.voTypes |= voType;
+    g_aic.inFrmIdc = 0; // 可不加
+    g_aic.voOpenRef = 1;
+
+    AicMonVenc(); // 获取VENC的out chn fd，并监听之
+    EventFdInc(g_aic.statusChgFd); // 通知status变更
+
+    // 通知注册的user
+    AicDispStrmOn(codecType, outWidth, outHeight);
+
+    LOGI("AIC: start VENC done\n");
+    return 0;
+}
+
+/**
+    stop vo.
+*/
+int AicStopVo(uint32_t voType)
+{
+    HI_ASSERT(voType == AIC_VOT_UVC || voType == AIC_VOT_IP || voType == AIC_VOT_RTSPD);
+
+    if (g_aic.voOpenRef <= 0) {
+        LOGW("AIC: stop VO{%x} ignore, for voOpenRef=%d\n", voType, g_aic.voOpenRef);
+        return 0;
+    }
+
+    g_aic.voTypes &= ~voType;
+    if (--g_aic.voOpenRef > 0) {
+        LOGW("AIC: stop VO{%x} ignore, for voOpenRef=%d\n", voType, g_aic.voOpenRef);
+        EventFdInc(g_aic.statusChgFd); // 通知status变更
+        return 0;
+    }
+
+    // 终止VO
+    LOGI("AIC: stop VO{%x} ...\n", g_aic.voTypes);
+    HI_ASSERT(g_aic.vencSess);
+    HI_ASSERT(g_aic.vencFd >= 0);
+
+    AicUnmonVenc();
+    MppSessDestroy(g_aic.vencSess);
+    g_aic.vencSess = NULL;
+    g_aic.inFrmIdc = 0;
+
+    EventFdInc(g_aic.statusChgFd); // 通知status变更
+
+    // 不释放，以提升UVC开关性能
+    // 需要复位此标志，否则可能没有机会复位它, 当前正在发送init pic也无妨
+    g_aic.inTxInitPic = false;
+    g_aic.initPicSent = 0;
+
+    // 通知注册的user
+    AicDispStrmOff();
+
+    LOGI("AIC: stop VO{%x} done\n", voType);
+    return 0;
+}
+
+/**
+    stop 所有的vi, vo.
+    NOTE: 不stop AIC_VOT_UVC，这由UVC触发.
+*/
+int AicStopVios(bool byHost)
+{
+    int ret = 0;
+
+    if (g_aic.viType && AicStopVi(g_aic.viType, byHost) < 0) {
+        ret = -1;
+    }
+    if ((g_aic.voTypes & AIC_VOT_IP) && AicStopVo(AIC_VOT_IP) < 0) {
+        ret = -1;
+    }
+    return ret;
+}
+
+/**
+    AicMng constructor.
+*/
+static void AicCreate(AicMng* self)
+{
+    self->inited = true;
+
+    self->evtMon = MainEvtMon();
+    self->vpssFd = -1;
+    self->vencFd = -1;
+    self->vpssGrp = -1;
+    self->vpssChn0 = -1;
+    self->vpssChn1 = -1;
+    self->vdecChn = AIC_VDEC_CHN; // vdecChn是固定的
+    self->vencChn = AIC_VENC_CHN; // vencChn是固定的
+    self->osdSet = NULL;
+    self->viSess = NULL;
+    self->vencSess = NULL;
+    self->viType = AIC_VIT_NONE;
+    self->voTypes = 0;
+    self->viByHost = false;
+    self->viOpenRef = 0;
+    self->voOpenRef = 0;
+
+    VdecCfgInit(&self->vdecCfg, g_aic.vdecChn, PT_MJPEG, VIDEO_MODE_FRAME, VB_SOURCE_MODULE, NULL);
+    self->vdecCfg.fps = VDEC_FPS_DEF;
+
+    self->inFrmIdc = 0;
+    self->aiCalSvc.evtMon = NULL;
+    self->aiCalSvc.sigFd = -1;
+
+    self->aiCalJob.busy = false;
+    self->aiCalJob.sigFd = -1;
+    self->aiCalJob.res = -1;
+    self->aiCalJob.grpId = -1;
+    self->aiCalJob.chnId = -1;
+    self->aiCalJob.resJson = NULL;
+    self->prevResJson = NULL;
+    RecurMutexInit(&self->plugMutex);
+
+    INIT_LIST_HEAD(&self->plugInfos);
+    INIT_LIST_HEAD(&self->svcPlugs);
+    INIT_LIST_HEAD(&self->aiSvcUsers);
+    INIT_LIST_HEAD(&self->evtUsers);
+
+    self->statusChgFd = EventFdCreate();
+    HI_ASSERT(self->statusChgFd >= 0);
+    if (EmAddFd(self->evtMon, self->statusChgFd, FDE_IN, AicOnStatusChg, NULL) < 0) {
+        HI_ASSERT(0);
+    }
+
+    self->blkCallNum = 0;
+
+    self->inTxInitPic = false;
+    self->initPicSent = 0;
+    self->initPicBuf = NULL;
+    self->initPicLen = 0;
+}
+
+/**
+    AicMng destructor.
+*/
+static void AicDestroy(AicMng* self)
+{
+    struct list_head *node = NULL;
+    struct list_head *next = NULL;
+
+    self->inited = false;
+
+    list_for_each_safe(node, next, &self->plugInfos) {
+        AiPlugInfoDelete(list_entry(node, AiPlugInfo, lnode));
+    }
+    int ret = list_empty(&self->svcPlugs);
+    HI_ASSERT(ret);
+
+    if (EmDelFd(self->evtMon, self->statusChgFd) < 0) {
+        HI_ASSERT(0);
+    }
+    self->statusChgFd = -1;
+
+    HI_ASSERT(!self->workPlug.itf);
+    HI_ASSERT(!self->aiCalSvc.evtMon);
+    HI_ASSERT(self->aiCalJob.sigFd < 0);
+    HI_ASSERT(!self->aiCalJob.resJson);
+
+    if (self->prevResJson) {
+        free(self->prevResJson);
+        self->prevResJson = NULL;
+    }
+
+    HI_EXP_LOGE(!list_empty(&self->evtUsers), "%d evtUsers leak\n", list_size(&self->evtUsers));
+    while (!list_empty(&self->evtUsers)) {
+        AicEvtUser *user = list_entry(self->evtUsers.next, AicEvtUser, lnode);
+        free(user);
+    }
+
+    HI_EXP_LOGE(!list_empty(&self->aiSvcUsers), "%d aiSvcUsers leak\n", list_size(&self->aiSvcUsers));
+    while (!list_empty(&self->aiSvcUsers)) {
+        AiSvcUser *user = list_entry(self->aiSvcUsers.next, AiSvcUser, lnode);
+        free(user);
+    }
+
+    HI_ASSERT(!self->viSess);
+    HI_ASSERT(!self->vencSess);
+
+    AicFreeInitPic();
+    MutexDestroy(&self->plugMutex);
+
+    if (memset_s(self, sizeof(*self), 0, sizeof(*self)) != EOK) {
+        HI_ASSERT(0);
+    }
+}
+
+/*************************************************************************************************
+    主要直接对外接口
+*************************************************************************************************/
+#define SP_AIC_API
+
+/**
+    初始化.
+*/
+void AicInit(void)
+{
+    HI_ASSERT(!g_aic.inited);
+
+    AicCreate(&g_aic);
+    g_aic.initing = true;
+
+    // 创建与venc关联的OsdSet，供AiCalJob使用
+    HI_ASSERT(!g_aic.osdSet);
+    g_aic.osdSet = OsdsCreate(HI_OSD_BINDMOD_VENC, 0, g_aic.vencChn);
+    HI_ASSERT(g_aic.osdSet);
+
+    // 初始化时扫描一次插件
+    const char* plugDir = GetCfgStr("aic_mng:plug_dir", PLUG_DIR_DEF);
+    PmScanPlug(plugDir, &g_aic.plugInfos);
+    LOGI("AIC: detect %d plugs\n", list_size(&g_aic.plugInfos));
+
+    // 加载需要启动管理服务的插件，并启动其服务
+    if (GetCfgBool("aic_mng:start_plug_svc", false)) {
+        AicStartPlugSvcs();
+    }
+
+    // 加载配置的plugs，因此函数总是在app初始化时执行，这里不创建临时线程执行加载
+    AicPreloadPlugs();
+    g_aic.initing = false;
+}
+
+/**
+    去初始化.
+*/
+void AicExit(void)
+{
+    bool ret = IsMainThrd();
+    HI_ASSERT(ret);
+    HI_ASSERT(g_aic.inited);
+    HI_ASSERT(!g_aic.blkCallNum); // 不能还有耗时操作在执行，由APP确保
+
+    // 手动终止vi/vo，终止vi时会终止AiCalSvc
+    if (g_aic.viType) {
+        AicStopVi(g_aic.viType, g_aic.viByHost);
+    }
+    if (g_aic.voTypes) {
+        AicStopVo(g_aic.voTypes);
+    }
+
+    // 卸载当前插件，由于后台线程均已终止，这里不加锁unload插件也没有问题
+    MutexLock(&g_aic.plugMutex);
+    AicUnloadPlug();
+    MutexUnlock(&g_aic.plugMutex);
+
+    // 终止插件的管理服务，并卸载其插件
+    AicStopPlugSvcs();
+
+    // destroy OsdSet
+    HI_ASSERT(g_aic.osdSet);
+    OsdsClear(g_aic.osdSet);
+    OsdsDestroy(g_aic.osdSet);
+
+    AicDestroy(&g_aic);
+}
+
+/**
+    是否处于UVC strm模式.
+*/
+bool AicInStrm(void)
+{
+    bool ret = IsMainThrd();
+    HI_ASSERT(ret);
+    HI_ASSERT(g_aic.inited);
+    return (g_aic.inited && (g_aic.voTypes & AIC_VOT_UVC));
+}
+
+/**
+    submit 1 jpg.
+*/
+int AicSubmitJpg(uint8_t* data, int len, bool endOfStrm)
+{
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    HI_ASSERT(g_aic.inited);
+    HI_ASSERT(data);
+    VDEC_STREAM_S vdecStrm;
+    HI_S32 ret;
+
+    g_aic.rxPicNum++;
+
+    if (g_aic.viType != AIC_VIT_HOST || g_aic.inTxInitPic) {
+        if (g_aic.rxPicNum > VDEC_FPS_DEF) { // 避免无意义的log，当discard pic数量较大时才log，相当于每秒log一次
+            LOGW("dicard host jpeg, for vdec not ready\n");
+        }
+        ret = -1;
+        goto END;
+    }
+
+    if (memset_s(&vdecStrm, sizeof(vdecStrm), 0, sizeof(vdecStrm)) != EOK) {
+        HI_ASSERT(0);
+    }
+    vdecStrm.u64PTS = 0;
+    vdecStrm.pu8Addr = data;
+    vdecStrm.u32Len = len;
+    vdecStrm.bEndOfFrame = HI_TRUE;
+    vdecStrm.bEndOfStream = endOfStrm ? HI_TRUE : HI_FALSE;
+
+    ret = HI_MPI_VDEC_SendStream(g_aic.vdecChn, &vdecStrm, 0);
+    if (ret != HI_SUCCESS) {
+        LOGE("HI_MPI_VDEC_SendStream FAIL, ret=%#x\n", ret);
+    }
+
+    END:
+        return ret;
+}
+
+/**
+    get vi type.
+*/
+AicViType AicGetViType(void)
+{
+    bool ret = IsMainThrd();
+    HI_ASSERT(ret);
+    HI_ASSERT(g_aic.inited);
+    return g_aic.viType;
+}
+
+/**
+    get vo type.
+*/
+uint32_t AicGetVoTypes(void)
+{
+    bool ret = IsMainThrd();
+    HI_ASSERT(ret);
+    HI_ASSERT(g_aic.inited);
+    return g_aic.voTypes;
+}
+
+/**
+    设置AI插件.
+*/
+int AicSetAiPlug(const char* uuid, AiPlugLib* plugLib, bool reload)
+{
+    uuid = uuid ? uuid : "";
+    AiPlugInfo *info = NULL;
+    int ret;
+
+    __sync_add_and_fetch(&g_aic.blkCallNum, 1);
+    MutexLock(&g_aic.plugMutex);
+
+    const char* curUuid = g_aic.workPlug.uuid ? g_aic.workPlug.uuid : "null";
+    const char* curDesc = g_aic.workPlug.desc ? g_aic.workPlug.desc : "null";
+
+    if (!*uuid) { // uuid为null表示unload操作
+        LOGI("AIC: set plug {'%s', '%s'} => null ...\n", curUuid, curDesc);
+    } else { // load / unload+load操作
+        // 查找plug, 找到则说明是正常的load操作
+        info = AicFindPlug(uuid);
+        HI_EXP_CMD_GOTO(!info, (ret = -1), END, "set plug FAIL, for plug '%s' not found\n", uuid);
+        LOGI("AIC: set plug {'%s', '%s'} => {'%s', '%s'} ...\n", curUuid, curDesc, info->uuid, info->desc);
+    }
+
+    // 如果要load的插件已经被load，且@param reload为false，则忽略该请求
+    bool loaded = g_aic.workPlug.itf && g_aic.workPlug.uuid && strcmp(uuid, g_aic.workPlug.uuid) == 0;
+    if (loaded && !reload) {
+        LOGW("load plug '%s' ignore, for it loaded\n", uuid);
+        ret = 0;
+        goto END;
+    }
+
+    // 如果请求为unload，而当前没有插件被load，则忽略该请求
+    if (!*uuid && !g_aic.workPlug.itf) {
+        LOGW("unload plug ignore, for no working plug\n");
+        ret = 0;
+        goto END;
+    }
+
+    // 先unload当前插件
+    if (g_aic.workPlug.itf) {
+        AicUnloadPlug();
+    }
+
+    // 没有指定uuid，说明只是unload插件
+    ret = *uuid ? AicLoadPlug(uuid, info) : 0;
+
+    END:
+        if (plugLib) {
+            if (ret >= 0) {
+                *plugLib = g_aic.workPlug;
+            } else if (memset_s(plugLib, sizeof(*plugLib), 0, sizeof(*plugLib)) != EOK) {
+                HI_ASSERT(0);
+            }
+            INIT_LIST_HEAD(&plugLib->lnode);
+        }
+
+        // 指示status变更，此函数由后台线程执行，不能直接调用AicGenStatusEvt
+        if (!g_aic.initing) {
+            EventFdInc(g_aic.statusChgFd);
+        }
+
+        LOGI("AIC: set plug '%s' %s\n", uuid, (ret < 0 ? "FAIL" : "done"));
+        MutexUnlock(&g_aic.plugMutex);
+        __sync_sub_and_fetch(&g_aic.blkCallNum, 1);
+        return ret;
+}
+
+/**
+    列表ai插件信息.
+*/
+int AicListAiPlugs(MemBlk** resJson, int rsvSize)
+{
+    bool ret = IsMainThrd();
+    HI_ASSERT(ret);
+    HI_ASSERT(g_aic.inited);
+    HI_ASSERT(resJson);
+    *resJson = NULL;
+    AiPlugInfo *info = NULL;
+    struct list_head *node = NULL;
+    size_t size = 0;
+    int n;
+
+    if (list_empty(&g_aic.plugInfos)) {
+        // 仍然继续后面的打包处理，此时ret=0，表示没有插件
+        LOGW("list ai plugs with 0 plug\n");
+    }
+
+    // 计算输出json所需空间
+    size += rsvSize > 0 ? rsvSize : 0;
+    size += TINY_BUF_SIZE; // header, 实际24就够了
+    n = 0;
+    list_for_each(node, &g_aic.plugInfos) {
+        info = list_entry(node, AiPlugInfo, lnode);
+        HI_ASSERT(info->prof);
+        size += strlen(info->prof);
+        size += TINY_BUF_SIZE; // 组合为大json时的额外开销，实际16就够了
+        n++;
+    }
+
+    HI_ASSERT(size > 0);
+    *resJson = MemBlkNew2(size, rsvSize);
+    HI_ASSERT(*resJson);
+    char *buf = (char*)(*resJson)->data;
+
+    // 组合为大json
+    int len = (*resJson)->len;
+    len += snprintf_s(buf + len, size - len, size - len - 1, "[\n");
+    n = 0;
+    list_for_each(node, &g_aic.plugInfos) {
+        info = list_entry(node, AiPlugInfo, lnode);
+        HI_ASSERT(info->prof);
+
+        if (n > 0) {
+            len += snprintf_s(buf + len, size - len, size - len - 1, ",\n");
+            HI_ASSERT(len < size);
+        }
+        n++;
+        len += snprintf_s(buf + len, size - len, size - len - 1, "%s", info->prof);
+        HI_ASSERT(len < size);
+    }
+    len += snprintf_s(buf + len, size - len, size - len - 1, "\n]");
+
+    HI_ASSERT(len < size);
+    (*resJson)->len = len;
+    return n; // number of plugs
+}
+
+/**
+    列表working plugs.
+*/
+int AicListWorkPlugs(struct list_head* plugInfos)
+{
+    bool ret = IsMainThrd();
+    HI_ASSERT(ret);
+    HI_ASSERT(g_aic.inited);
+    HI_ASSERT(plugInfos);
+    int num = 0;
+
+    // 用小锁来保护对workPlugs的访问，而不能用plugMutex，否则此函数会耗时，增加user使用难度
+    HiGlbLock();
+
+    if (g_aic.workPlug.itf) {
+        HI_ASSERT(g_aic.workPlug.uuid && *g_aic.workPlug.uuid);
+        AiPlugInfo *info = AicFindPlug(g_aic.workPlug.uuid);
+        HI_ASSERT(info); // working plug的信息必然还存在
+
+        // clone一份，并添加到plugInfos中
+        info = AiPlugInfoClone(info);
+        list_add_tail(&info->lnode, plugInfos);
+        num++;
+    }
+
+    HiGlbUnlock();
+    return num;
+}
+
+/**
+    订阅AI计算结果事件.
+*/
+int AicSubsAiSvc(uintptr_t cltId, const char* plugUuid, AiResProc proc, void* user)
+{
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    HI_ASSERT(g_aic.inited);
+    int ret = -1;
+
+    // 未指定plugUuid表示订阅所有plugs的服务
+    if (!plugUuid || !*plugUuid) {
+        AiSvcUser *svcUser = AiSvcUserNew(cltId, "", proc, user); // plugUuid设为null,ensure by xiao
+        list_add_tail(&svcUser->lnode, &g_aic.aiSvcUsers);
+        return 0;
+    }
+
+    // 用小锁来保护对workPlugs的访问，而不能用plugMutex，否则此函数会耗时，增加user使用难度
+    HiGlbLock();
+
+    // 判断plugUuid对应的插件是否处于working状态
+    if (!g_aic.workPlug.itf) {
+        LOGE("subs ai svc FAIL, for no plug in working\n");
+        goto END;
+    }
+    HI_ASSERT(g_aic.workPlug.uuid && *g_aic.workPlug.uuid);
+    if (strcmp(g_aic.workPlug.uuid, plugUuid) != 0) {
+        LOGE("subs ai svc FAIL, for plug '%s' not in working\n", plugUuid);
+        goto END;
+    }
+
+    // 创建AiSvcUser并添加到aiSvcUsers中
+    // 仍然在锁内执行是为了确保注册期间workPlug不会变更，
+    // 以便于将来支持workPlug变更时，注册状态与之保持同步
+    AiSvcUser *svcUser = AiSvcUserNew(cltId, plugUuid, proc, user);
+    list_add_tail(&svcUser->lnode, &g_aic.aiSvcUsers);
+    ret = 0;
+
+    END:
+        HiGlbUnlock();
+        return ret;
+}
+
+/**
+    去订阅AI计算结果事件.
+    因为只有主线程才会执行对aiSvcUsers的修改，且这里不访问workPlug，因此无需加锁.
+*/
+int AicUnsubsAiSvc(uintptr_t cltId, const char* plugUuid)
+{
+    bool ret = IsMainThrd();
+    HI_ASSERT(ret);
+    struct list_head *node = NULL;
+    struct list_head *next = NULL;
+
+    // 匹配后不退出循环，以容错user的重复订阅
+    list_for_each_safe(node, next, &g_aic.aiSvcUsers) {
+        AiSvcUser *svcUser = list_entry(node, AiSvcUser, lnode);
+        if (svcUser->cltId == cltId &&
+            (!plugUuid || !*plugUuid || strcmp(svcUser->plugUuid, plugUuid) == 0)) {
+            list_del(node);
+            free(svcUser);
+        }
+    }
+    return 0;
+}
+
+/**
+    订阅AIC事件(不含AI服务事件).
+*/
+int AicSubsEvt(uintptr_t cltId, const char* evtName, AicEvtProc proc, void* user)
+{
+    bool ret = IsMainThrd();
+    HI_ASSERT(ret);
+    HI_ASSERT(g_aic.inited);
+
+    AicEvtUser *evtUser = AicEvtUserNew(cltId, evtName, proc, user); // ensure by xiao
+    list_add_tail(&evtUser->lnode, &g_aic.evtUsers);
+
+    return 0;
+}
+
+/**
+    去订阅AIC事件(不含AI服务事件).
+*/
+int AicUnsubsEvt(uintptr_t cltId, const char* evtName)
+{
+    bool ret = IsMainThrd();
+    HI_ASSERT(ret);
+    struct list_head *node = NULL;
+    struct list_head *next = NULL;
+
+    // 匹配后不退出循环，以容错user的重复订阅
+    list_for_each_safe(node, next, &g_aic.evtUsers) {
+        AicEvtUser *evtUser = list_entry(node, AicEvtUser, lnode);
+        if (evtUser->cltId == cltId &&
+            (!evtName || !*evtName || strcmp(evtUser->evtName, evtName) == 0)) {
+            list_del(node);
+            free(evtUser);
+        }
+    }
+    return 0;
+}
+
+/**
+    获得当前状态.
+*/
+int AicGetStatus(MemBlk* statusJson)
+{
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    HI_ASSERT(statusJson);
+    struct list_head plugInfos = LIST_HEAD_INIT(plugInfos); // working plug info list
+    int ret;
+
+    MemBlk *blk = statusJson;
+    char *buf = (char*)blk->data;
+    int len = blk->len;
+
+    // 编码begin, VI, VO
+    len += snprintf_s(buf + len, blk->size - len, blk->size - len - 1, "{ \"vi\": %d", g_aic.viType);
+    len += snprintf_s(buf + len, blk->size - len, blk->size - len - 1, ", \"vo\": %u", g_aic.voTypes);
+
+    // 获得workPlugs信息，并编码为JSON数组
+    ret = AicListWorkPlugs(&plugInfos);
+    HI_EXP_RET(ret < 0, ret, "AicListWorkPlugs() FAIL, ret=%d\n", ret);
+    len += snprintf_s(buf + len, blk->size - len, blk->size - len - 1, ", \"workPlugs\": [");
+    bool firstField = true;
+    while (!list_empty(&plugInfos)) {
+        AiPlugInfo *plug = list_entry(plugInfos.next, AiPlugInfo, lnode);
+        len += snprintf_s(buf + len, blk->size - len, blk->size - len - 1, "%s{\"uuid\": \"%s\"}",
+            (firstField ? " " : ", "), plug->uuid);
+        firstField = false;
+        list_del(plugInfos.next);
+        AiPlugInfoDelete(plug);
+    }
+    len += snprintf_s(buf + len, blk->size - len, blk->size - len - 1, " ]}");
+
+    blk->len = len;
+    return 0;
+}
+
+/**
+    注册stream user.
+*/
+bool AicAddStrmUser(const IAicStrmUser* itf, void* user)
+{
+    bool ret = IsMainThrd();
+    HI_ASSERT(ret);
+    HI_ASSERT(itf);
+
+    for (size_t i = 0; i < HI_ARRAY_SIZE(g_aic.strmUserTab); i++) {
+        AicStrmUser *node = &g_aic.strmUserTab[i];
+        if (!node->itf) {
+            node->itf = itf;
+            node->user = user;
+            g_aic.strmUserNum++;
+            return true;
+        }
+    }
+
+    LOGE("add StrmUser FAIL, for tab full, size=%uz\n", g_aic.strmUserNum);
+    return false;
+}
+
+/**
+    注销stream user.
+*/
+bool AicDelStrmUser(const IAicStrmUser* itf, void* user)
+{
+    bool ret = IsMainThrd();
+    HI_ASSERT(ret);
+    HI_ASSERT(itf);
+
+    for (size_t i = 0; i < HI_ARRAY_SIZE(g_aic.strmUserTab); i++) {
+        AicStrmUser *node = &g_aic.strmUserTab[i];
+        if (node->itf == itf && node->user == user) {
+            node->itf = NULL;
+            node->user = NULL;
+            g_aic.strmUserNum--;
+            return true;
+        }
+    }
+
+    LOGE("del StrmUser FAIL, for user not found\n");
+    return false;
+}
+
diff -urpBN hiopenais/src/aic_mng/aic_mng.h hiopenais_modify/src/aic_mng/aic_mng.h
--- hiopenais/src/aic_mng/aic_mng.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/aic_mng/aic_mng.h	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,226 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AIC_MNG_H
+#define AIC_MNG_H
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#include "mpp_sess.h"
+#include "plug_mng.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    video input type.
+    同一时刻，只支持一个来源。
+*/
+typedef enum AicViType {
+    AIC_VIT_NONE = 0,
+    AIC_VIT_SENSOR, // from local sensor, the default
+    AIC_VIT_HOST, // from host (PC/TV)
+    AIC_VIT_FILE, // from file, 暂未支持
+    AIC_VIT_CLOUD, // from cloud，暂未支持
+    AIC_VIT_BUTT
+}AicViType;
+
+/**
+    video output type.
+    非互斥关系，可共存。
+*/
+#define AIC_VOT_UVC     HI_BIT0 // output via UVC
+#define AIC_VOT_IP      HI_BIT1 // output via IP
+#define AIC_VOT_RTSPD   HI_BIT4 // output via RTSPD
+
+/**
+    AI计算结果处理函数类型.
+*/
+typedef void (*AiResProc)(void* user,
+    uint32_t cltId, const char* plugUuid, const char* resJson, int resLen);
+
+/**
+    事件处理函数类型.
+*/
+typedef void (*AicEvtProc)(void* user,
+    uint32_t cltId, const char* evtName, const char* evtJson, int evtLen);
+
+/**
+    aic stream user接口.
+*/
+typedef struct IAicStrmUser {
+    bool (*OnStrmOn)(void* user, int vencChn, PAYLOAD_TYPE_E codecType, int width, int height);
+    void (*OnStrmOff)(void* user);
+    void (*OnVencFrm)(void* user, VencFrm* frm); // VENC out frame
+    void (*OnVideoFrm)(void* user, VIDEO_FRAME_INFO_S* frm); // VI/VPSS out frame
+}IAicStrmUser;
+
+/**
+    前向申明.
+*/
+struct uvc_device_ext; // aic user会包含此头文件，前向申明，以避免此头文件include <uvc_dev.h>.
+
+/**
+    AicMng init/exit.
+*/
+void AicInit(void);
+void AicExit(void);
+
+/**
+    是否处于strm传输状态，供histm_aic使用.
+    用于替换原有的HiStmCheckUvcStatus()。
+*/
+bool AicInStrm(void);
+
+/**
+    submit 1 jpg to venc.
+*/
+int AicSubmitJpg(uint8_t* data, int len, bool endOfStrm);
+
+/**
+    get vi type.
+*/
+AicViType AicGetViType(void);
+
+/**
+    get vo types.
+*/
+uint32_t AicGetVoTypes(void);
+
+/**
+    start/stop VI.
+*/
+int AicStartVi(AicViType viType, bool byHost,
+    int outWidth, int outHeight, PIXEL_FORMAT_E pixFormat);
+int AicStopVi(AicViType viType, bool byHost);
+
+/**
+    start/stop VO.
+
+    @param voType 不能为AIC_VOT_UVC。
+    @param codecType 目前仅支持MJPEG。
+*/
+int AicStartVo(uint32_t voType, int width, int height, PAYLOAD_TYPE_E codecType);
+int AicStopVo(uint32_t voType);
+
+/**
+    stop 所有的vi, vo.
+    NOTE: 不stop AIC_VOT_UVC，这由UVC触发.
+*/
+int AicStopVios(bool byHost);
+
+/**
+    发送初始frame.
+    目前仅供UVC user使用，以绕开UVC必须通过发送数帧以turn strm on的问题.
+*/
+int AicTxInitPic(void);
+
+/**
+    设置ai插件.
+
+    @param uuid 为null string表示unload当前插件，否则表示加载@param uuid指定的插件。
+    @param reload 为true时，即便设置的新插件当前已加载，也重新加载之。
+    @param plug 返回加载的插件的信息，如果是加载操作的话。
+*/
+int AicSetAiPlug(const char* uuid, AiPlugLib* plug, bool reload);
+
+/**
+    列表ai插件信息.
+
+    @param resJson[out]: 返回json格式的插件列表。
+    @param rsvSize[in]: 此函数在创建resJson对象时，在其头部保留的空间(字节长度).
+    @return 成功则返回plug的数量，否则返回负值.
+*/
+int AicListAiPlugs(MemBlk** resJson, int rsvSize);
+
+/**
+    列表working plugs.
+
+    @param plugInfos[out]: 输出working plugs信息。链表节点为AiPlugInfo。
+    @return 成功，则返回输出的working plugs的数目，可能为0。否则返回负数，其值表示错误码。
+*/
+int AicListWorkPlugs(struct list_head* plugInfos);
+
+/**
+    订阅AI服务事件.
+
+    订阅后，当AI计算产生结果时，会调用proc()输出计算结果.
+
+    @param cltId[in]: client ID.
+    @param plugUuid[in]: 表示特定AI服务的插件的ID.
+    @param proc[in]: 输出计算结果的处理函数.
+    @param user[in]: 作为user参数传入aiResProc()的任意类型的指针.
+    @return 成功返回0，否则返回负数，其值表示错误码.
+*/
+int AicSubsAiSvc(uintptr_t cltId, const char* plugUuid, AiResProc proc, void* user);
+
+/**
+    去订阅AI服务事件.
+
+    去订阅此前通过AicSubsAiSvc()订阅的AI服务.
+
+    @param cltId[in]: client ID.
+    @param plugUuid[in]: 表示特定AI服务的插件的ID.
+    @return 成功返回0，否则返回负数，其值表示错误码.
+*/
+int AicUnsubsAiSvc(uintptr_t cltId, const char* plugUuid);
+
+/**
+    订阅AIC事件(不含AI服务事件).
+
+    订阅后，当AIC产生事件时，会调用proc()向用户提交事件.
+
+    @param cltId[in]: client ID.
+    @param evtName[in]: 表示待订阅的事件名称，置为NULL表示订阅所有事件.
+    @param proc[in]: 事件处理函数.
+    @param user[in]: 作为user参数传入aicEvtProc()的任意类型的指针.
+    @return 成功返回0，否则返回负数，其值表示错误码.
+*/
+int AicSubsEvt(uintptr_t cltId, const char* evtName, AicEvtProc proc, void* user);
+
+/**
+    去订阅AIC事件(不含AI服务事件).
+
+    去订阅此前通过AicSubsEvt()订阅的事件.
+
+    @param cltId[in]: client ID.
+    @param evtName[in]: 表示去订阅的事件名称，置为NULL表示去订阅所有事件.
+    @return 成功返回0，否则返回负数，其值表示错误码.
+*/
+int AicUnsubsEvt(uintptr_t cltId, const char* evtName);
+
+/**
+    获得当前状态.
+    @param resJson[out]: 返回JSON格式的状态。
+*/
+int AicGetStatus(MemBlk* resJson);
+
+/**
+    注册stream user.
+*/
+bool AicAddStrmUser(const IAicStrmUser* itf, void* user);
+
+/**
+    注销stream user.
+*/
+bool AicDelStrmUser(const IAicStrmUser* itf, void* user);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // AIC_MNG_H
diff -urpBN hiopenais/src/aic_mng/ai_plug.h hiopenais_modify/src/aic_mng/ai_plug.h
--- hiopenais/src/aic_mng/ai_plug.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/aic_mng/ai_plug.h	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,139 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AI_PLUG_H
+#define AI_PLUG_H
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "hi_comm_video.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    插件应遵循的约定.
+*/
+#define AI_PLUG_MAGIC       0x3D2E837B // 插件应返回的magic
+#define AI_PLUG_EXTNAME     "plug" // 插件文件名后缀
+
+/*
+    避免#include "mmp_img.h"而直接申明要使用的OsdSet类型.
+*/
+typedef struct OsdSet OsdSet;
+
+/**
+    AIC插件接口.
+
+    插件应实现该接口，并通过aic_plug_itf对外暴露。
+
+    hiopenais在获得IAicPlug后，会调用load()加载模型，并调用cal()执行一帧图片的计算。
+    当不再需要使用插件时，hiopenais会调用unlock()卸载模型。
+
+    这里的模型时抽象概念，由插件来定义其含义。插件可以创建任意类型的对象，通过
+    load()返回给hiopenais，hiopenais会透明使用它来调用插件的接口接口。
+*/
+typedef struct AiPlug {
+    /**
+        获取插件profile.
+
+        插件应维持返回的profile的有效性，hiopenais不会复制它。
+
+        @return 返回插件的profile.
+    */
+    const HI_PCHAR (*Prof)(void);
+
+    /**
+        加载模型.
+
+        需要使用插件的计算服务时，hiopenais会调用此函数。
+
+        目前的定义，在插件的生命周期内，hiopenais不会在unload已load的模型前，再次调用
+        此函数重新load。
+
+        @param model[out]: 输出插件创建的模型对象。
+        @param osds[in]: hiopenais创建的OsdSet，插件可维持它，并用其在resFrm中叠加文字。
+        @return 成功则返回0，否则返回负数，其值表示错误码。
+    */
+    int (*Load)(uintptr_t* model, OsdSet* osds);
+
+    /**
+        卸载模型.
+
+        hiopenais调用此函数来卸载模型。此后hiopenais可能会重新调用load()加载模型。
+
+        @param model[in]: load()返回的@param model。
+        @return 成功则返回0，否则返回负数，其值表示错误码。
+    */
+    int (*Unload)(uintptr_t model);
+
+    /**
+        计算一张图片.
+
+        hiopenais传入一帧图片@param srcFrm，插件进行AI计算。插件可以将计算结果以文字、
+        图形(如矩形)叠加到@param resFrm中，并生成结构化JSON数据以表示计算结果。
+
+        hiopenais已经把@param srcFrm的分辨率按插件profile中的要求予以调整。但像素格式，
+        如YUV/RGB，以及单通道/多通道等hiopenais未做转换，需要插件处理。将来hiopenais会做
+        更进一步的处理，以减轻插件开发的负担。
+
+        需要注意的是@srcFrm与@dstFrm的分辨率可能是不同的，插件在resFrm中叠加信息，
+        及生成resJson时需要做坐标转换。插件可以用工具函数rect_box_tran()来转换。
+
+        resJson由插件负责分配，由hiopenais负责释放。
+
+        @param model[in]: load()返回的@param model。
+        @param srcFrm[in]: 待计算的图片帧。
+        @param resFrm[in|out]: 结果帧，插件可在其上叠加图形、文字等信息。
+        @param resJson[out]: 结构化结果数据，JSON格式。其结构由插件自定义。
+        @return 成功则返回0，否则返回负数，其值表示错误码。
+    */
+    int (*Cal)(uintptr_t model, VIDEO_FRAME_INFO_S* srcFrm,
+        VIDEO_FRAME_INFO_S* resFrm, char** resJson);
+
+    /**
+        启动/终止插件管理服务.
+
+        插件可以自定义管理服务，hiopenais会在启动/终止时自动启动/终止该服务。
+
+        插件管理服务的含义由插件定义，hiopenais不做解释。典型的案例时识别类算法的底库管理，
+        插件如果需要在Camera中支持底库管理，可以定义服务来管理底库。
+
+        插件可以使用lite_httpd提供的http服务，在host端通过http与插件管理服务通信。
+
+        startSvc()启动服务。
+        stopSvc()终止服务。
+
+        @return 成功则返回0，否则返回负数，其值表示错误码。
+    */
+    int (*StartSvc)(void);
+    int (*StopSvc)(void);
+}   AiPlug;
+
+/**
+    获取插件接口.
+
+    @param magic[out]: 插件通过它返回AIC_PLUG_MAGIC。
+    @return 返回插件实现的IAicPlug接口。
+*/
+const AiPlug* AiPlugItf(uint32_t* magic);
+typedef const AiPlug* (*AIPlugItfFunc)(uint32_t* magic);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // AI_PLUG_H
diff -urpBN hiopenais/src/aic_mng/ext_plug.c hiopenais_modify/src/aic_mng/ext_plug.c
--- hiopenais/src/aic_mng/ext_plug.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/aic_mng/ext_plug.c	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <limits.h>
+#include <dlfcn.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include "hi_ext_util.h"
+#include "ext_plug.h"
+
+/**
+    杞芥瀹浠跺ㄦ搴.
+*/
+int ExtPlugLoad(ExtPlugLib** self, const char* path)
+{
+    HI_ASSERT(path && *path);
+    HI_ASSERT(self);
+    int ret;
+
+    ExtPlugLib *plug = (ExtPlugLib*)malloc(sizeof(*plug));
+    if (!plug) { // 寮ㄦ杩琛ょ┖澶
+        HI_ASSERT(0);
+    }
+    if (memset_s(plug, sizeof(*plug), 0, sizeof(*plug)) != EOK) {
+        HI_ASSERT(0);
+    }
+    INIT_LIST_HEAD(&plug->lnode);
+
+    void *hnd = dlopen(path, RTLD_LAZY);
+    HI_EXP_GOTO(!hnd, FAIL, "load '%s' FAIL, err='%s, %d'\n", path, strerror(errno), errno);
+
+    dlerror();
+    plug->init = (ExtPlugInitFunc)dlsym(hnd, "ExtPlugInit");
+    HI_EXP_GOTO(dlerror() || !plug->init, FAIL,
+        "load '%s' 'VoPlugItf' FAIL, err='%s, %d'\n", path, strerror(errno), errno);
+
+    dlerror();
+    plug->exit = (ExtPlugExitFunc)dlsym(hnd, "ExtPlugExit");
+    HI_EXP_GOTO(dlerror() || !plug->init, FAIL,
+        "load '%s' 'ExtPlugExit' FAIL, err='%s, %d'\n", path, strerror(errno), errno);
+
+    ret = plug->init(&plug->userItf, &plug->userObj);
+    HI_EXP_GOTO(ret || !plug->userItf, FAIL,
+        "exec init of '%s' FAIL, ret=%d\n", path, ret);
+
+    plug->hnd = hnd;
+    *self = plug;
+    return 0;
+
+    FAIL:
+        if (hnd) {
+            dlclose(hnd);
+        }
+        if (plug) {
+            free(plug);
+        }
+        *self = NULL;
+        return -1;
+}
+
+/**
+    歌浇瀹浠跺ㄦ搴.
+*/
+void ExtPlugUnload(ExtPlugLib* plug)
+{
+    HI_ASSERT(plug);
+    int ret;
+
+    HI_ASSERT(plug->exit);
+    plug->exit();
+
+    HI_ASSERT(plug->hnd);
+    ret = dlclose(plug->hnd);
+    HI_ASSERT(!ret);
+
+    ret = list_empty(&plug->lnode);
+    HI_ASSERT(ret);
+    if (memset_s(plug, sizeof(*plug), 0, sizeof(*plug)) != EOK) {
+        HI_ASSERT(0);
+    }
+    free(plug);
+}
+
diff -urpBN hiopenais/src/aic_mng/ext_plug.h hiopenais_modify/src/aic_mng/ext_plug.h
--- hiopenais/src/aic_mng/ext_plug.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/aic_mng/ext_plug.h	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef EXT_PLUG_H
+#define EXT_PLUG_H
+
+#include "aic_mng.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    插件接口.
+*/
+int ExtPlugInit(const IAicStrmUser** userItf, void** userObj);
+int ExtPlugExit(void);
+
+typedef int (*ExtPlugInitFunc)(const IAicStrmUser** userItf, void** userObj);
+typedef int (*ExtPlugExitFunc)(void);
+
+/**
+    VO插件动态库相关信息.
+*/
+typedef struct ExtPlugLib {
+    struct list_head lnode;
+
+    void* hnd; // lib handle
+    ExtPlugInitFunc init;
+    ExtPlugExitFunc exit;
+
+    const IAicStrmUser* userItf;
+    void *userObj;
+}ExtPlugLib;
+
+/**
+    加载指定的VO插件动态库.
+
+    创建plug，加载动态库，并通过`plug`返回创建的plug。
+    返回的plug应通过`ExtPlugUnload`卸载和释放。
+*/
+int ExtPlugLoad(ExtPlugLib** self, const char* path);
+
+/**
+    卸载指定的VO插件动态库.
+    卸载动态库，并释放`plug`。
+*/
+void ExtPlugUnload(ExtPlugLib* plug);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // EXT_PLUG_H
diff -urpBN hiopenais/src/aic_mng/plug_mng.c hiopenais_modify/src/aic_mng/plug_mng.c
--- hiopenais/src/aic_mng/plug_mng.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/aic_mng/plug_mng.c	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,218 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <limits.h>
+#include <dlfcn.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include "hi_ext_util.h"
+#include "cjson_help.h"
+#include "plug_mng.h"
+
+/**
+    AiPlugInfo create.
+*/
+AiPlugInfo* AiPlugInfoNew(
+    const char* uuid, const char* desc, const char* prof, const char* path, bool mngSvc)
+{
+    AiPlugInfo *self = NULL;
+
+    self = (AiPlugInfo*)malloc(sizeof(*self));
+    HI_ASSERT(self);
+
+    INIT_LIST_HEAD(&self->lnode);
+    HI_ASSERT(uuid && *uuid);
+    self->uuid = HiStrdup(uuid);
+    HI_ASSERT(self->uuid);
+    HI_ASSERT(desc && *desc);
+    self->desc = HiStrdup(desc);
+    HI_ASSERT(self->desc);
+    HI_ASSERT(prof && *prof);
+    self->prof = HiStrdup(prof);
+    HI_ASSERT(self->prof);
+    HI_ASSERT(path && *path);
+    self->path = HiStrdup(path);
+    HI_ASSERT(self->path);
+    self->mngSvc = mngSvc;
+    return self;
+}
+
+/**
+    AiPlugInfo destroy.
+*/
+void AiPlugInfoDelete(AiPlugInfo* self)
+{
+    HI_ASSERT(self);
+
+    if (self->path) {
+        free(self->path);
+    }
+    if (self->prof) {
+        free(self->prof);
+    }
+    if (self->desc) {
+        free(self->desc);
+    }
+    if (self->uuid) {
+        free(self->uuid);
+    }
+    free(self);
+}
+
+/**
+    AiPlugInfo clone.
+*/
+AiPlugInfo* AiPlugInfoClone(AiPlugInfo* self)
+{
+    return AiPlugInfoNew(self->uuid, self->desc, self->prof, self->path, self->mngSvc);
+}
+
+/**
+    瀹褰.
+*/
+int PmScanPlug(const char* dir, struct list_head* plugInfoList)
+{
+    HI_ASSERT(dir && *dir);
+    HI_ASSERT(plugInfoList);
+    int ret = list_empty(plugInfoList);
+    HI_ASSERT(ret);
+    struct dirent *entry = NULL;
+    struct stat statbuf;
+    AiPlugLib plug;
+    char plugPath[PATH_MAX];
+    const char *lastSep = dir[strlen(dir) - 1] == '/' ? "" : "/";
+
+    DIR *dp = opendir(dir);
+    HI_EXP_RET(!dp, -errno, "open dir '%s' FAIL, err='%s, %d'\n", dir, strerror(errno), errno);
+
+    // ㄥョreaddir_r()夸唬
+    while ((entry = readdir(dp)) != NULL) {
+        if (snprintf_s(plugPath, sizeof(plugPath), sizeof(plugPath) - 1, "%s%s%s", dir, lastSep, entry->d_name) < 0) {
+            HI_ASSERT(0);
+        }
+        if (lstat(plugPath, &statbuf) < 0) {
+            LOGW("lstat(%s) FAIL, err='%s, %d'\n", entry->d_name, strerror(errno), errno);
+            continue;
+        }
+        if (S_ISDIR(statbuf.st_mode)) { // 璺宠瀛褰锛涓褰
+            continue;
+        }
+
+        const char* extName = HiPathExt(entry->d_name);
+        if (!extName || strcmp(extName, AI_PLUG_EXTNAME) != 0) {
+            continue;
+        }
+
+        if (PmLoadPlugLib(&plug, plugPath) < 0) {
+            continue;
+        }
+
+        if (!*plug.uuid || !*plug.desc) {
+            LOGW("plug prof ERR, prof.uuid='%s', desc='%s'\n", plug.uuid, plug.desc);
+            PmUnloadPlugLib(&plug);
+            continue;
+        }
+
+        bool mngSvc = plug.itf && plug.itf->StartSvc && plug.itf->StopSvc;
+        AiPlugInfo *plugInfo = AiPlugInfoNew(plug.uuid, plug.desc, plug.profTxt, plugPath, mngSvc);
+        list_add_tail(&plugInfo->lnode, plugInfoList);
+        PmUnloadPlugLib(&plug);
+    }
+
+    closedir(dp);
+    return 0;
+}
+
+/**
+    杞芥瀹浠跺ㄦ搴.
+*/
+int PmLoadPlugLib(AiPlugLib* plug, const char* path)
+{
+    HI_ASSERT(path && *path);
+    HI_ASSERT(plug);
+    uint32_t magic = 0;
+    AIPlugItfFunc rootFunc;
+    int ret = -1;
+
+    if (memset_s(plug, sizeof(*plug), 0, sizeof(*plug)) != EOK) {
+        HI_ASSERT(0);
+    }
+    INIT_LIST_HEAD(&plug->lnode);
+
+    void *hnd = dlopen(path, RTLD_LAZY);
+    HI_EXP_RET(!hnd, -errno, "load '%s' FAIL, err='%s, %d'\n", path, strerror(errno), errno);
+    plug->hnd = hnd;
+
+    dlerror();
+    rootFunc = (AIPlugItfFunc)dlsym(hnd, "AiPlugItf");
+    HI_EXP_GOTO(dlerror() || !rootFunc, ERR_END,
+        "load '%s' 'AiPlugItf' FAIL, err='%s, %d'\n", path, strerror(errno), errno);
+
+    plug->itf = rootFunc(&magic);
+    HI_EXP_GOTO(!plug->itf, ERR_END, "AiPlugItf() return NULL\n");
+
+    HI_EXP_GOTO(magic != AI_PLUG_MAGIC, ERR_END,
+        "AiPlugItf() MAGIC mismatch, res=%08X, accept=%08X\n", magic, AI_PLUG_MAGIC);
+    HI_EXP_GOTO(!plug->itf->Prof || !plug->itf->Load || !plug->itf->Unload || !plug->itf->Cal,
+        ERR_END, "AiPlug has NULL func\n");
+
+    plug->profTxt = plug->itf->Prof();
+    HI_EXP_GOTO(!plug->profTxt || !*plug->profTxt, ERR_END, "AiPlug::prof() ret NULL\n");
+
+    plug->prof = cJSON_Parse(plug->profTxt);
+    HI_EXP_GOTO(!plug->prof, ERR_END, "parse JSON prof FAIL\n");
+    plug->uuid = JsonStr(plug->prof, "uuid", "");
+    plug->desc = JsonStr(plug->prof, "desc", "");
+    plug->width = JsonInt(plug->prof, "frmWidth", -1);
+    plug->height = JsonInt(plug->prof, "frmHeight", -1);
+    plug->model = 0;
+    return 0;
+
+    ERR_END:
+        dlclose(hnd);
+        if (memset_s(plug, sizeof(*plug), 0, sizeof(*plug)) != EOK) {
+            HI_ASSERT(0);
+        }
+        return ret;
+}
+
+/**
+    歌浇瀹浠跺ㄦ搴.
+*/
+int PmUnloadPlugLib(AiPlugLib* plug)
+{
+    HI_ASSERT(plug && plug->hnd);
+    int ret;
+
+    if (plug->prof) {
+        cJSON_Delete(plug->prof);
+    }
+    ret = dlclose(plug->hnd);
+    HI_ASSERT(!ret);
+
+    if (memset_s(plug, sizeof(*plug), 0, sizeof(*plug)) != EOK) {
+        HI_ASSERT(0);
+    }
+    return ret;
+}
+
diff -urpBN hiopenais/src/aic_mng/plug_mng.h hiopenais_modify/src/aic_mng/plug_mng.h
--- hiopenais/src/aic_mng/plug_mng.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/aic_mng/plug_mng.h	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AIC_PLUG_MNG_H
+#define AIC_PLUG_MNG_H
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "ai_plug.h"
+#include "cJSON.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    插件信息.
+*/
+typedef struct AiPlugInfo {
+    struct list_head lnode;
+    char *uuid; // xx.yy.zz
+    char *desc; // description
+    char *prof; // plug profile
+    char *path; // plug file path
+    bool mngSvc; // 是否提供了管理服务
+}   AiPlugInfo;
+
+/**
+    AiPlugInfo create.
+*/
+AiPlugInfo* AiPlugInfoNew(
+    const char* uuid, const char* desc, const char* prof, const char* path, bool mngSvc);
+
+/**
+    AiPlugInfo destroy.
+*/
+void AiPlugInfoDelete(AiPlugInfo* self);
+
+/**
+    AiPlugInfo clone.
+*/
+AiPlugInfo* AiPlugInfoClone(AiPlugInfo* self);
+
+/**
+    插件动态库相关信息.
+*/
+typedef struct AiPlugLib {
+    struct list_head lnode;
+
+    void* hnd; // lib handle
+    const AiPlug* itf; // plug interface
+
+    cJSON *prof;
+    const char* uuid;
+    const char* desc;
+    int width;
+    int height;
+
+    uintptr_t model; // 供app使用，pm_load_plug_lib时不会load模型
+    const char* profTxt; // profile原始文本
+}   AiPlugLib;
+
+/**
+    扫描指定目录.
+*/
+int PmScanPlug(const char* dir, struct list_head* plugInfoList);
+
+/**
+    加载指定插件动态库.
+*/
+int PmLoadPlugLib(AiPlugLib* plug, const char* path);
+
+/**
+    卸载指定插件动态库.
+*/
+int PmUnloadPlugLib(AiPlugLib* plug);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // AIC_PLUG_MNG_H
diff -urpBN hiopenais/src/hi_dev_id/hi_dev_id.c hiopenais_modify/src/hi_dev_id/hi_dev_id.c
--- hiopenais/src/hi_dev_id/hi_dev_id.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_dev_id/hi_dev_id.c	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <signal.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <securec.h>
+#include <mpi_sys.h>
+
+#define LEN_NUM 2
+/**
+    浜杩舵版杞涓hex琛ㄧずstring.
+*/
+static int BinToStr(const void* bin, int binLen, char* str, int strSize)
+{
+    assert(strSize > binLen * LEN_NUM);
+    int len = 0;
+
+    *str = 0;
+    for (int i = 0; i < binLen; i++) {
+        len += snprintf_s(str + len, strSize - len, strSize - len - 1, "%02X", (int)((uint8_t*)bin)[i]);
+        assert(len < strSize);
+    }
+    assert(len == binLen * LEN_NUM);
+    return len;
+}
+
+/**
+    app entry.
+    涓瑕瑰澶缁姝淇″凤杩绋淇″疯缁姝㈡讹exit code藉瀹.
+*/
+int main(int argc, char *argv[])
+{
+    HI_UNIQUE_ID_S uniqueId = { 0 };
+    char chipId[sizeof(uniqueId) * LEN_NUM + 1];
+    int ret;
+
+    ret = HI_MPI_SYS_GetUniqueId(&uniqueId);
+    if (ret) {
+        fprintf(stderr, "GetUniqueId FAIL, ret=%x\n", ret);
+        return ENOENT;
+    }
+
+    BinToStr(&uniqueId, sizeof(uniqueId), chipId, sizeof(chipId));
+    printf("%s\n", chipId);
+    return 0;
+}
+
diff -urpBN hiopenais/src/hi_ext_util/base_adpt.h hiopenais_modify/src/hi_ext_util/base_adpt.h
--- hiopenais/src/hi_ext_util/base_adpt.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/base_adpt.h	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef BASE_ADPT_H
+#define BASE_ADPT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    init.
+*/
+int BaseAdptInit(void);
+
+/**
+    exit.
+*/
+int BaseAdptExit(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // BASE_ADPT_H
diff -urpBN hiopenais/src/hi_ext_util/cjson_help.c hiopenais_modify/src/hi_ext_util/cjson_help.c
--- hiopenais/src/hi_ext_util/cjson_help.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/cjson_help.c	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,127 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdint.h>
+#include <limits.h>
+
+#include "cJSON.h"
+
+#include "hi_ext_util.h"
+#include "cjson_help.h"
+
+/**
+    峰瀹object瀹itemstring.
+*/
+const char* JsonStr(cJSON* obj, const char* itemName, const char* defVal)
+{
+    HI_ASSERT(obj);
+    HI_ASSERT(itemName && *itemName);
+    cJSON *item;
+
+    item = cJSON_GetObjectItem(obj, itemName);
+    if (!item) {
+        return defVal ? defVal : "";
+    }
+
+    if (item->type == cJSON_String) {
+        HI_ASSERT(item->valuestring);
+        return item->valuestring;
+    } else {
+        return defVal ? defVal : "";
+    }
+}
+
+/**
+    峰瀹object瀹itemint.
+*/
+int JsonInt(cJSON* obj, const char* itemName, int defVal)
+{
+    HI_ASSERT(obj);
+    HI_ASSERT(itemName && *itemName);
+    cJSON *item;
+
+    item = cJSON_GetObjectItem(obj, itemName);
+    if (!item) {
+        return defVal;
+    }
+
+    if (item->type == cJSON_Number) {
+        return item->valueint;
+    } else if (item->type == cJSON_String) {
+        HI_ASSERT(item->valuestring);
+        return atoi(item->valuestring);
+    } else {
+        return defVal;
+    }
+}
+
+/**
+    峰瀹object瀹itemdouble.
+*/
+double JsonDouble(cJSON* obj, const char* itemName, double defVal)
+{
+    HI_ASSERT(obj);
+    HI_ASSERT(itemName && *itemName);
+    cJSON *item;
+
+    item = cJSON_GetObjectItem(obj, itemName);
+    if (!item) {
+        return defVal;
+    }
+
+    if (item->type == cJSON_Number) {
+        return item->valueint;
+    } else if (item->type == cJSON_String) {
+        HI_ASSERT(item->valuestring);
+        return strtod(item->valuestring, NULL);
+    } else {
+        return defVal;
+    }
+}
+
+/**
+    峰瀹object瀹itembool.
+*/
+bool JsonBool(cJSON* obj, const char* itemName, bool defVal)
+{
+    HI_ASSERT(obj);
+    HI_ASSERT(itemName && *itemName);
+    cJSON *item;
+
+    item = cJSON_GetObjectItem(obj, itemName);
+    if (!item) {
+        return defVal;
+    }
+
+    if (item->type == cJSON_True) {
+        return true;
+    } else if (item->type == cJSON_False) {
+        return false;
+    } else if (item->type == cJSON_NULL) {
+        return false;
+    } else if (item->type == cJSON_Number) {
+        return item->valueint ? true : false;
+    } else if (item->type == cJSON_String) {
+        HI_ASSERT(item->valuestring);
+        return atoi(item->valuestring) ? true : false;
+    } else {
+        return defVal;
+    }
+}
+
diff -urpBN hiopenais/src/hi_ext_util/cjson_help.h hiopenais_modify/src/hi_ext_util/cjson_help.h
--- hiopenais/src/hi_ext_util/cjson_help.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/cjson_help.h	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CJSON_HELP_H
+#define CJSON_HELP_H
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "cJSON.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    峰瀹object瀹itemstring.
+
+    浠褰item.type涓cJSON_String讹杩item硷杩defVal
+*/
+const char* JsonStr(cJSON* obj, const char* itemName, const char* defVal);
+
+/**
+    峰瀹object瀹itemint.
+
+    浠褰item.type涓cJSON_NumbercJSON_String讹杩item硷杩defVal
+    褰item.type涓cJSON_String讹浼灏string杞涓int杩
+*/
+int JsonInt(cJSON* obj, const char* itemName, int defVal);
+
+/**
+    峰瀹object瀹itemdouble.
+
+    浠褰item.type涓cJSON_NumbercJSON_String讹杩item硷杩defVal
+    褰item.type涓cJSON_String讹浼灏string杞涓double杩
+*/
+double JsonDouble(cJSON* obj, const char* itemName, double defVal);
+
+/**
+    峰瀹object瀹itembool.
+
+    浠褰item.type涓cJSON_True || cJSON_False || cJSON_Number || cJSON_String讹
+    杩item硷杩defVal
+    褰item.type涓cJSON_String || cJSON_Number讹浼灏跺艰浆涓bool杩
+*/
+bool JsonBool(cJSON* obj, const char* itemName, bool defVal);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // CJSON_HELP_H
diff -urpBN hiopenais/src/hi_ext_util/evt_mon.c hiopenais_modify/src/hi_ext_util/evt_mon.c
--- hiopenais/src/hi_ext_util/evt_mon.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/evt_mon.c	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,389 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <pthread.h>
+
+#include "hi_ext_util.h"
+#include "evt_mon.h"
+
+#define EPOLL_RES_EVTS_MAX      10 // epollresult buf size
+
+/**
+    Event handler info.
+*/
+typedef struct EvtProc {
+    struct list_head lnode; // 浣涓洪捐〃
+    EmEvtProc proc; // 浜浠跺芥
+    void *user; // 浜浠跺user
+    int fd; // 寰瑙fd
+}   EvtProc;
+
+/**
+    Event Monitor版.
+*/
+struct EvtMon {
+    struct list_head procList; // 瀛ㄦaddEvtProc
+
+    int epollFd; // epoll fd
+    int abortFd; // quit浜浠剁fd, eventfd()寤
+    int usrFdNum; // usr fd伴锛烘跺涓0锛ㄤ烘堕璇妫娴
+
+    // 变userㄤ浠跺杩绋涓戒や娉ㄥfd锛瑕稿澶
+#   ifndef __HuaweiLite__
+    struct epoll_event waitResEvts[EPOLL_RES_EVTS_MAX]; // ㄤepoll_wait杩缁evts扮
+#   endif
+    int waitResNum; // 褰epoll_wait杩缁evts伴
+
+    pthread_t svcThrdId; // 扮嚎绋ID锛APP杩emon_start()ㄦ℃朵娇
+    pthread_t wdThrdId; // watchdog绾跨ID
+    int wdAbortFd; // watchdog abort fd锛watchdog绾跨ㄥ舵ョquit浜浠
+    int wdCancelFd; // watchdog cancel fd锛ㄤ绀哄wd娑
+};
+
+/**
+    Event check return.
+*/
+void EvtChkRet(uint32_t detectedEvts, uint32_t monitoredEvt, int fd)
+{
+    if ((detectedEvts) & ~(monitoredEvt)) {
+        LOGE("detect un-mon evts, fd=%d, devts=%x, mevt=%x\n", (fd), (detectedEvts), (monitoredEvt));
+    }
+    if (!((detectedEvts) & (monitoredEvt))) {
+        LOGW("detect invalid evts, fd=%d, devts=%x, mevt=%x\n", (fd), (detectedEvts), (monitoredEvt));
+        return;
+    }
+}
+
+/**
+    create EmEvtProc.
+*/
+static EvtProc* EvtProcNew(int fd, EmEvtProc proc, void* user)
+{
+    EvtProc *self;
+
+    self = (EvtProc*)malloc(sizeof(*self));
+    if (!self) {
+        HI_ASSERT(0);
+    }
+    INIT_LIST_HEAD(&self->lnode);
+    self->proc = proc;
+    self->user = user;
+    self->fd = fd;
+    return self;
+}
+
+/**
+    寤EvtMon.
+*/
+int EmCreate(EvtMon** emon)
+{
+    HI_ASSERT(emon);
+    EvtMon *self;
+
+    self = (EvtMon*)malloc(sizeof(*self));
+    HI_ASSERT(self);
+    *emon = self;
+
+    /* init struct parameters */
+    INIT_LIST_HEAD(&self->procList);
+#   ifndef __HuaweiLite__
+    self->epollFd = epoll_create1(EPOLL_CLOEXEC);
+    HI_ASSERT(self->epollFd >= 0);
+#   else
+    self->epollFd = -1;
+#   endif
+    self->abortFd = EventFdCreate();
+    HI_ASSERT(self->abortFd >= 0);
+    self->usrFdNum = 0;
+    self->svcThrdId = pthread_self(); // run()朵琚缃
+    self->wdThrdId = 0;
+    self->wdAbortFd = 0;
+    self->wdCancelFd = 0;
+    return 0;
+}
+
+/**
+    姣EvtMon.
+*/
+void EmDestroy(EvtMon* self)
+{
+    HI_ASSERT(self);
+
+    if (self->abortFd >= 0) {
+        close(self->abortFd);
+    }
+    if (self->epollFd >= 0) {
+        close(self->epollFd);
+    }
+
+    struct list_head *node = NULL;
+    struct list_head *next = NULL;
+    list_for_each_safe(node, next, &self->procList) {
+        EvtProc *proc = list_entry(node, EvtProc, lnode);
+        free(proc);
+    }
+    free(self);
+}
+
+static EvtProc* EmFindFd(EvtMon* self, int fd)
+{
+    struct list_head *node = NULL;
+    struct list_head *next = NULL;
+
+    list_for_each_safe(node, next, &self->procList) {
+        EvtProc *proc = list_entry(node, EvtProc, lnode);
+        if (proc->fd == fd) {
+            return proc;
+        }
+    }
+    return NULL;
+}
+
+/**
+    峰宠＄嚎绋ID.
+*/
+pthread_t EmThrdId(EvtMon* self)
+{
+    HI_ASSERT(self);
+    return self->svcThrdId;
+}
+
+#ifndef __HuaweiLite__
+
+/**
+    娣诲fd浠ョ.
+*/
+int EmAddFd(EvtMon* self, int fd, int evts, EmEvtProc cb, void* user)
+{
+    HI_ASSERT(self);
+    EvtProc *proc = NULL;
+    struct epoll_event ev;
+    int err;
+
+    proc = EvtProcNew(fd, cb, user);
+    if (memset_s(&ev, sizeof(ev), 0, sizeof(ev)) != EOK) {
+        HI_ASSERT(0);
+    }
+    ev.events = evts;
+    ev.data.ptr = proc;
+
+    err = epoll_ctl(self->epollFd, EPOLL_CTL_ADD, fd, &ev);
+    if (err < 0) {
+        LOGE("epoll_ctl for add FAIL, err='%s'\n", strerror(errno));
+        free(proc);
+        return err;
+    }
+
+    list_add_tail(&proc->lnode, &self->procList);
+    self->usrFdNum++;
+    return 0;
+}
+
+/**
+    ゅ规瀹fd.
+*/
+int EmDelFd(EvtMon* self, int fd)
+{
+    HI_ASSERT(self && fd >= 0);
+    EvtProc *proc = NULL;
+    int err;
+
+    proc = EmFindFd(self, fd);
+    if (!proc) {
+        LOGE("del fd FAIL, for fd(%d) not found\n", fd);
+        return -1;
+    }
+
+    // 浠褰缁琛ㄤ腑ユ惧苟璁
+    for (int n = 0; n < self->waitResNum; n++) {
+        // abortEvt涔搴璇ョEvtProc缁
+        if (self->waitResEvts[n].data.fd == self->abortFd) {
+            continue;
+        }
+
+        EvtProc *proc = (EvtProc*)self->waitResEvts[n].data.ptr;
+        if (!proc) {
+            continue;
+        }
+        if (proc->fd == fd) {
+            self->waitResEvts[n].data.ptr = NULL;
+        }
+    }
+
+    err = epoll_ctl(self->epollFd, EPOLL_CTL_DEL, fd, NULL);
+    if (err < 0) {
+        LOGE("epoll_ctl for del FAIL, err='%s'\n", strerror(errno));
+    }
+
+    // 充究epoll_ctl澶辫触锛涔瑕free璇ヨ
+    list_del(&proc->lnode);
+    self->usrFdNum--;
+    HI_ASSERT(self->usrFdNum >= 0);
+    free(proc);
+    return err < 0 ? err : 0;
+}
+
+/**
+    淇圭浜浠剁被.
+*/
+int EmModFd(EvtMon* self, int fd, int evts)
+{
+    HI_ASSERT(0);
+    return -1;
+}
+
+/**
+    杩ョ寰.
+*/
+int EmRun(EvtMon* self)
+{
+    HI_ASSERT(self);
+    struct epoll_event abortEv;
+    int n;
+    int nfds;
+    int err;
+
+    self->svcThrdId = pthread_self();
+
+    if (memset_s(&abortEv, sizeof(abortEv), 0, sizeof(abortEv)) != EOK) {
+        HI_ASSERT(0);
+    }
+    abortEv.events = FDE_IN;
+    abortEv.data.fd = self->abortFd;
+    // add abort event to epoll
+    err = epoll_ctl(self->epollFd, EPOLL_CTL_ADD, self->abortFd, &abortEv);
+    if (err < 0) {
+        return err;
+    }
+
+    // 哄锛瑕浠epoll涓del abortEvt锛绛
+    while (1) {
+        self->waitResNum = 0;
+        if (memset_s(self->waitResEvts, sizeof(self->waitResEvts), 0, sizeof(self->waitResEvts)) != EOK) {
+            HI_ASSERT(0);
+        }
+        nfds = epoll_wait(self->epollFd, self->waitResEvts, EPOLL_RES_EVTS_MAX, -1);
+        if (nfds < 0) {
+            continue;
+        }
+        self->waitResNum = nfds;
+
+        for (n = 0; n < nfds; n++) {
+            // abortEvt涔搴璇ョEvtProc缁
+            // receive quit event ,exit event monitor immediately
+            if (self->waitResEvts[n].data.fd == self->abortFd) {
+                // poll all events in abortEvt for reuse later
+                EventFdClear(self->abortFd);
+                self->waitResNum = nfds;
+                return 0;
+            }
+
+            EvtProc *proc = (EvtProc*)self->waitResEvts[n].data.ptr;
+            if (!proc) {
+                LOGD("discard evt for fd removed\n");
+                continue;
+            }
+
+            HI_ASSERT(proc);
+            if (proc->proc) {
+                // NOTE: userㄤ浠跺跺戒ゅ凡缁浜х浜浠剁fd
+                proc->proc(proc->user, proc->fd, self->waitResEvts[n].events);
+            }
+        }
+    }
+}
+
+#else // __HuaweiLite__
+
+int EmAddFd(EvtMon* self, int fd, int evts, EmEvtProc cb, void* user)
+{
+    HI_ASSERT(0);
+    return -1;
+}
+
+int EmDelFd(EvtMon* self, int fd)
+{
+    HI_ASSERT(0);
+    return -1;
+}
+
+int EmRun(EvtMon* self)
+{
+    HI_ASSERT(0);
+    return -1;
+}
+
+#endif // __HuaweiLite__
+
+/**
+    璇锋缁姝㈡.
+    姝ゅ芥伴瀹颁负淇″峰ㄣ
+*/
+int EmQuit(EvtMon* self)
+{
+    HI_ASSERT(self);
+    HI_ASSERT(self->abortFd >= 0);
+
+    EventFdInc(self->abortFd);
+    return 0;
+}
+
+/**
+    EvtMon＄嚎绋.
+*/
+static void* EmThrd(void* param)
+{
+    EvtMon* self = (EvtMon*)param;
+    EmRun(self);
+    return NULL;
+}
+
+/**
+    ㄧ.
+*/
+int EmStart(EvtMon* self)
+{
+    HI_ASSERT(self);
+    pthread_t thrdId;
+
+    if ((pthread_create(&thrdId, NULL, EmThrd, self)) == -1) {
+        LOGE("create thread FAIL, err='%s, %d'\n", strerror(errno), errno);
+        return -1;
+    }
+    self->svcThrdId = thrdId;
+    return 0;
+}
+
+/**
+    缁姝㈢.
+*/
+int EmStop(EvtMon* self)
+{
+    HI_ASSERT(self);
+    void *res = NULL;
+
+    LOGI("EMON: wait svc thrd end ...\n");
+    EmQuit(self);
+    HI_ASSERT(self->svcThrdId > 0);
+    pthread_join(self->svcThrdId, &res);
+    self->svcThrdId = 0;
+    LOGI("EMON: wait svc thrd end done\n");
+    return 0;
+}
+
diff -urpBN hiopenais/src/hi_ext_util/evt_mon.h hiopenais_modify/src/hi_ext_util/evt_mon.h
--- hiopenais/src/hi_ext_util/evt_mon.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/evt_mon.h	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,140 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef EVT_MON_H
+#define EVT_MON_H
+
+#include <stdint.h>
+#ifdef __HuaweiLite__
+#include <poll.h>
+#else
+#include <sys/epoll.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    fd事件类型.
+
+    重定义类型，以屏蔽实现差异。可以基于epoll/poll/select实现EvtMon。
+
+    下列事件不需要显示指定监听类型，fd被监听时，它们会被自动监听
+    +  FDE_ERR
+    +  FDE_HUP
+*/
+#ifdef __HuaweiLite__
+#define FDE_IN      POLLIN // 有数据到达，fd可读
+#define FDE_OUT     POLLOUT // 发送缓冲变空，fd可写
+#define FDE_PRI     POLLPRI // 优先数据(外带数据)达到
+#define FDE_ERR     POLLERR // 检测到错误
+#define FDE_HUP     POLLHUP // 检测到hang up
+// poll不支持ET
+#define FDE_ET      HI_BIT15 // 边缘触发，仅作为事件选项使用，EvtMon不会产生该事件
+#else
+#define FDE_IN      EPOLLIN // 有数据到达，fd可读
+#define FDE_OUT     EPOLLOUT // 发送缓冲变空，fd可写
+#define FDE_PRI     EPOLLPRI // 优先数据(外带数据)达到
+#define FDE_ERR     EPOLLERR // 检测到错误
+#define FDE_HUP     EPOLLHUP // 检测到hang up
+#define FDE_ET      EPOLLET // 边缘触发，仅作为事件选项使用，EvtMon不会产生该事件
+#endif // __HuaweiLite__
+
+/**
+    校验被监听的单个事件.
+    用于事件处理函数，简化代码书写。
+*/
+void EvtChkRet(uint32_t detectedEvts, uint32_t monitoredEvt, int fd);
+
+/**
+    fd event处理函数类型.
+*/
+typedef void (*EmEvtProc) (void* user, int fd, uint32_t evts);
+
+/**
+    EvtMon对象类型.
+    所有数据成员均为私有，定义在.c中。
+*/
+typedef struct EvtMon EvtMon;
+
+/**
+    创建EvtMon.
+*/
+int EmCreate(EvtMon** self);
+
+/**
+    销毁EvtMon.
+*/
+void EmDestroy(EvtMon* self);
+
+/**
+    获得关联的服务线程的ID.
+*/
+pthread_t EmThrdId(EvtMon* self);
+
+/**
+    添加fd以监听.
+*/
+int EmAddFd(EvtMon* self, int fd, int evts, EmEvtProc cb, void* user);
+
+/**
+    删除对指定fd的所有监听.
+*/
+int EmDelFd(EvtMon* self, int fd);
+
+/**
+    修改监听事件类型.
+*/
+int EmModFd(EvtMon* self, int fd, int evts);
+
+/**
+    进入监听循环.
+
+    此函数会进入死循环，直到emon_quit()被调用。因此，APP应创建线程来执行此函数。
+    APP也可直接调用emon_start()启动服务，emon_start()会创建后台线程执行此函数。
+*/
+int EmRun(EvtMon* self);
+
+/**
+    请求终止服务.
+
+    它会触发让emon_run()退出循环的事件。
+    此函数信号安全，不会调用非异步安全函数，可以用于信号处理函数中。
+*/
+int EmQuit(EvtMon* self);
+
+/**
+    启动监听服务.
+
+    创建后台线程执行emon_run()。
+    此函数会立刻返回，不会阻塞。
+    APP通过调用emon_stop()终止服务。
+*/
+int EmStart(EvtMon* self);
+
+/**
+    终止监听服务.
+
+    此函数用来终止用emon_start()创建的服务。
+    其会先执行emon_quit()，并等待后台线程结束后再返回。
+*/
+int EmStop(EvtMon* self);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // EVT_MON_H
diff -urpBN hiopenais/src/hi_ext_util/hi_app_base.c hiopenais_modify/src/hi_ext_util/hi_app_base.c
--- hiopenais/src/hi_ext_util/hi_app_base.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/hi_app_base.c	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,280 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <limits.h>
+#include <unistd.h>
+#include <signal.h>
+
+#include "iniparser.h"
+#include "hi_ext_util.h"
+#include "hi_app_base.h"
+
+#define CFG_KEY_MAX         256 // config key buf澶ч垮害
+#define WAIT_QUIT_TMOUT     9000 // reboot绛寰堕
+
+static dictionary *g_appCfg = NULL; // ㄥ缃
+static pthread_t g_mainThrdId = 0; // 涓荤嚎绋ID锛璋app_base_init()绾跨
+static EvtMon *g_mainEvtMon = NULL; // 涓荤嚎绋宠EvtMon
+static bool g_rebootReq = false; // 琚璇锋reboot
+static pthread_t g_wdThrdId = 0; // watchdog thread id
+
+/**
+    杩ㄧ嚎绋ュwatchdog timer.
+*/
+static void* WatchdogThrd(void* param)
+{
+    long timeout = (long)(uintptr_t)param;
+    HI_ASSERT(timeout > 0);
+    usleep(timeout * HI_USLEEP_MS);
+
+    if (g_rebootReq) {
+        LOGE("@@@  app quit watchdog timeout, reboot system\n");
+        kill(1, SIGTERM);
+    } else {
+        LOGE("@@@ app quit watchdog timeout, exit proc\n");
+        _exit(HI_EC_WD_TIMEOUT);
+    }
+    return NULL;
+}
+
+/**
+    app base濮.
+*/
+int AppBaseInit(const char* cfgFilePath)
+{
+    // 涓璁搁澶init
+    HI_ASSERT(!g_mainThrdId);
+    HI_ASSERT(!g_mainEvtMon);
+
+    g_mainThrdId = pthread_self();
+    LOGI("mainThrdId=%ld\n", (long)g_mainThrdId);
+
+    if (cfgFilePath && *cfgFilePath) {
+        g_appCfg = iniparser_load(cfgFilePath);
+        if (!g_appCfg) {
+            LOGE("load '%s' FAIL, all config to default\n", cfgFilePath);
+        }
+    } else {
+        LOGW("no config file provided, all config to default\n");
+        g_appCfg = NULL;
+    }
+
+    if (EmCreate(&g_mainEvtMon) < 0) {
+        HI_ASSERT(0);
+    }
+    return 0;
+}
+
+/**
+    app base诲濮.
+*/
+void AppBaseExit(void)
+{
+    // 涓璁搁澶exit
+    HI_ASSERT(g_mainEvtMon);
+    bool ret = IsMainThrd();
+    HI_ASSERT(ret);
+
+    // 妫娴mainEvtMon宸茬哄惊
+    EmDestroy(g_mainEvtMon);
+    g_mainEvtMon = NULL;
+    g_mainThrdId = 0;
+
+    if (g_appCfg) {
+        iniparser_freedict(g_appCfg);
+        g_appCfg = NULL;
+    }
+
+    // reboot澶
+    if (g_rebootReq) {
+        LOGI("@@@ kill(1, SIGINT) to reboot\n");
+        kill(1, SIGINT);
+    }
+    g_wdThrdId = 0;
+}
+
+/**
+    watchdog.
+*/
+void StartAppWd(long watchdogTimeout)
+{
+    if (g_wdThrdId) {
+        LOGW("start watchdog ignore, for it started\n");
+        return;
+    }
+
+    watchdogTimeout = watchdogTimeout < 0 ? WAIT_QUIT_TMOUT : watchdogTimeout;
+    if (watchdogTimeout > 0) {
+        LOGI("@@@ start watchdog, timeout=%ldms\n", watchdogTimeout);
+        DetachThreadCreate(&g_wdThrdId, WatchdogThrd, (void*)(uintptr_t)watchdogTimeout);
+    } else {
+        LOGW("start watchdog ignore, for timeout=0\n");
+    }
+}
+
+/**
+    璇锋reboot绯荤.
+    瀵逛reboot锛涓虹‘淇介杩绋骞reboot锛ㄦゅ芥颁腑存start watchdog.
+*/
+void RebootSystem(long watchdogTimeout)
+{
+    // 瑕watchdog锛quit main emon
+    LOGI("@@@ reboot req, quit main thrd loop\n");
+    g_rebootReq = true;
+    StartAppWd(watchdogTimeout);
+    EmQuit(MainEvtMon());
+}
+
+/**
+    杩涓荤嚎绋ID.
+*/
+pthread_t MainThrdId(void)
+{
+    HI_ASSERT(g_mainThrdId);
+    return g_mainThrdId;
+}
+
+/**
+    杩涓荤嚎绋宠EvtMon.
+*/
+EvtMon* MainEvtMon(void)
+{
+    HI_ASSERT(g_mainEvtMon);
+    return g_mainEvtMon;
+}
+
+/**
+    ゆ褰绾跨涓荤嚎绋.
+*/
+bool IsMainThrd(void)
+{
+    return pthread_self() == g_mainThrdId;
+}
+
+/**
+    峰key瀵瑰int缃椤.
+*/
+int GetCfgInt(const char* key, int defVal)
+{
+    HI_ASSERT(key && *key);
+    return g_appCfg ? iniparser_getint(g_appCfg, key, defVal) : defVal;
+}
+
+/**
+    峰key瀵瑰double缃椤.
+*/
+double GetCfgDouble(const char* key, double defVal)
+{
+    HI_ASSERT(key && *key);
+    return g_appCfg ? iniparser_getdouble(g_appCfg, key, defVal) : defVal;
+}
+
+/**
+    峰key瀵瑰bool缃椤.
+*/
+bool GetCfgBool(const char* key, bool defVal)
+{
+    static const size_t trueSize = 4;
+    static const size_t falseSize = 5;
+    const char *val;
+
+    val = GetCfgStr(key, NULL);
+    if (val && *val) {
+        if (val[0] == '1' || val[0] == 'y' || val[0] == 'Y') {
+            return true;
+        } else if (val[0] == '0' || val[0] == 'n' || val[0] == 'N') {
+            return false;
+        } else if (HiStrincmp(val, "true", trueSize) == 0) {
+            return true;
+        } else if (HiStrincmp(val, "false", falseSize) == 0) {
+            return false;
+        } else {
+            return defVal;
+        }
+    } else {
+        return defVal;
+    }
+}
+
+/**
+    峰key瀵瑰string缃椤.
+*/
+const char* GetCfgStr(const char* key, const char* defVal)
+{
+    HI_ASSERT(key && *key);
+    return g_appCfg ? iniparser_getstring(g_appCfg, key, defVal) : defVal;
+}
+
+/**
+    峰section+field瀵瑰int缃椤.
+*/
+int SectGetCfgInt(const char* section, const char* field, int defVal)
+{
+    HI_ASSERT(field && *field);
+    char key[CFG_KEY_MAX];
+
+    if (snprintf_s(key, sizeof(key), sizeof(key) - 1, "%s:%s", (section ? section : ""), field) < 0) {
+        HI_ASSERT(0);
+    }
+    return GetCfgInt(key, defVal);
+}
+
+/**
+    峰section+field瀵瑰double缃椤.
+*/
+double SectGetCfgDouble(const char* section, const char* field, double defVal)
+{
+    HI_ASSERT(field && *field);
+    char key[CFG_KEY_MAX];
+
+    if (snprintf_s(key, sizeof(key), sizeof(key) - 1, "%s:%s", (section ? section : ""), field) < 0) {
+        HI_ASSERT(0);
+    }
+    return GetCfgDouble(key, defVal);
+}
+
+/**
+    峰section+field瀵瑰bool缃椤.
+*/
+bool SectGetCfgBool(const char* section, const char* field, bool defVal)
+{
+    HI_ASSERT(field && *field);
+    char key[CFG_KEY_MAX];
+
+    if (snprintf_s(key, sizeof(key), sizeof(key) - 1, "%s:%s", (section ? section : ""), field) < 0) {
+        HI_ASSERT(0);
+    }
+    return GetCfgBool(key, defVal);
+}
+
+/**
+    峰section+field瀵瑰string缃椤.
+*/
+const char* SectGetCfgStr(const char* section, const char* field, const char* defVal)
+{
+    HI_ASSERT(field && *field);
+    char key[CFG_KEY_MAX];
+
+    if (snprintf_s(key, sizeof(key), sizeof(key) - 1, "%s:%s", (section ? section : ""), field) < 0) {
+        HI_ASSERT(0);
+    }
+    return GetCfgStr(key, defVal);
+}
+
diff -urpBN hiopenais/src/hi_ext_util/hi_app_base.h hiopenais_modify/src/hi_ext_util/hi_app_base.h
--- hiopenais/src/hi_ext_util/hi_app_base.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/hi_app_base.h	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HI_APP_BASE_H
+#define HI_APP_BASE_H
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "evt_mon.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    app base濮.
+
+    appㄦ惰ㄦゅ芥板瀵app base濮
+    ц姝ゅ芥扮绾跨灏琚璁剧疆涓轰富绾跨锛姝ゅ芥板涓哄跺寤EvtMon
+    瀹浼灏ㄥ缃浠load板瀛锛user杩cfg_get_xxx()璇诲缃
+
+    @param cfgFilePath[in]: ㄥ缃浠跺ㄨ矾寰
+*/
+int AppBaseInit(const char* cfgFilePath);
+
+/**
+    app base诲濮.
+
+    app烘跺璋ㄦゅ芥板瀵app base诲濮
+    AppBaseInit()涓loadㄥ缃浼琚俱
+*/
+void AppBaseExit(void);
+
+/**
+    watchdog.
+
+    浠ヨ剧疆watchdogTimeoutュwatchdog timer褰timer版锛ヨ绋杩缁姝锛
+    璇存绋搴bug锛涓芥ｅ父猴姝ゆapp base浼exit杩绋
+
+    @param watchdogTimeout[in]:
+        0琛ㄧず涓watchdog锛
+        >0琛ㄧず锛跺间负timeout(ms)锛
+        <0琛ㄧず锛timeout涓洪璁ゅ.
+ */
+void StartAppWd(long watchdogTimeout);
+
+/**
+    璇锋reboot绯荤.
+
+    瀹浼璇锋涓荤嚎绋轰浠跺惊锛璁剧疆蹇锛app_base_exit()跺绯荤璇锋reboot绯荤
+
+    浠ヨ剧疆@watchdogTimeoutュwatchdog timer褰timer版锛ヨ绋杩缁姝锛
+    璇存绋搴bug锛涓芥ｅ父猴姝ゆapp base浼寮鸿reboot绯荤
+
+    @param watchdogTimeout[in]: 瑙app_quit_req()涓拌存
+*/
+void RebootSystem(long watchdogTimeout);
+
+/**
+    杩涓荤嚎绋ID.
+*/
+pthread_t MainThrdId(void);
+
+/**
+    杩涓荤嚎绋宠EvtMon.
+*/
+EvtMon* MainEvtMon(void);
+
+/**
+    ゆ褰绾跨涓荤嚎绋.
+*/
+bool IsMainThrd(void);
+
+/**
+    峰缃椤.
+
+    褰@param key涓瀛ㄦ讹杩@param defVal.
+
+    @param key[in]: 缃椤key锛煎涓"section:field".
+    @param defVal[in]: 缃椤归璁ゅ笺
+    @return 杩缃椤圭兼榛璁ゅ笺
+*/
+int GetCfgInt(const char* key, int defVal);
+double GetCfgDouble(const char* key, double defVal);
+bool GetCfgBool(const char* key, bool defVal);
+const char* GetCfgStr(const char* key, const char* defVal);
+
+/**
+    峰缃椤.
+
+    褰@param section@param field涓瀛ㄦ讹杩@param defVal.
+
+    @param key[in]: 缃椤section.
+    @param key[in]: 缃椤field.
+    @param defVal[in]: 缃椤归璁ゅ笺
+    @return 杩缃椤圭兼榛璁ゅ笺
+*/
+int SectGetCfgInt(const char* section, const char* field, int defVal);
+double SectGetCfgDouble(const char* section, const char* field, double defVal);
+bool SectGetCfgBool(const char* section, const char* field, bool defVal);
+const char* SectGetCfgStr(const char* section, const char* field, const char* defVal);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // HI_APP_BASE_H
diff -urpBN hiopenais/src/hi_ext_util/hi_dbg_log.c hiopenais_modify/src/hi_ext_util/hi_dbg_log.c
--- hiopenais/src/hi_ext_util/hi_dbg_log.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/hi_dbg_log.c	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+#include <errno.h>
+
+#include "hi_ext_def.h"
+#include "hi_dbg_log.h"
+
+/**
+    debug level.
+*/
+int g_hiDbgLev = HI_DLEV_INFO;
+
+/**
+    set level.
+*/
+void HiSetDbgLev(int lev)
+{
+    if (lev < 0 || lev >= HI_DLEV_BUTT) { // error
+        printf("\033[;31m" "set dbg lev FAIL, lev=%d, range={%d~%d}\n" "\033[0m", lev, 0, HI_DLEV_BUTT - 1);
+    } else if (lev != g_hiDbgLev) { // warn
+        printf("\033[1;35m" "dbg lev changed, %d -> %d\n" "\033[0m", g_hiDbgLev, lev);
+        g_hiDbgLev = lev; // 锛瀹
+    }
+}
+
+/**
+    assert澶.
+*/
+void HiAssertErr(const char* file, int line, const char* func, const char* exp)
+{
+    printf("\033[1;31m" "HI_ASSERT: %s[%d](%s): '%s'\n" "\033[0m", HiPathName(file), line, func, exp);
+    exit(HI_EC_ASSERT_FAIL);
+}
+
diff -urpBN hiopenais/src/hi_ext_util/hi_dbg_log.h hiopenais_modify/src/hi_ext_util/hi_dbg_log.h
--- hiopenais/src/hi_ext_util/hi_dbg_log.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/hi_dbg_log.h	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,234 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HI_DBG_LOG_H
+#define HI_DBG_LOG_H
+
+#include <stdio.h>
+#include "hi_str_util.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    debug log level.
+*/
+#define HI_DLEV_NONE        0 // disable
+#define HI_DLEV_ERR         1 // error
+#define HI_DLEV_WARN        2 // warning
+#define HI_DLEV_INFO        3 // informational
+#define HI_DLEV_DBG         4 // debug normal
+#define HI_DLEV_VERB        5 // debug vervose
+#define HI_DLEV_BUTT        6
+
+/**
+    log on special level.
+
+    color: E=red, W=yellow, I=default, D=green, V=gray
+*/
+#define LOGE(format, ...) LOG_WITH_FLF(HI_DLEV_ERR, "\033[;31m" "%s[%d](%s): " format "\033[0m", ##__VA_ARGS__)
+#define LOGW(format, ...) LOG_WITH_FLF(HI_DLEV_WARN, "\033[;35m" "%s[%d](%s): " format "\033[0m", ##__VA_ARGS__)
+#define LOGI(format, ...) LOG_ONLY(HI_DLEV_INFO, format, ##__VA_ARGS__)
+#define LOGD(format, ...) LOG_WITH_FLF(HI_DLEV_DBG, "\033[;32m" "%s[%d](%s): " format "\033[0m", ##__VA_ARGS__)
+#define LOGV(format, ...) LOG_WITH_FLF(HI_DLEV_VERB, "\033[2m" "%s[%d](%s): " format "\033[0m", ##__VA_ARGS__)
+
+#define DOLOGE(cmd) DOLOG_WITH_FLF(HI_DLEV_ERR, "\033[;31m", (cmd))
+#define DOLOGW(cmd) DOLOG_WITH_FLF(HI_DLEV_ERR, "\033[;35m", (cmd))
+#define DOLOGI(cmd) DOLOG_NO_COLOR(HI_DLEV_ERR, (cmd))
+#define DOLOGD(cmd) DOLOG_WITH_FLF(HI_DLEV_ERR, "\033[;32m", (cmd))
+#define DOLOGV(cmd) DOLOG_WITH_FLF(HI_DLEV_ERR, "\033[2m", (cmd))
+
+/**
+    log with file/name.
+*/
+#define LOG_ONLY(lev, format, ...) do { \
+    if (g_hiDbgLev >= (lev)) { \
+        printf(format, ##__VA_ARGS__); \
+    } \
+}   while (0)
+
+/**
+    log with file/name/function.
+*/
+#define LOG_WITH_FLF(lev, format, ...) do { \
+    if (g_hiDbgLev >= (lev)) { \
+        printf(format, HiPathName(__FILE__), __LINE__, __FUNCTION__, ##__VA_ARGS__); \
+    } \
+}   while (0)
+
+/**
+    log with file/name.
+*/
+#define DOLOG_NO_COLOR(lev, cmd) do { \
+    if (g_hiDbgLev >= (lev)) { \
+        (cmd); \
+    } \
+}   while (0)
+
+/**
+    log with file/name.
+*/
+#define DOLOG_WITH_FLF(lev, color, cmd) do { \
+    if (g_hiDbgLev >= (lev)) { \
+        printf(color "%s[%d](%s): ", HiPathName(__FILE__), __LINE__, __FUNCTION__); \
+        (cmd); \
+        printf("\033[0m"); \
+    } \
+}   while (0)
+
+/**
+    Check ret, return when FAIL.
+*/
+#define HI_CHK_RET(ret, format, ...) do { \
+    if ((ret) != 0) { \
+        LOGE(format, ##__VA_ARGS__); \
+        return ret; \
+    } \
+}   while (0)
+
+/**
+    Check ret, return when FAIL.
+*/
+#define HI_CHK_WRET(ret, format, ...) do { \
+    if ((ret) != 0) { \
+        LOGW(format, ##__VA_ARGS__); \
+        return ret; \
+    } \
+}   while (0)
+
+/**
+    Check ret, goto label when FAIL.
+*/
+#define HI_CHK_GOTO(ret, label, format, ...) do { \
+    if ((ret) != 0) { \
+        LOGE(format, ##__VA_ARGS__); \
+        goto label; \
+    } \
+}   while (0)
+
+/**
+    Check ret, goto label when FAIL.
+*/
+#define HI_CHK_WGOTO(ret, label, format, ...) do { \
+    if ((ret) != 0) { \
+        LOGW(format, ##__VA_ARGS__); \
+        goto label; \
+    } \
+}   while (0)
+
+/**
+    Check exp, return when exp true.
+*/
+#define HI_EXP_RET(exp, retVal, format, ...) do { \
+    if (exp) { \
+        LOGE(format, ##__VA_ARGS__); \
+        return (retVal); \
+    } \
+}   while (0)
+#define HI_EXP_RET_NONE(exp, format, ...) do { \
+    if (exp) { \
+        LOGE(format, ##__VA_ARGS__); \
+        return; \
+    } \
+}   while (0)
+
+/**
+    Check exp, return when exp true.
+*/
+#define HI_EXP_WRET(exp, retVal, format, ...) do { \
+    if (exp) { \
+        LOGW(format, ##__VA_ARGS__); \
+        return (retVal); \
+    } \
+}   while (0)
+#define HI_EXP_WRET_NONE(exp, format, ...) do { \
+    if (exp) { \
+        LOGW(format, ##__VA_ARGS__); \
+        return; \
+    } \
+}   while (0)
+
+/**
+    Check exp, LOG when exp true.
+*/
+#define HI_EXP_LOGE(exp, format, ...) do { \
+    if (exp) { \
+        LOGE(format, ##__VA_ARGS__); \
+    } \
+}   while (0)
+#define HI_EXP_LOGW(exp, format, ...) do { \
+    if (exp) { \
+        LOGE(format, ##__VA_ARGS__); \
+    } \
+}   while (0)
+
+/**
+    Check exp, goto label when exp true.
+*/
+#define HI_EXP_GOTO(exp, label, format, ...) do { \
+    if (exp) { \
+        LOGE(format, ##__VA_ARGS__); \
+        goto label; \
+    } \
+}   while (0)
+
+/**
+    Check exp, goto label when exp true.
+*/
+#define HI_EXP_WGOTO(exp, label, format, ...) do { \
+    if (exp) { \
+        LOGW(format, ##__VA_ARGS__); \
+        goto label; \
+    } \
+}   while (0)
+
+/**
+    Check exp, exec cmdExp and goto label when exp true.
+*/
+#define HI_EXP_CMD_GOTO(exp, cmdExp, label, format, ...) do { \
+    if (exp) { \
+        LOGE(format, ##__VA_ARGS__); \
+        (cmdExp); \
+        goto label; \
+    } \
+}   while (0)
+
+/**
+    Check exp, exec cmdExp and goto label when exp true.
+*/
+#define HI_EXP_CMD_WGOTO(exp, cmdExp, label, format, ...) do { \
+    if (exp) { \
+        LOGW(format, ##__VA_ARGS__); \
+        (cmdExp); \
+        goto label; \
+    } \
+}   while (0)
+
+/**
+    debug level.
+*/
+extern int g_hiDbgLev;
+
+/**
+    set level.
+*/
+void HiSetDbgLev(int lev);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // HI_DBG_LOG_H
diff -urpBN hiopenais/src/hi_ext_util/hi_ext_def.h hiopenais_modify/src/hi_ext_util/hi_ext_def.h
--- hiopenais/src/hi_ext_util/hi_ext_def.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/hi_ext_def.h	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HI_EXT_DEF_H
+#define HI_EXT_DEF_H
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    bit常量.
+*/
+#define HI_BIT0             0x01U
+#define HI_BIT1             0x02U
+#define HI_BIT2             0x04U
+#define HI_BIT3             0x08U
+#define HI_BIT4             0x10U
+#define HI_BIT5             0x20U
+#define HI_BIT6             0x40U
+#define HI_BIT7             0x80U
+#define HI_BIT8             0x0100U
+#define HI_BIT9             0x0200U
+#define HI_BIT10            0x0400U
+#define HI_BIT11            0x0800U
+#define HI_BIT12            0x1000U
+#define HI_BIT13            0x2000U
+#define HI_BIT14            0x4000U
+#define HI_BIT15            0x8000U
+
+/**
+    常用数字单位.
+*/
+#define HI_KB               1024
+#define HI_MB               (1024 * 1024)
+#define HI_MS_OF_SEC        1000 // 1s的毫秒数
+#define HI_NS_OF_MS         1000000 // 1ms的纳秒数
+#define HI_BYTE_BITS        8 // 1byte的bits数
+#define HI_OVEN_BASE        2 // 偶数基数
+#define HI_INT8_BITS        8 // 8位整数的bit数
+#define HI_INT16_BITS       16 // 16位整数的bit数
+#define HI_INT32_BITS       32 // 32位整数的bit数
+#define HI_INT64_BITS       64 // 64位整数的bit数
+#define HI_PER_BASE         100
+
+/**
+    usleep时间长度.
+    usleep()的单位为微妙。
+*/
+#define HI_USLEEP_MS       1000
+
+/**
+    exit codes
+*/
+#define HI_EC_PARAM_ERR     98
+#define HI_EC_EXEC_FAIL     127
+#define HI_EC_WD_TIMEOUT    5
+#define HI_EC_ASSERT_FAIL   100
+
+/**
+    通用常量.
+*/
+#define IP_STR_BUF_SIZE     40 // 字符串格式的ip地址buf长度
+#define INT_STR_BUF_SIZE    64 // 字符串表示的整数的buf的长度
+#define TINY_BUF_SIZE       64 // tiny buf size
+#define SMALL_BUF_SIZE      128 // small buf size
+#define NORM_BUF_SIZE       256 // normal buf size
+#define LARGE_BUF_SIZE      1024 // normal buf size
+#define HUGE_BUF_SIZE       9120 // huge buf size
+#define DUMP_LINE_BYTES     16 // dump数据时，每行的byte数
+
+/**
+    misc consts.
+*/
+#define MAC_BYTE_SIZE       6 // mac地址的字节长度
+
+/**
+    RGB888常用颜色.
+*/
+#define RGB888_RED          ((uint32_t)0xFF0000)
+#define RGB888_GREEN        ((uint32_t)0x00FF00)
+#define RGB888_BLUE         ((uint32_t)0x0000FF)
+#define RGB888_YELLOW       ((uint32_t)0xFFFF00)
+#define RGB888_WHITE        ((uint32_t)0xFFFFFF)
+#define RGB888_BLACK        ((uint32_t)0x000000)
+
+/**
+    ARGB1555常用颜色.
+*/
+#define ARGB1555_RED        0xFC00 // 1 11111 00000 00000
+#define ARGB1555_GREEN      0x83E0 // 1 00000 11111 00000
+#define ARGB1555_BLUE       0x801F // 1 00000 00000 11111
+#define ARGB1555_YELLOW     0xFFE0 // 1 11111 11111 00000
+#define ARGB1555_YELLOW2    0xFF00 // 1 11111 11111 00000
+#define ARGB1555_WHITE      0xFFFF // 1 11111 11111 11111
+#define ARGB1555_BLACK      0x8000 // 1 00000 00000 00000
+
+/**
+    char pointer类型.
+    用于定义函数指针类型时返回char*. 以绕开某些编辑工具的问题.
+*/
+#define HI_PCHAR char*
+
+#ifdef __cplusplus
+}
+#endif
+
+/**
+    hi heap api.
+    在extern "C" {} 之外定义.
+*/
+#ifdef CFG_EXT_HEAP
+#include "hi_ext_heap.h"
+#endif
+
+#endif // HI_EXT_DEF_H
diff -urpBN hiopenais/src/hi_ext_util/hi_ext_util.h hiopenais_modify/src/hi_ext_util/hi_ext_util.h
--- hiopenais/src/hi_ext_util/hi_ext_util.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/hi_ext_util.h	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HI_EXT_UTIL_H
+#define HI_EXT_UTIL_H
+
+#include "securec.h"
+
+#include "hi_app_base.h"
+
+#include "hi_dbg_log.h"
+
+#include "posix_help.h"
+
+#include "hi_misc_util.h"
+
+#endif // HI_EXT_UTIL_H
+
diff -urpBN hiopenais/src/hi_ext_util/hi_misc_util.c hiopenais_modify/src/hi_ext_util/hi_misc_util.c
--- hiopenais/src/hi_ext_util/hi_misc_util.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/hi_misc_util.c	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,366 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <limits.h>
+#include "hi_ext_util.h"
+
+#ifdef __HuaweiLite__
+#include <los_sys.h>
+#endif
+
+
+#define BIN_LEN_MULTIPLT_NUM    2
+
+/**
+    全局的公共mutex.
+    用来保护对某些共享资源的访问。
+*/
+static pthread_mutex_t g_pubMutex = { 0 }; // 初始化为无效值
+
+/**
+    取自开机以来的当前时间(ms).
+*/
+int64_t HiClockMs(void)
+{
+#   ifndef __HuaweiLite__
+
+    struct timespec t;
+    if (clock_gettime(CLOCK_BOOTTIME, &t) < 0) {
+        LOGE("clock_gettime(CLOCK_BOOTTIME) FAIL, err='%s'\n", strerror(errno));
+        return -1;
+    }
+    return (int64_t)t.tv_sec * HI_MS_OF_SEC + (int64_t)t.tv_nsec / HI_NS_OF_MS;
+
+#   else // __HuaweiLite__
+    return (int64_t) LOS_Tick2MS(LOS_TickCountGet());
+#   endif // __HuaweiLite__
+}
+
+/**
+    将数据以hex格式dump到stdout.
+*/
+int HiDumpHex(const void* buf, int len)
+{
+    const uint8_t *data = (const uint8_t*)buf;
+    int res;
+    int ret = 0;
+
+    if (len < 1) {
+        return 0;
+    }
+
+    // 1st byte
+    res = printf("\t%02X", (unsigned int)data[0]);
+    if (res > 0) {
+        ret += res;
+    }
+
+    // bytes 1 to len-1
+    for (int i = 1; i < len; i++) {
+        if (i % DUMP_LINE_BYTES) {
+            res = printf(" %02X", (unsigned int)data[i]);
+        } else {
+            res = printf("\n\t%02X", (unsigned int)data[i]);
+        }
+        if (res > 0) {
+            ret += res;
+        }
+    }
+
+    printf("\n");
+    return ret;
+}
+
+/**
+    将数据以txt格式dump到stdout.
+*/
+int HiDumpTxt(const void* buf, int len)
+{
+    const char *data = (const char*)buf;
+
+    if (len < 1) {
+        len = strlen(data);
+    }
+
+    putchar('\t');
+    for (int i = 0; i < len; i++) {
+        if (data[i]) {
+            putchar(data[i]);
+            if (data[i] == '\n') {
+                putchar('\t');
+            }
+        } else {
+            putchar('.');
+        }
+    }
+    putchar('\n');
+    return 0;
+}
+
+/**
+    二进制数据转换为hex表示的string.
+*/
+int HiBinToStr(const void* bin, int binLen, char* str, int strSize)
+{
+    HI_ASSERT(strSize > binLen * 2);
+    int len = 0;
+
+    *str = 0;
+    for (int i = 0; i < binLen; i++) {
+        len += snprintf_s(str + len, strSize - len, strSize - len - 1, "%02X", (int)((uint8_t*)bin)[i]);
+        HI_ASSERT(len < strSize);
+    }
+    HI_ASSERT(len == binLen * BIN_LEN_MULTIPLT_NUM);
+    return len;
+}
+
+/**
+    创建MemBlk.
+*/
+MemBlk* MemBlkNew(int size)
+{
+    HI_ASSERT(size > 0);
+    MemBlk *self = NULL;
+    int total;
+
+    total = size + sizeof(MemBlk);
+    self = (MemBlk*)malloc(total);
+    if (!self) { // 由于MemBlk大量用于size较大的网络消息/媒体数据块，需要检测分配结果
+        LOGE("MemBlkNew FAIL, size=%d\n", size);
+        return NULL;
+    }
+    INIT_LIST_HEAD(&self->lnode);
+    self->index = 0;
+    self->offset = 0;
+    self->len = 0;
+    self->size = size;
+    return self;
+}
+
+/**
+    创建MemBlk.
+*/
+MemBlk* MemBlkNew2(int size, int rsvSize)
+{
+    HI_ASSERT(rsvSize >= 0 && rsvSize <= size);
+
+    MemBlk *self = MemBlkNew(size);
+    if (!self) {
+        HI_ASSERT(0);
+    }
+    self->offset = rsvSize;
+    self->len = rsvSize;
+    return self;
+}
+
+/**
+    销毁MemBlk.
+*/
+void MemBlkDelete(MemBlk* self)
+{
+    HI_ASSERT(self);
+    free(self);
+}
+
+/**
+    在头部添加string.
+*/
+int MemBlkPrefixStr(MemBlk* self, const char* str, int len)
+{
+    HI_ASSERT(str);
+
+    len = len < 0 ? strlen(str) : len;
+    if (len == 0) {
+        return 0;
+    }
+    if (self->offset < len) {
+        LOGE("MemBlk prefixStr FAIL, for offset(%d) < len(%d)\n", self->offset, len);
+        return -1;
+    }
+
+    if (memcpy_s(&self->data[self->offset - len], len, str, len) != EOK) {
+        HI_ASSERT(0);
+    }
+    self->offset -= len;
+    return len;
+}
+
+/**
+    在尾部添加string.
+*/
+int MemBlkSuffixStr(MemBlk* self, const char* str, int len)
+{
+    HI_ASSERT(str);
+
+    len = len < 0 ? strlen(str) : len;
+    if (len == 0) {
+        return 0;
+    }
+    if (self->size - self->len < len) { // 用<而不是<=, 以保留一个字节用于0
+        LOGE("MemBlk suffixStr FAIL, for left(%d) < len(%d)\n", self->size - self->offset, len);
+        return -1;
+    }
+
+    if (memcpy_s(&self->data[self->len], self->size - self->len, str, len) != EOK) {
+        HI_ASSERT(0);
+    }
+    self->len += len;
+    return len;
+}
+
+/**
+    销毁MemBlk链表中的所有节点.
+*/
+void MemBlksDelete(struct list_head* list)
+{
+    struct list_head *node = NULL;
+    struct list_head *next = NULL;
+    MemBlk *blk = NULL;
+
+    list_for_each_safe(node, next, list) {
+        blk = list_entry(node, MemBlk, lnode);
+        list_del(node);
+        MemBlkDelete(blk);
+    }
+}
+
+/**
+    求list中MemBlk的长度之和.
+*/
+size_t MemBlksSize(struct list_head* list)
+{
+    struct list_head *node = NULL;
+    MemBlk *blk = NULL;
+    size_t size = 0;
+
+    list_for_each(node, list) {
+        blk = list_entry(node, MemBlk, lnode);
+        size += blk->len;
+    }
+    return size;
+}
+
+/**
+    将MemBlks转换为一个MemBlk输出.
+*/
+MemBlk* MemBlksToBlk(struct list_head *blkList, int offset, int tailRsvSize)
+{
+    HI_ASSERT(blkList);
+    HI_ASSERT(offset >= 0);
+    HI_ASSERT(tailRsvSize >= 0);
+    struct list_head *node = NULL;
+    MemBlk *outBlk = NULL;
+    size_t outSize;
+
+    // 计算blkList size，分配outBlk
+    outSize = MemBlksSize(blkList);
+    outSize += offset + tailRsvSize;
+    outBlk = MemBlkNew(outSize);
+    if (!outBlk) {
+        LOGE("alloc FAIL, size=%zu\n", outSize);
+        return NULL;
+    }
+
+    // 复制
+    outBlk->offset += offset;
+    list_for_each(node, blkList) {
+        MemBlk *blk = list_entry(node, MemBlk, lnode);
+        if (blk->len > blk->offset) {
+            HI_ASSERT(outBlk->size - outBlk->offset >= blk->len - blk->offset);
+            if (memcpy_s(&outBlk->data[outBlk->offset], outBlk->size - outBlk->offset,
+                &blk->data[blk->offset], blk->len - blk->offset) != EOK) {
+                HI_ASSERT(0);
+            }
+            outBlk->offset += blk->len;
+        }
+    }
+    return outBlk;
+}
+
+/**
+    按比例转换坐标.
+*/
+void RectBoxTran(RectBox* box, int srcWidth, int srcHeight, int dstWidth, int dstHeight)
+{
+    if (!srcWidth || !srcHeight) {
+        HI_ASSERT(srcWidth && srcHeight);
+    } else {
+        box->xmin = box->xmin * dstWidth / srcWidth * HI_OVEN_BASE / HI_OVEN_BASE;
+        box->xmax = box->xmax * dstWidth / srcWidth * HI_OVEN_BASE / HI_OVEN_BASE;
+        box->ymin = box->ymin * dstHeight / srcHeight * HI_OVEN_BASE / HI_OVEN_BASE;
+        box->ymax = box->ymax * dstHeight / srcHeight * HI_OVEN_BASE / HI_OVEN_BASE;
+    }
+}
+
+/**
+    将整数放大到给定的倍数范围内.
+*/
+int IntZoomTo(int n, double rate, double rateMin, double rateMax)
+{
+    HI_ASSERT(rateMin < 1 && rateMax > 1);
+    int ret;
+
+    if (!rateMin) {
+        HI_ASSERT(rateMin);
+        return n;
+    } else {
+        if (rate > rateMax) {
+            ret = n * (int)rateMax;
+        } else if (rate < rateMin) {
+            ret = n / (int)(1 / rateMin);
+        } else {
+            ret = (int)(n * rate);
+        }
+        return ret < 1 ? 1 : ret;
+    }
+}
+
+/**
+    加全局锁.
+*/
+void HiGlbLock(void)
+{
+    MutexLock(&g_pubMutex);
+}
+
+/**
+    解全局锁.
+*/
+void HiGlbUnlock(void)
+{
+    MutexUnlock(&g_pubMutex);
+}
+
+/**
+    初始化global mutex.
+*/
+void HiGlbLockInit(void)
+{
+    RecurMutexInit(&g_pubMutex);
+}
+
+/**
+    去初始化global mutex.
+*/
+void HiGlbLockExit(void)
+{
+    MutexDestroy(&g_pubMutex);
+}
+
diff -urpBN hiopenais/src/hi_ext_util/hi_misc_util.h hiopenais_modify/src/hi_ext_util/hi_misc_util.h
--- hiopenais/src/hi_ext_util/hi_misc_util.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/hi_misc_util.h	2021-03-29 20:34:26.000000000 -0700
@@ -0,0 +1,304 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HI_MISC_UTIL_H
+#define HI_MISC_UTIL_H
+
+#include <stdint.h>
+#include "linux_list.h"
+#include "hi_ext_def.h"
+#include "hi_str_util.h"
+#include "list.h"
+#include "hi_debug.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    取最小值.
+*/
+#define HI_MIN(a, b) ((a) < (b) ? (a) : (b))
+
+/**
+    取最大值.
+*/
+#define HI_MAX(a, b) ((a) > (b) ? (a) : (b))
+
+/**
+    取array的元素数目.
+*/
+#define HI_ARRAY_SIZE(arr) ((sizeof(arr) / sizeof((arr)[0])))
+
+#define SHIFT_EIGHT_BITS         8
+#define SHIFT_SIXTEEN_BITS       16
+#define SHIFT_TWENTYFOUR_BITS    24
+
+/**
+    get le16-int from special address.
+*/
+static inline uint16_t HiGetLe16(const uint8_t *p)
+{
+    return p[0] | (p[1] << 8);
+}
+
+/**
+    put le16-int to special address.
+*/
+static inline void HiPutLe16(uint16_t val, uint8_t *p)
+{
+    *p++ = val;
+    *p = val >> SHIFT_EIGHT_BITS;
+}
+
+/**
+    get le32-int from special address.
+*/
+static inline uint32_t HiGetLe32(const uint8_t *p)
+{
+    return p[0] | (p[1] << 8) | (p[2] << 16) | (p[3] << 24);
+}
+
+/**
+    put le32-int to special address.
+*/
+static inline void HiPutLe32(uint32_t val, uint8_t *p)
+{
+    *p++ = val;
+    *p++ = val >> SHIFT_EIGHT_BITS;
+    *p++ = val >> SHIFT_SIXTEEN_BITS;
+    *p = val >> SHIFT_TWENTYFOUR_BITS;
+}
+
+/**
+    get be16-int from special address.
+*/
+static inline uint16_t HiGetBe16(const uint8_t *p)
+{
+    return p[1] | (p[0] << 8);
+}
+
+/**
+    put be16-int to special address.
+*/
+static inline void HiPutBe16(uint16_t val, uint8_t *p)
+{
+    *p++ = val >> SHIFT_EIGHT_BITS;
+    *p = val;
+}
+
+/**
+    get be32-int from special address.
+*/
+static inline uint32_t HiGetBe32(const uint8_t *p)
+{
+    return p[3] | (p[2] << 8) | (p[1] << 16) | (p[0] << 24);
+}
+
+/**
+    put le32-int to special address.
+*/
+static inline void HiPutBe32(uint32_t val, uint8_t *p)
+{
+    *p++ = val >> SHIFT_TWENTYFOUR_BITS;
+    *p++ = val >> SHIFT_SIXTEEN_BITS;
+    *p++ = val >> SHIFT_EIGHT_BITS;
+    *p = val;
+}
+
+/**
+    字节对齐计算.
+*/
+#define HI_ALIGN2(num) (((num) + 2 - 1) / 2 * 2)
+#define HI_ALIGN8(num) (((num) + 8 - 1) / 8 * 8)
+#define HI_ALIGN16(num) (((num) + 16 - 1) / 16 * 16)
+#define HI_ALIGN32(num) (((num) + 32 - 1) / 32 * 32)
+
+/**
+    将参数转换为string常量.
+*/
+#define HI_TO_STR1(c)   #c
+#define HI_TO_STR(c)    HI_TO_STR1(c)
+
+/**
+    取自开机以来的当前时间(ms).
+*/
+int64_t HiClockMs(void);
+
+/**
+    将数据以hex格式dump到stdout.
+
+    16个字节的数据为一行。
+    @return 返回输出的字节数。
+*/
+int HiDumpHex(const void* buf, int len);
+
+/**
+    将数据以txt格式dump到stdout.
+*/
+int HiDumpTxt(const void* buf, int len);
+
+/**
+    二进制数据转换为hex表示的string.
+*/
+int HiBinToStr(const void* bin, int binLen, char* str, int strSize);
+
+/**
+    可作为链表节点的mem block.
+*/
+typedef struct MemBlk {
+    struct list_head lnode;
+
+    int index; // 供APP自定义使用的属性
+    int offset; // 通常用来作为seek指针，对象创建时被初始化为0
+    int len; // 有效数据长度
+    int size; // buf size
+    uint8_t data[]; // buf
+}   MemBlk;
+
+/**
+    创建MemBlk.
+*/
+MemBlk* MemBlkNew(int size);
+
+/**
+    创建MemBlk.
+*/
+MemBlk* MemBlkNew2(int size, int rsvSize);
+
+/**
+    销毁MemBlk.
+*/
+void MemBlkDelete(MemBlk* self);
+
+/**
+    获得实际数据长度.
+    当使用offset时使用.
+*/
+static inline int MemBlkLen(MemBlk* self)
+{
+    HI_ASSERT(self->len >= self->offset);
+    return self->len - self->offset;
+}
+
+/**
+    获得数据存储的首地址.
+    当使用offset时使用.
+*/
+static inline uint8_t* MemBlkData(MemBlk* self)
+{
+    HI_ASSERT(self->offset < self->size);
+    return &self->data[self->offset];
+}
+
+/**
+    在头部添加string.
+*/
+int MemBlkPrefixStr(MemBlk* self, const char* str, int len);
+
+/**
+    在尾部添加string.
+*/
+int MemBlkSuffixStr(MemBlk* self, const char* str, int len);
+
+/**
+    销毁MemBlk链表中的所有节点.
+*/
+void MemBlksDelete(struct list_head* list);
+
+/**
+    求list中MemBlk的长度之和.
+*/
+size_t MemBlksSize(struct list_head* list);
+
+/**
+    MemBlk处理器类型.
+    通用类型(接口)，其含义由具体应用解释。
+*/
+typedef int (*MemBlkProc)(void* user, MemBlk* blk);
+
+/**
+    rect box.
+*/
+typedef struct RectBox {
+    int xmin;
+    int ymin;
+    int xmax;
+    int ymax;
+}   RectBox;
+
+/**
+    按比例转换坐标.
+
+    将相对于{srcWidth, srcHeight}的坐标，转换为相对于{dstWidth, dstHeight}的坐标。
+
+    @param box[in|out]: 输入为相对于{srcWidth, srcHeight}的坐标，输出为相对于{dstWidth, dstHeight}的坐标。
+    @param srcWidth[in]: 原坐标width。
+    @param srcHeight[in]: 原坐标height。
+    @param dstWidth[in]: 目的坐标width。
+    @param dstHeight[in]: 目的坐标height。
+*/
+void RectBoxTran(RectBox* box, int srcWidth, int srcHeight, int dstWidth, int dstHeight);
+
+/**
+    将整数放大到给定的倍数范围内.
+
+    某些芯片的IVE仅支持整数倍的缩放，难以支持任意src到任意dst的size转换。
+    目前仅部分低端芯片有此要求，暂不支持。
+
+    @param size[in]: 待缩放的整数.
+    @param rate[in]: 希望缩放的比例.
+    @param rateMax[in]: 最小的放大比例. 也即最大的缩小倍数，必须小于1.
+    @param rateMin[in]: 最大的放大比例.
+
+    @return 返回放大后的整数.
+*/
+int IntZoomTo(int n, double rate, double rateMin, double rateMax);
+
+/**
+    length and data struct.
+    临时使用。
+*/
+typedef struct HiLenData {
+    int len;
+    uint8_t *data;
+}   HiLenData;
+
+/**
+    加全局锁.
+*/
+void HiGlbLock(void);
+
+/**
+    解全局锁.
+*/
+void HiGlbUnlock(void);
+
+/**
+    初始化全局锁.
+*/
+void HiGlbLockInit(void);
+
+/**
+    去初始化全局锁.
+*/
+void HiGlbLockExit(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // HI_MISC_UTIL_H
+
diff -urpBN hiopenais/src/hi_ext_util/hi_str_util.c hiopenais_modify/src/hi_ext_util/hi_str_util.c
--- hiopenais/src/hi_ext_util/hi_str_util.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/hi_str_util.c	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,245 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "securec.h"
+#include "hi_debug.h"
+#include "hi_str_util.h"
+
+/**
+    杞㈠姣涓哄ぇ.
+*/
+#define TO_UPPER(c) (((c) >= 'a' && (c) <= 'z') ? ((c) - 'a' + 'A') : (c))
+
+/**
+    strdup.
+*/
+char* HiStrdup(const char* s)
+{
+    char *dst = NULL;
+    int len;
+
+    len = strlen(s) + 1;
+    if (len <= 0) {
+        HI_ASSERT(0);
+        return NULL;
+    }
+    dst = malloc(len);
+    HI_ASSERT(dst);
+    if (memcpy_s(dst, len, s, len) != EOK) {
+        HI_ASSERT(0);
+    }
+    return dst;
+}
+
+/**
+    涓哄澶уstrcmp.
+*/
+int HiStricmp(const char *s1, const char *s2)
+{
+    while (TO_UPPER(*s1) == TO_UPPER(*s2) && *s1) {
+        s1++;
+        s2++;
+    }
+    return (int)(unsigned char)TO_UPPER(*s1) - (int)(unsigned char)TO_UPPER(*s2);
+}
+
+/**
+    涓哄澶уstrncmp.
+*/
+int HiStrincmp(const char *s1, const char *s2, size_t n)
+{
+    while (n > 0 && TO_UPPER(*s1) == TO_UPPER(*s2) && *s1) {
+        ++s1;
+        ++s2;
+        n--;
+    }
+
+    if (n == 0) {
+        return 0;
+    } else {
+        return (int)(unsigned char)TO_UPPER(*s1) - (int)(unsigned char)TO_UPPER(*s2);
+    }
+}
+
+/**
+    ユ惧瀛绗涓(涓哄澶у).
+*/
+char* HiStristr(const char *s1, const char *s2)
+{
+    size_t len2;
+
+    if ((len2 = strlen(s2)) == 0) {
+        return (char*)s1;
+    }
+
+    for (; *s1; ++s1) {
+        if (TO_UPPER(*s1) == TO_UPPER(*s2) && HiStrincmp(s1, s2, len2) == 0) {
+            return (char*)s1;
+        }
+    }
+    return NULL;
+}
+
+/**
+    strxfrm.
+*/
+int HiStrxfrm(char *s1, const char *s2, int n)
+{
+    int i;
+
+    n--;
+    for (i = 0; i < n && s2[i]; i++) {
+        s1[i] = s2[i];
+    }
+    s1[i] = 0;
+    return i;
+}
+
+/**
+    缁璁″绗涓蹭腑瀹瀛绗虹扮娆℃.
+*/
+int HiStrchrc(const char* s, int c)
+{
+    const char *p = s;
+    int count = 0;
+
+    while ((p = strchr(p, c)) != NULL) {
+        count++;
+        p++;
+    }
+    return count;
+}
+
+/**
+    strtok绾跨瀹ㄧ.
+*/
+char* HiStrtoks(char** tokensAddr, const char* delimit)
+{
+    char *tokens = NULL;
+    char *p = NULL;
+    const char *s = NULL;
+    char c;
+
+    if (!*tokensAddr) {
+        return NULL;
+    }
+    tokens = *tokensAddr;
+
+    // delimit讹翠釜tokens浣涓token杩
+    if (!delimit || !*delimit) {
+        *tokensAddr = NULL; // 缃token涓NULL
+        return tokens;
+    }
+
+    // 璺宠token涓delimit瀛绗
+    tokens += strspn(tokens, delimit);
+    // ゆ板熬浜
+    if (!*tokens) {
+        *tokensAddr = NULL; // 缃token涓NULL
+        return NULL;
+    }
+
+    // 惧颁涓涓灞浜delimit涓瀛绗锛骞跺剁疆0
+    for (p = tokens; (c = *p) != 0; p++) {
+        // ゆcdelimit涓瀛绗
+        for (s = delimit; *s; s++) {
+            if (*s == c) {
+                *p = 0;
+                *tokensAddr = p + 1; // 缃token
+                return tokens;
+            }
+        }
+    }
+
+    *tokensAddr = p; // 缃token, *P芥0
+    return tokens;
+}
+
+/**
+    strtok╁.
+*/
+const char* HiStrtokx(const char** tokensAddr, const char* delimit, int* len)
+{
+    const char *tokens = NULL;
+    const char *p = NULL;
+    const char *s = NULL;
+    char c;
+
+    if (!*tokensAddr) {
+        return NULL;
+    }
+    tokens = *tokensAddr;
+
+    // delimit讹翠釜tokens浣涓token杩
+    if (!delimit || !*delimit) {
+        *tokensAddr = NULL; // 缃token涓NULL
+        *len = strlen(tokens);
+        return tokens;
+    }
+
+    // 璺宠token涓delimit瀛绗
+    tokens += strspn(tokens, delimit);
+    // ゆ板熬浜
+    if (!*tokens) {
+        *tokensAddr = NULL; // 缃token涓NULL
+        return NULL;
+    }
+
+    // 惧颁涓涓灞浜delimit涓瀛绗锛骞跺剁疆0
+    for (p = tokens; (c = *p) != 0; p++) {
+        // ゆcdelimit涓瀛绗
+        for (s = delimit; *s; s++) {
+            if (*s == c) {
+                *len = p - tokens; // *len涓绗
+                *tokensAddr = p + 1; // 缃token
+                return tokens;
+            }
+        }
+    }
+
+    *len = p - tokens;
+    *tokensAddr = p; // 缃token, *P芥0
+    return tokens;
+}
+
+/**
+    path浠跺ㄥ.
+*/
+const char* HiPathName(const char* path)
+{
+    HI_ASSERT(path);
+
+    const char *p = strrchr(path, '/');
+    if (p) {
+        return p + 1;
+    }
+    return path;
+}
+
+/**
+    浠跺缂.
+*/
+const char* HiPathExt(const char* path)
+{
+    const char* ext = strrchr(HiPathName(path), '.');
+    return ext ? ext + 1 : NULL;
+}
+
diff -urpBN hiopenais/src/hi_ext_util/hi_str_util.h hiopenais_modify/src/hi_ext_util/hi_str_util.h
--- hiopenais/src/hi_ext_util/hi_str_util.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/hi_str_util.h	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HI_STR_UTIL_H
+#define HI_STR_UTIL_H
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    dup string.
+    strdup锛浣跨malloc()ュ瀛.
+*/
+char* HiStrdup(const char* s);
+
+/**
+    瀛绗涓蹭哄澶у姣杈.
+*/
+int HiStricmp(const char *s1, const char *s2);
+int HiStrincmp(const char *s1, const char *s2, size_t n);
+
+/**
+    ユ惧瀛绗涓.
+*/
+char* HiStristr(const char *s1, const char *s2);
+
+/**
+    瀛绗涓copy.
+*/
+int HiStrxfrm(char *s1, const char *s2, int n);
+
+/**
+    瀛绗涓插ぇ灏杞.
+*/
+char* HiStrupr(char *s);
+char* HiStrlwr(char *s);
+
+/**
+    缁璁″绗涓蹭腑瀹瀛绗虹扮娆℃.
+*/
+int HiStrchrc(const char* s, int c);
+
+/**
+    strtok绾跨瀹ㄧ.
+
+    hi_strtok涓瑕缁存static锛绾跨瀹ㄧ
+
+    @param tokens [in|out]: token瀛绗涓茬"板"
+    @param delimit [in]: token绗
+    @param len [out]: token垮害锛褰寰token舵
+
+    @return 杩token锛杩NULL
+*/
+char* HiStrtoks(char** tokens, const char* delimit);
+const char* HiStrtokx(const char** tokens, const char* delimit, int* len);
+
+/**
+    path (ㄨ矾寰)绉伴ㄥ.
+    涓windows璺寰.
+*/
+const char* HiPathName(const char* path);
+
+/**
+    pathname浠跺缂.
+    涓windows璺寰.
+*/
+const char* HiPathExt(const char* path);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // HI_STR_UTIL_H
diff -urpBN hiopenais/src/hi_ext_util/inet_test_util.c hiopenais_modify/src/hi_ext_util/inet_test_util.c
--- hiopenais/src/hi_ext_util/inet_test_util.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/inet_test_util.c	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,128 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdint.h>
+#include <limits.h>
+#include <unistd.h>
+
+#include "hi_ext_util.h"
+#include "inet_test_util.h"
+
+#define TEST_BUF_SIZE    128 * HI_KB; // buf size
+
+/**
+    处理一次TCP连接的速度测试.
+*/
+void* TcpRxSpeedTest(void* user)
+{
+    static const int outIntval = 1 * HI_MS_OF_SEC; // 1000ms or 5000ms ?
+    static const int bufSize = TEST_BUF_SIZE; // buf size
+    int sock = (int)(uintptr_t)user;
+    HI_ASSERT(sock >= 0);
+    uint8_t *buf = NULL;
+    int64_t begTime;
+    int64_t piroid;
+    int64_t speed;
+    int64_t total;
+    int ret;
+
+    LOGI("TCP-RX: speed test beg ...\n");
+    FdSetBlock(sock);
+    buf = malloc(bufSize);
+    HI_ASSERT(buf);
+
+    total = 0;
+    begTime = HiClockMs();
+    while ((ret = read(sock, buf, bufSize)) > 0) {
+        total += ret;
+
+        piroid = HiClockMs() - begTime;
+        if (piroid < outIntval) {
+            continue;
+        }
+
+        speed = total / piroid * HI_MS_OF_SEC / HI_KB; // KB/s
+        LOGI("TCP-RX: speed=%jd(KB/s), piroid=%jd\n", speed, piroid);
+        begTime = HiClockMs();
+        total = 0;
+    }
+    if (ret < 0) {
+        LOGE("tcp read FAIL, err='%s'\n", strerror(errno));
+    }
+
+    free(buf);
+    close(sock);
+    LOGI("TCP-RX: speed test done\n");
+    return NULL;
+}
+
+/*
+    处理多连接测试中的一次连接速度测试.
+*/
+void* TcpMultiRxSpeedTest(void* user)
+{
+    TcpMultiRx *self = (TcpMultiRx*)user;
+    int sock = self->sock;
+    HI_ASSERT(sock >= 0);
+    static const int outIntval = 1 * HI_MS_OF_SEC; // 1000ms or 5000ms?
+    static const int bufSize = TEST_BUF_SIZE; // buf size
+    uint8_t *buf = NULL;
+    int64_t total = 0;
+    int ret;
+
+    FdSetBlock(sock);
+
+    if (self->piriodRxNum == 0) {
+        self->piriodBegTime = HiClockMs();
+    }
+
+    buf = malloc(bufSize);
+    HI_ASSERT(buf);
+    while ((ret = read(sock, buf, bufSize)) > 0) {
+        total += ret;
+    }
+    if (ret < 0) {
+        LOGE("tcp read FAIL, err='%s'\n", strerror(errno));
+    }
+    free(buf);
+    close(sock);
+    self->sock = -1;
+    self->piriodRxTotal += total;
+    self->piriodRxNum++;
+
+    int64_t piroid = HiClockMs() - self->piriodBegTime;
+    if (piroid >= outIntval) {
+        int64_t speed = self->piriodRxTotal / piroid * HI_MS_OF_SEC / HI_KB; // KB/s
+        int64_t pps = self->piriodRxNum * HI_MS_OF_SEC / piroid; // pps
+        LOGI("TCP-MRX: speed=%jd(KB/s), pps=%jd, piroid=%jd\n", speed, pps, piroid);
+        TcpMultiRxClear(self);
+    }
+    return NULL;
+}
+
+/**
+    清除TcpMultiRx中的信息.
+*/
+void TcpMultiRxClear(TcpMultiRx* self)
+{
+    if (memset_s(self, sizeof(*self), 0, sizeof(*self)) != EOK) {
+        HI_ASSERT(0);
+    }
+}
+
diff -urpBN hiopenais/src/hi_ext_util/inet_test_util.h hiopenais_modify/src/hi_ext_util/inet_test_util.h
--- hiopenais/src/hi_ext_util/inet_test_util.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/inet_test_util.h	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef INET_TEST_UTIL_H
+#define INET_TEST_UTIL_H
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    处理一次TCP连接的速度测试.
+*/
+void* TcpRxSpeedTest(void* user);
+
+/**
+    多连接速度测试信息.
+*/
+typedef struct TcpMultiRx {
+    int sock;
+
+    int64_t piriodBegTime;
+    int64_t piriodRxTotal;
+    int piriodRxNum;
+}   TcpMultiRx;
+
+/*
+    处理多连接测试中的一次连接速度测试.
+*/
+void* TcpMultiRxSpeedTest(void* user);
+
+/**
+    清除TcpMultiRx中的信息.
+*/
+void TcpMultiRxClear(TcpMultiRx* self);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // INET_TEST_UTIL_H
diff -urpBN hiopenais/src/hi_ext_util/linux_list.h hiopenais_modify/src/hi_ext_util/linux_list.h
--- hiopenais/src/hi_ext_util/linux_list.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/linux_list.h	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef LINUX_LIST_H
+#define LINUX_LIST_H
+
+#include "list.h"
+
+#ifndef _LINUX_LIST_H
+
+/**
+    get the node num of a list.
+*/
+static inline int list_size(struct list_head *head)
+{
+    struct list_head *node = NULL;
+    int size = 0;
+
+    list_for_each (node, head) {
+        size++;
+    }
+    return size;
+}
+
+#endif // _LINUX_LIST_H
+#endif // __HI_LIST_H
diff -urpBN hiopenais/src/hi_ext_util/liteos_adpt.c hiopenais_modify/src/hi_ext_util/liteos_adpt.c
--- hiopenais/src/hi_ext_util/liteos_adpt.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/liteos_adpt.c	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <strings.h>
+#include <stdarg.h>
+#include <errno.h>
+#include <stdint.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <ifaddrs.h>
+#include <signal.h>
+#include <fcntl.h>
+#include <mqueue.h>
+#include <netdb.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <sys/file.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <limits.h>
+
+#include "hi_ext_util.h"
+#include "posix_help.h"
+#include "base_adpt.h"
+
+#ifndef __HuaweiLite__
+#error "This file only used in LiteOS"
+#endif
+
+#define SOCK_PAIR_PORT          9090 // socket pair server port
+#define SOCK_PAIR_BACKLOG       3 // socket pair listen backlog
+
+static int g_sockPairSvr = -1; // socket pair server
+static pthread_mutex_t g_sockPairMutex; // socket pair mutex // 直接初始化为RECUR mode
+
+/**
+    SkPair create.
+
+    LiteOS未实现该接口，这里模拟实现。
+    但LiteOS目前不支持PF_UNIX/PF_LINUX，因此只能使用INET/TCP。
+
+    in: server side socket.
+    out: client side socket.
+*/
+int socketpair(int domain, int type, int protocol, int sv[2])
+{
+    int trueType = type & ~(SOCK_NONBLOCK | SOCK_CLOEXEC);
+    int ret;
+
+    HI_EXP_LOGW(domain != AF_UNIX && domain != AF_LOCAL, "domain not AF_UNIX or AF_LOCAL\n");
+    HI_EXP_LOGW(protocol, "socketpair param protocol MUST be 0, regard it as 0\n");
+    HI_EXP_RET(trueType != SOCK_STREAM, -1, "socketpair only support SOCK_STREAM\n");
+
+    // 这里必须加锁，在锁内完成连接的connect和accpet
+    MutexLock(&g_sockPairMutex);
+
+    // 以阻塞方式连接sock pair server
+    ret = TcpCltCreate(SOCK_PAIR_PORT, 0x7F000001, false); // 127.0.0.1
+    HI_ASSERT(ret >= 0); // 这里必然应该成功，失败只可能是因为sock资源耗尽，这是必须处理的
+    sv[1] = ret;
+
+    // 以阻塞方式accept sock pair连接，在TcpSvrCreate时已制定为阻塞模式
+    ret = SockAccept(g_sockPairSvr);
+    HI_ASSERT(ret >= 0); // 这里也必然应该成功
+    sv[0] = ret;
+
+    MutexUnlock(&g_sockPairMutex);
+
+    // 根据要求设置为async模式
+    if (type & SOCK_NONBLOCK) {
+        FdSetAsync(sv[0]);
+        FdSetAsync(sv[1]);
+    }
+    return 0;
+}
+
+/**
+    init.
+*/
+int BaseAdptInit(void)
+{
+    HI_ASSERT(g_sockPairSvr < 0);
+    RecurMutexInit(&g_sockPairMutex);
+
+    g_sockPairSvr = TcpSvrCreate(SOCK_PAIR_PORT, 0, false, SOCK_PAIR_BACKLOG);
+    return g_sockPairSvr < 0 ? g_sockPairSvr : 0;
+}
+
+/**
+    exit.
+*/
+int BaseAdptExit(void)
+{
+    if (g_sockPairSvr) {
+        close(g_sockPairSvr);
+        g_sockPairSvr = -1;
+    }
+    MutexDestroy(&g_sockPairMutex);
+    return 0;
+}
+
diff -urpBN hiopenais/src/hi_ext_util/posix_help.c hiopenais_modify/src/hi_ext_util/posix_help.c
--- hiopenais/src/hi_ext_util/posix_help.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/posix_help.c	2021-05-05 02:20:16.000000000 -0700
@@ -0,0 +1,1010 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <strings.h>
+#include <stdarg.h>
+#include <errno.h>
+#include <stdint.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <ifaddrs.h>
+#include <signal.h>
+#include <fcntl.h>
+#include <mqueue.h>
+#include <netdb.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <sys/file.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#ifndef __HuaweiLite__
+#include <linux/if.h>
+#endif
+#include <limits.h>
+
+#include "hi_ext_util.h"
+#include "posix_help.h"
+
+#ifdef __HuaweiLite__
+
+#else // __HuaweiLite__
+
+#define ADDR0   0
+#define ADDR1   1
+#define ADDR2   2
+#define ADDR3   3
+#define ADDR4   4
+#define ADDR5   5
+
+/**
+    读取指定网口的指定类型的inet地址.
+*/
+int IfGetInetAddr(const char* ifname, in_addr_t* ip, int ioctlOpt)
+{
+    HI_ASSERT(ip);
+    struct ifreq ifr;
+    struct sockaddr_in *addr = NULL;
+    int sock;
+    int ret;
+
+    sock = socket(AF_INET, SOCK_DGRAM, 0);
+    HI_ASSERT(sock > -1);
+    if (memset_s(&ifr, sizeof(ifr), 0, sizeof(ifr)) != EOK) {
+        HI_ASSERT(0);
+    }
+    HiStrxfrm(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+
+    if (ioctl(sock, ioctlOpt, &ifr) < 0) {
+        LOGE("ioctl::get(%s, %#x) FAIL, err='%s'\n", ifname, ioctlOpt, strerror(errno));
+        *ip = 0;
+        ret = -1;
+    } else {
+        addr = (struct sockaddr_in*)&(ifr.ifr_addr);
+        *ip = addr->sin_addr.s_addr;
+        ret = 0;
+    }
+
+    if (close(sock) < 0) {
+        LOGE("close(%d) FAIL, err='%s\n'", sock, strerror(errno));
+    }
+    return ret;
+}
+
+/**
+    获取指定网口指定类型的IP4地址.
+*/
+int IfGetInetStr(const char* ifname, char* ipBuf, int ipSize, int ioctlOpt)
+{
+    HI_ASSERT(ipBuf && ipSize > 0);
+    in_addr_t ip;
+    int ret;
+
+    ret = IfGetInetAddr(ifname, &ip, ioctlOpt);
+    if (ret < 0) {
+        return ret;
+    }
+
+    if (!inet_ntop(AF_INET, &ip, ipBuf, ipSize)) {
+        LOGE("inet_ntop() for got ip FAIL, err='%s'\n", strerror(errno));
+        return -1;
+    }
+    return ret;
+}
+
+/**
+    设置指定网口的指定类型的inet地址.
+*/
+int IfSetInetAddr(const char* ifname, in_addr_t ip, int ioctlOpt)
+{
+    struct ifreq ifr;
+    struct sockaddr_in *addr = NULL;
+    int sock;
+    int ret;
+
+    sock = socket(AF_INET, SOCK_DGRAM, 0);
+    HI_ASSERT(sock > -1);
+
+    if (memset_s(&ifr, sizeof(ifr), 0, sizeof(ifr)) != EOK) {
+        HI_ASSERT(0);
+    }
+    HiStrxfrm(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+    addr = (struct sockaddr_in*)&(ifr.ifr_addr);
+    addr->sin_family = AF_INET;
+    addr->sin_addr.s_addr = ip;
+
+    if (ioctl(sock, ioctlOpt, &ifr) < 0) {
+        char ipStr[IP_STR_BUF_SIZE] = { 0 };
+        inet_ntop(AF_INET, &ip, ipStr, sizeof(ipStr));
+        LOGE("ioctl::set('%s', 0x%x, '%s') FAIL, err='%s'\n", ifname, ioctlOpt, ipStr, strerror(errno));
+        ret = -1;
+    } else {
+        ret = 0;
+    }
+
+    if (close(sock) < 0) {
+        LOGE("close(%d) FAIL, err='%s'\n", sock, strerror(errno));
+    }
+    return ret;
+}
+
+/**
+    获取指定网口的IP4地址.
+*/
+int IfGetIpInt(const char* ifname, in_addr_t* ip)
+{
+    int ret;
+
+    ret = IfGetInetAddr(ifname, ip, SIOCGIFADDR);
+    if (ret < 0) {
+        LOGE("get loc ip of '%s' FAIL\n", ifname);
+    }
+    return ret;
+}
+
+/**
+    获取指定网口的IP地址.
+*/
+int IfGetIpStr(const char* ifname, char* ipBuf, int ipSize)
+{
+    int ret;
+
+    ret = IfGetInetStr(ifname, ipBuf, ipSize, SIOCGIFADDR);
+    if (ret < 0) {
+        LOGE("get loc ip of '%s' FAIL\n", ifname);
+    }
+    return ret;
+}
+
+/**
+    设置指定网口的IP4地址.
+*/
+int IfSetIpInt(const char* ifname, in_addr_t ip)
+{
+    int ret = IfSetInetAddr(ifname, ip, SIOCSIFADDR);
+    if (ret < 0) {
+        LOGE("set loc ip '%08X' of '%s' FAIL\n", ntohl(ip), ifname);
+    }
+    return ret;
+}
+
+/**
+    设置指定网口的IP4地址.
+*/
+int IfSetIpStr(const char* ifname, const char* ipStr)
+{
+    int ret = IfSetInetAddr(ifname, (ipStr ? inet_addr(ipStr) : 0), SIOCSIFADDR);
+    if (ret < 0) {
+        LOGE("set loc ip '%s' of '%s' FAIL\n", (ipStr ? ipStr : ""), ifname);
+    }
+    return ret;
+}
+
+/**
+    获取指定网口的mask IP4地址.
+*/
+int IfGetMaskInt(const char* ifname, in_addr_t* ip)
+{
+    int ret;
+
+    ret = IfGetInetAddr(ifname, ip, SIOCGIFNETMASK);
+    if (ret < 0) {
+        LOGE("get mask of '%s' FAIL\n", ifname);
+    }
+    return ret;
+}
+
+/**
+    获取指定网口的mask IP地址.
+*/
+int IfGetMaskStr(const char* ifname, char* ipBuf, int ipSize)
+{
+    int ret;
+
+    ret = IfGetInetStr(ifname, ipBuf, ipSize, SIOCGIFNETMASK);
+    if (ret < 0) {
+        LOGE("get mask of '%s' FAIL\n", ifname);
+    }
+    return ret;
+}
+
+/**
+    设置指定网口的mask IP4地址.
+*/
+int IfSetMaskInt(const char* ifname, uint32_t mask)
+{
+    int ret;
+
+    ret = IfSetInetAddr(ifname, mask, SIOCSIFNETMASK);
+    if (ret < 0) {
+        LOGE("set mask '%08X' of '%s' FAIL\n", ntohl(mask), ifname);
+    }
+    return ret;
+}
+
+/**
+    设置指定网口的mask IP4地址.
+*/
+int IfSetMaskStr(const char* ifname, const char* maskStr)
+{
+    int ret;
+
+    ret = IfSetInetAddr(ifname, (maskStr ? inet_addr(maskStr) : 0), SIOCSIFNETMASK);
+    if (ret < 0) {
+        LOGE("set mask '%s' of '%s' FAIL\n", (maskStr ? maskStr : ""), ifname);
+    }
+    return ret;
+}
+
+/**
+    获取指定网口的广播IP4地址.
+*/
+int IfGetBroadcastInt(const char* ifname, in_addr_t* addr)
+{
+    int ret;
+
+    ret = IfGetInetAddr(ifname, addr, SIOCGIFBRDADDR);
+    if (ret < 0) {
+        LOGE("get broadcast addr of '%s' FAIL\n", ifname);
+    }
+    return ret;
+}
+
+/**
+    获取指定网口的广播IP4地址.
+*/
+int IfGetBroadcastStr(const char* ifname, char* addrBuf, int addrSize)
+{
+    int ret;
+
+    ret = IfGetInetStr(ifname, addrBuf, addrSize, SIOCGIFBRDADDR);
+    if (ret < 0) {
+        LOGE("get broadcast addr of '%s' FAIL\n", ifname);
+    }
+    return ret;
+}
+
+/**
+    设置指定网口的广播IP4地址.
+*/
+int IfSetBroadcastInt(const char* ifname, in_addr_t addr)
+{
+    int ret = IfSetInetAddr(ifname, addr, SIOCSIFBRDADDR);
+    if (ret < 0) {
+        LOGE("set broadcast addr '%08X' of '%s' FAIL\n", ntohl(addr), ifname);
+    }
+    return ret;
+}
+
+/**
+    设置指定网口的广播IP4地址.
+*/
+int IfSetBroadcastStr(const char* ifname, const char* addrStr)
+{
+    int ret = IfSetInetAddr(ifname, (addrStr ? inet_addr(addrStr) : 0), SIOCSIFBRDADDR);
+    if (ret < 0) {
+        LOGE("set broadcast addr '%s' of '%s' FAIL\n", (addrStr ? addrStr : ""), ifname);
+    }
+    return ret;
+}
+
+/**
+    获取指定网口的MAC地址.
+*/
+int IfGetMacBytes(const char* ifname, uint8_t* macBuf, int macSize)
+{
+    HI_ASSERT(macBuf && macSize >= MAC_BYTE_SIZE);
+    struct ifreq ifr;
+    int sock;
+    int ret;
+
+    sock = socket(AF_INET, SOCK_DGRAM, 0);
+    HI_ASSERT(sock >= 0);
+    if (memset_s(&ifr, sizeof(ifr), 0, sizeof(ifr)) != EOK) {
+        HI_ASSERT(0);
+    }
+    HiStrxfrm(ifr.ifr_name, ifname, sizeof(ifr.ifr_name));
+
+    ret = ioctl(sock, SIOCGIFHWADDR, &ifr);
+    if (ret < 0) {
+        LOGE("ioctl::get(%s, SIOCFIFHWADDR) FAIL, err='%s'\n", ifname, strerror(errno));
+        LOGE("get mac of '%s' FAIL\n", ifname);
+        if (memset_s(macBuf, macSize, 0, macSize) != EOK) {
+            HI_ASSERT(0);
+        }
+        ret = -1;
+    } else {
+        if (memcpy_s(macBuf, macSize, (uint8_t*)ifr.ifr_hwaddr.sa_data, MAC_BYTE_SIZE) != EOK) {
+            HI_ASSERT(0);
+        }
+        ret = MAC_BYTE_SIZE;
+    }
+
+    if (close(sock) < 0) { // 原型int close(int fd)
+        LOGE("close(%d) FAIL, err='%s'", sock, strerror(errno));
+    }
+    return ret;
+}
+
+/**
+    获取指定网口的MAC地址.
+*/
+int IfGetMacStr(const char* ifname, char* macBuf, int macSize)
+{
+    HI_ASSERT(macBuf && macSize > 0);
+    uint8_t addr[MAC_BYTE_SIZE];
+    int ret;
+
+    ret = IfGetMacBytes(ifname, addr, sizeof(addr));
+    if (ret < 0) {
+        return ret;
+    }
+
+    HI_ASSERT(ret == MAC_BYTE_SIZE);
+    // MAC地址共6个字节，分别为addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]
+    ret = snprintf_s(macBuf, macSize, macSize - 1, "%02X:%02X:%02X:%02X:%02X:%02X",
+        (int)addr[ADDR0], (int)addr[ADDR1], (int)addr[ADDR2], (int)addr[ADDR3], (int)addr[ADDR4], (int)addr[ADDR5]);
+    return ret;
+}
+
+#endif // __HuaweiLite__
+
+/**
+    等待fd有信号.
+*/
+int FdWait(int fd, int64_t timeout)
+{
+    HI_ASSERT(fd > -1);
+    struct timeval timeval;
+    fd_set aset;
+    int ret;
+
+    FD_ZERO(&aset);
+    FD_SET(fd, &aset);
+
+    if (timeout >= 0) {
+        timeval.tv_sec = (long)(timeout / HI_MS_OF_SEC);
+        timeval.tv_usec = (long)(timeout % HI_MS_OF_SEC);
+    }
+
+    ret = select(fd + 1, &aset, NULL, NULL, timeout >= 0 ? &timeval : NULL);
+    if (ret > 0) { // 检测到信号
+        HI_ASSERT(ret == 1);
+        if (FD_ISSET(fd, &aset)) { // OK，有信号
+            return 1;
+        } else { // 不应该到这里
+            HI_ASSERT(0);
+            return -1;
+        }
+    } else if (ret == 0) { // timeout
+        return -ETIMEDOUT;
+    } else { // < 0, select FAIL
+        LOGE("FdAccess(%d) FAIL, err='%d, %s'\n", fd, errno, strerror(errno));
+        return -errno;
+    }
+}
+
+/**
+    查询给定的fd是否可读.
+*/
+static bool FdAccess(int fd, int* err, int mode)
+{
+    struct timeval timeval;
+    fd_set aset;
+    int ret;
+
+    HI_ASSERT(fd > -1);
+    if (err) {
+        *err = 0;
+    }
+    HI_ASSERT(mode == 'r' || mode == 'w');
+
+    FD_ZERO(&aset);
+    FD_CLR(fd, &aset);
+    FD_SET(fd, &aset);
+    timeval.tv_sec = 0;
+    timeval.tv_usec = 0;
+
+    ret = select(fd + 1, (mode == 'r' ? &aset : NULL), (mode == 'w' ? &aset : NULL), NULL, &timeval);
+    if (ret == 0) { // 没有信号
+        return false;
+    } else if (ret < 0) { // 其他原因导致的失败
+        LOGE("FdAccess(%d) FAIL, err='%d, %s'\n", fd, errno, strerror(errno));
+        if (err) {
+            *err = errno;
+        }
+        return false;
+    } else {
+        if (FD_ISSET(fd, &aset)) { // OK，有信号
+            return true;
+        } else { // 不应该到这里
+            HI_ASSERT(0);
+            if (err) {
+                *err = errno;
+            }
+            return false;
+        }
+    }
+}
+
+/**
+    查询给定的fd是否可读.
+*/
+bool FdReadable(int fd, int* err)
+{
+    return FdAccess(fd, err, 'r');
+}
+
+/**
+    查询给定的fd是否可写.
+*/
+bool FdWritable(int fd, int* err)
+{
+    return FdAccess(fd, err, 'w');
+}
+
+/**
+    读取完整消息.
+*/
+int FdReadMsg(int fd, void* msgBuf, int msgSize)
+{
+    HI_ASSERT(msgBuf && msgSize > 0);
+    static const int logPerCount = 1000; // loop多少次log一次信息
+    int loopNum = 0;
+    int total = 0;
+    int ret;
+    while (total < msgSize) {
+        ret = read(fd, (char*)msgBuf + total, msgSize - total);
+        if (ret > 0) {
+            total += ret;
+        } else if (ret == 0) { // fd closed by peer
+            LOGW("read FAIL, for fd closed by peer\n");
+            return -1;
+        } else if (errno == EAGAIN || errno == EWOULDBLOCK) { // no data now
+            if (total == 0) { // 此前没有读到数据时，返回
+                return 0;
+            }
+            if (++loopNum % logPerCount == 0) {
+                LOGW("FdReadMsg wait %ds, ERR, CHECK it\n", loopNum / logPerCount);
+            }
+            usleep(HI_USLEEP_MS); // wait 1ms, and try again
+        } else { // read error
+            return -1;
+        }
+    }
+    return msgSize;
+}
+
+/**
+    写入完整消息.
+*/
+int FdWriteMsg(int fd, const void* msgData, int msgLen)
+{
+    HI_ASSERT(msgData && msgLen > 0);
+    static const int logPerCount = 1000; // loop多少次log一次信息
+    int loopNum = 0;
+    int total = 0;
+    int ret;
+
+    while (total < msgLen) {
+        ret = write(fd, (const char*)msgData + total, msgLen - total);
+        if (ret > 0) {
+            total += ret;
+        } else if (ret == 0 || (ret < 0 && (errno == EAGAIN || errno == EWOULDBLOCK))) { // no data now
+            if (++loopNum % logPerCount == 0) {
+                LOGE("FdWriteMsg wait %ds, ERR, CHECK it\n", loopNum / logPerCount);
+            }
+            usleep(HI_USLEEP_MS); // wait 1ms, and try again
+        } else { // write error
+            HI_ASSERT(ret < 0);
+            LOGE("FdWriteMsg FAIL, err='%s'\n", strerror(errno));
+            return -1;
+        }
+    }
+    return msgLen;
+}
+
+/**
+    设置fd为异步模式.
+*/
+int FdSetAsync(int fd)
+{
+    int flags = fcntl(fd, F_GETFL, 0);
+    if (flags < 0 || fcntl(fd, F_SETFL, (uint32_t)flags | O_NONBLOCK) < 0) {
+        LOGE("set !O_NONBLOCK for fd(%d) FAIL, '%s'\n", fd, strerror(errno));
+        return -errno;
+    }
+    return 0;
+}
+
+/**
+    设置fd为阻塞模式.
+*/
+int FdSetBlock(int fd)
+{
+    int flags = fcntl(fd, F_GETFL, 0);
+    if (flags < 0 || fcntl(fd, F_SETFL, (uint32_t)flags & ~O_NONBLOCK) < 0) {
+        LOGE("set !O_NONBLOCK for fd(%d) FAIL, '%s'\n", fd, strerror(errno));
+        return -errno;
+    }
+    return 0;
+}
+
+/**
+    对listen socket执行accept.
+*/
+int SockAccept(int listenSock)
+{
+    struct sockaddr_in dstAddr;
+    socklen_t dstAddrLen = sizeof(dstAddr);
+    int ret;
+
+    if (memset_s(&dstAddr, sizeof(dstAddr), 0, sizeof(dstAddr)) != EOK) {
+        HI_ASSERT(0);
+    }
+    ret = accept(listenSock, (struct sockaddr*)&dstAddr, &dstAddrLen);
+    if (ret < 0) {
+        LOGE("accept FAIL, err='%s, %d'\n", strerror(errno), errno);
+        return -errno;
+    }
+    return ret;
+}
+
+/**
+    mqueue atom send.
+*/
+int MqAtomSend(const char* name, const void* data, int len, uint32_t oflag)
+{
+    HI_ASSERT(name && *name);
+    HI_ASSERT(data && data > 0);
+    int mq;
+    int ret;
+
+    oflag |= O_WRONLY;
+    mq = mq_open(name, oflag);
+    if (mq < 0) {
+        LOGE("open '%s' for write FAIL, oflag=%04X, err='%s'\n", name, oflag, strerror(errno));
+        return mq;
+    }
+
+    ret = mq_send(mq, data, len, 0);
+    if (ret < 0) {
+        LOGE("send msg to '%s' FAIL, len=%d, err='%s'\n", name, len, strerror(errno));
+    }
+
+    ret = mq_close(mq);
+    if (ret < 0) {
+        LOGE("close '%s' FAIL, err='%s'\n", name, strerror(errno));
+    }
+    return ret;
+}
+
+/**
+    创建子进程执行指定程序.
+*/
+int ForkAndExeclp(const char* file, const char* arg, ...)
+{
+    HI_ASSERT(arg);
+    static const int exitCode = 127;
+    static const int maxArg = 31;
+    char *argv[maxArg + 1];
+    char *s = NULL;
+    va_list ap;
+    int n = 0;
+    int pid;
+
+    // 转换参数到argv中
+    argv[n++] = (char*)arg;
+    va_start(ap, arg);
+    while ((s = va_arg(ap, char*)) != NULL) {
+        HI_ASSERT(n < maxArg);
+        if (n >= maxArg) {
+            LOGE("ForkAndExeclp FAIL, for argNum > %d\n", maxArg);
+            break;
+        }
+        argv[n++] = s;
+    }
+    va_end(ap);
+    HI_ASSERT(n <= maxArg);
+    argv[n] = NULL;
+
+    // fork and exec in child process
+    pid = fork();
+    if (pid == 0) { // child
+        execvp(file, argv);
+        LOGE("execlp('%s', '%s', ..., vaNum=%d) FAIL, err='%s'\n", file, arg, n, strerror(errno));
+        HI_ASSERT(0);
+        exit(exitCode);
+        return exitCode;
+    }
+    HI_ASSERT(pid > 0);
+
+    return pid;
+}
+
+/**
+    尝试lock指定的进程.
+*/
+#ifndef __HuaweiLite__
+int ProcTryLock(const char* pidFile, int* fd)
+{
+    if (fd) {
+        *fd = -1;
+    }
+
+    // 若目录不存在，则创建之
+    int hnd = open(pidFile, O_WRONLY | O_CREAT | O_CLOEXEC, S_IRUSR | S_IWUSR); // 必须加上O_CLOEXEC,增加mode文件所有者可读可写权限
+    HI_EXP_RET(hnd < 0, hnd, "open '%s' FAIL, err='%s, %d'\n", pidFile, strerror(errno), errno);
+
+    if (flock(hnd, LOCK_EX | LOCK_NB) < 0) { // lock FAIL, 已经被其他进程加锁了
+        close(hnd);
+        return -errno;
+    }
+
+    char pid[TINY_BUF_SIZE];
+    int len = snprintf_s(pid, sizeof(pid), sizeof(pid) - 1, "%ld\n", (long)getpid());
+    HI_ASSERT(len > 0);
+    write(hnd, pid, len);
+
+    if (fd) {
+        *fd = hnd;
+    }
+    return 0;
+}
+#else // __HuaweiLite__
+int ProcTryLock(const char* pidFile, int* fd)
+{
+    return 0;
+}
+#endif // __HuaweiLite__
+
+/**
+    从linux like pid文件中读取pid.
+*/
+int GetPidByFile(const char* pidFile)
+{
+    FILE *file = NULL;
+    char buf[TINY_BUF_SIZE];
+    int ret = -1;
+
+    file = fopen(pidFile, "rt");
+    if (!file) {
+        return -1;
+    }
+
+    if (fgets(buf, sizeof(buf), file)) {
+        ret = atoi(buf);
+        if (ret == 0) { // 不应该为0，原因基本确定为buf内容格式不对
+            ret = -1;
+        }
+    }
+
+    fclose(file);
+    return ret;
+}
+
+/**
+    根据pid文件终止进程.
+*/
+int KillByPidFile(const char* pidFile, bool waitEnd, const char* procName)
+{
+    HI_ASSERT(pidFile && procName);
+    int status;
+    int pid;
+    int ret;
+
+    // term
+    pid = GetPidByFile(pidFile);
+    if (pid > 0) {
+        LOGI("kill('%s', %d, 9) ...\n", procName, pid);
+        ret = kill(pid, SIGTERM);
+        if (ret < 0) {
+            LOGE("kill '%s' '%d' FAIL, err='%s'\n", procName, pid, strerror(errno));
+            return ret;
+        }
+        remove(pidFile);
+    } else {
+        LOGI("kill '%s' by '%s', but it not exist\n", procName, pidFile);
+        return 0;
+    }
+
+    // wait child proc end
+    if (pid > 0 && waitEnd) {
+        LOGI("wait '%s' '%d' end ...\n", procName, pid);
+        while (true) {
+            ret = waitpid(pid, &status, 0);
+            if (ret < 0) {
+                LOGE("waitpid(%d) FAIL, err='%s'\n", pid, strerror(errno));
+                sleep(1);
+                break;
+            }
+            if (WIFEXITED(status) || WIFSIGNALED(status) || WCOREDUMP(status)) {
+                LOGD("waitpid(%d) OK, status=%X\n", pid, status);
+                break;
+            }
+        }
+        LOGI("wait '%s' '%d' end done\n", procName, pid);
+    }
+    return 0;
+}
+
+/**
+    目录不存在，则创建.
+*/
+int MkdirIfNeed(const char* dir, bool recursive)
+{
+    HI_ASSERT(dir && *dir);
+    static const mode_t mkdirMode = 0755;
+
+    if (access(dir, F_OK) == 0) {
+        return 0;
+    }
+    if (mkdir(dir, mkdirMode) < 0) {
+        LOGE("@@@ mkdir '%s' FAIL, err='%s, %d'\n", dir, strerror(errno), errno);
+        return -errno;
+    }
+    return 0;
+}
+
+/**
+    获得文件的size，不改变文件位置指针.
+*/
+off_t FileGetSize(FILE* file)
+{
+    off_t savedPos;
+    off_t size;
+
+    savedPos = (int)ftello(file);
+    if (savedPos < 0) {
+        LOGE("get file orig pos FAIL, err='%s, %d'\n", strerror(errno), errno);
+        return -errno;
+    }
+
+    if (fseeko(file, 0, SEEK_END) < 0) {
+        LOGE("fseek FAIL, err='%s, %d'\n", strerror(errno), errno);
+        return -errno;
+    }
+    size = (int)ftello(file);
+    if (size < 0) {
+        LOGE("ftell FAIL, err='%s, %d'\n", strerror(errno), errno);
+        return -errno;
+    }
+    if (fseeko(file, savedPos, SEEK_SET) < 0) {
+        LOGE("seek file to orig pos FAIL, err='%s, %d'\n", strerror(errno), errno);
+        return -errno;
+    }
+    return size;
+}
+
+/**
+    加载文件到buf.
+*/
+long FileLoadToBuf(const char* filePath, uint8_t** data, bool rejectZeroSize)
+{
+    HI_ASSERT(filePath && data);
+    *data = NULL;
+    uint8_t *buf = NULL;
+    int bufSize;
+    int ret = -1;
+    char stFilePath[PATH_MAX] = {0};
+
+    if (!realpath(filePath, stFilePath)) {
+        LOGE("FileLoadToBuf filePath (%s) is not exit\n", filePath);
+        HI_ASSERT(0);
+    }
+    LOGI("FileLoadToBuf standard file path:%s\n", stFilePath);
+    FILE *file = fopen(stFilePath, "rb");
+    HI_EXP_RET(!file, -errno, "open '%s' FAIL\n", stFilePath);
+
+    off_t fileSize = FileGetSize(file);
+    if (fileSize < 0) {
+        LOGE("get size of '%s' FAIL\n", stFilePath);
+        ret = -errno;
+        goto END;
+    }
+
+    HI_EXP_GOTO(fileSize > INT_MAX, END, "fileSize(%jd) > INT_MAX\n", (intmax_t)fileSize);
+    bufSize = (int)fileSize;
+
+    if (bufSize == 0 && rejectZeroSize) {
+        LOGE("size of '%s' is 0, not accept\n", stFilePath);
+        ret = -1;
+        goto END;
+    }
+
+    buf = (uint8_t*)malloc(bufSize + sizeof(uintptr_t)); // 加一点缓冲，用于容错0字节长度
+    HI_ASSERT(buf);
+    ret = fread(buf, 1, bufSize, file);
+    if (ret != bufSize) {
+        LOGE("read '%s' FAIL, ret=%d, err='%s, %d'\n", stFilePath, ret, strerror(errno), errno);
+        ret = -errno;
+        goto END;
+    }
+
+    buf[bufSize] = 0; // 添加0
+    *data = buf;
+    ret = bufSize;
+    buf = NULL;
+
+    END:
+        fclose(file);
+        if (buf) {
+            free(buf);
+        }
+        return ret;
+}
+
+/**
+    init recursive pmutex replaced PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP.
+*/
+void RecurMutexInit(pthread_mutex_t* mutex)
+{
+    HI_ASSERT(mutex);
+    pthread_mutexattr_t attr;
+    int res;
+
+    res = pthread_mutexattr_init(&attr);
+    HI_ASSERT(!res);
+
+    res = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
+    HI_ASSERT(!res);
+    res = pthread_mutex_init(mutex, &attr);
+    HI_ASSERT(!res);
+
+    pthread_mutexattr_destroy(&attr);
+}
+
+/**
+    create a detach thread which not not be join.
+*/
+int DetachThreadCreate(pthread_t *thread, void *(*startRoutine)(void*), void *arg)
+{
+    pthread_attr_t attr;
+    int ret;
+
+    ret = pthread_attr_init(&attr);
+    HI_ASSERT(ret == 0);
+    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+    HI_ASSERT(ret == 0);
+
+    ret = pthread_create(thread, &attr, startRoutine, arg);
+    pthread_attr_destroy(&attr);
+    return ret;
+}
+
+/**
+    创建tcp server socket并listen.
+*/
+int TcpSvrCreate(uint16_t port, uint32_t ip, bool async, int backlog)
+{
+    struct sockaddr_in locAddr = {0};
+    int listenSock;
+    int oval;
+    int ret;
+
+    listenSock = socket(AF_INET, SOCK_STREAM, 0);
+    HI_ASSERT(listenSock > -1);
+
+    // 设置非阻塞模式，默认为阻塞模式
+    if (async) {
+        ret = FdSetAsync(listenSock);
+        HI_CHK_GOTO(ret, FAIL, "FdSetAsync FAIL, err='%s'\n", strerror(errno));
+    }
+
+    // 允许reuse addr
+    oval = 1;
+    if (setsockopt(listenSock, SOL_SOCKET, SO_REUSEADDR, &oval, sizeof(oval)) < 0) {
+        LOGE("set SO_REUSEADDR to listen sock FAIL, err='%s'\n", strerror(errno));
+        ret = -errno;
+        goto FAIL;
+    }
+
+    locAddr.sin_family = AF_INET;
+    locAddr.sin_addr.s_addr = htonl(ip);
+    locAddr.sin_port = htons(port);
+    ret = bind(listenSock, (struct sockaddr*)&locAddr, sizeof(locAddr));
+    HI_CHK_GOTO(ret, FAIL, "socket bind FAIL, err='%s'\n", strerror(errno));
+
+    if (backlog != 0) { // <0表示采用默认值，>0表示要求的值，0表示不listen
+        ret = listen(listenSock, backlog < 0 ? 10 : backlog); // 默认值为10
+        HI_EXP_GOTO(ret < 0, FAIL, "socket listen FAIL, err='%s'\n", strerror(errno));
+    }
+    return listenSock;
+
+    FAIL:
+        if (listenSock >= 0) {
+            close(listenSock);
+        }
+        return -errno;
+}
+
+/**
+    创建tcp client socket并connect.
+*/
+int TcpCltCreate(uint16_t port, uint32_t ip, bool async)
+{
+    struct sockaddr_in dstAddr = {0};
+    int sock;
+    int ret;
+
+    sock = socket(AF_INET, SOCK_STREAM, 0);
+    HI_ASSERT(sock > -1);
+
+    // 设置非阻塞模式，默认为阻塞模式
+    if (async) {
+        ret = FdSetAsync(sock);
+        HI_CHK_GOTO(ret, FAIL, "FdSetAsync FAIL, err='%s'\n", strerror(errno));
+    }
+
+    dstAddr.sin_family = AF_INET;
+    dstAddr.sin_addr.s_addr = htonl(ip);
+    dstAddr.sin_port = htons(port);
+    ret = connect(sock, (struct sockaddr*)&dstAddr, sizeof(dstAddr));
+    if (ret < 0 && (errno != EAGAIN || errno != EWOULDBLOCK)) {
+        LOGE("socket connect FAIL, err='%s, %d'\n", strerror(errno), errno);
+        goto FAIL;
+    }
+    return sock;
+
+    FAIL:
+        if (sock >= 0) {
+            close(sock);
+        }
+        return -errno;
+}
+
+/**
+    SkPair create.
+*/
+int SkPairCreate(SkPair* chn)
+{
+#   define SKPAIR_FDS 2
+    HI_ASSERT(chn);
+    int fds[SKPAIR_FDS];
+
+    if (socketpair(PF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds) < 0) {
+        HI_ASSERT(0);
+    }
+    chn->in = fds[0];
+    chn->out = fds[1];
+    return 0;
+}
+
+/**
+    SkPair destroy.
+*/
+void SkPairDestroy(SkPair* chn)
+{
+    HI_ASSERT(chn);
+
+    if (chn->in >= 0) {
+        if (close(chn->in) < 0) {
+            HI_ASSERT(0);
+        }
+        chn->in = -1;
+    }
+    if (chn->out >= 0) {
+        if (close(chn->out) < 0) {
+            HI_ASSERT(0);
+        }
+        chn->out = -1;
+    }
+}
+
diff -urpBN hiopenais/src/hi_ext_util/posix_help.h hiopenais_modify/src/hi_ext_util/posix_help.h
--- hiopenais/src/hi_ext_util/posix_help.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/posix_help.h	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,421 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef POSIX_HELP_H
+#define POSIX_HELP_H
+
+#include <errno.h>
+#include <strings.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <netinet/in.h>
+#include <pthread.h>
+#ifndef __HuaweiLite__
+#include <sys/eventfd.h>
+#endif
+#include <hi_ext_def.h>
+#include "hi_debug.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define EVENTD_FD_CREATE_NUM  1000
+#define SEM_FD_CREATE_NUM     1000
+
+/**
+    读取指定网口的指定类型的inet地址.
+*/
+int IfGetInetAddr(const char* ifname, in_addr_t* ip, int ioctlOpt);
+
+/**
+    获取指定网口指定类型的IP4地址.
+*/
+int IfGetInetStr(const char* ifname, char* ipBuf, int ipSize, int ioctlOpt);
+
+/**
+    设置指定网口的指定类型的inet地址.
+*/
+int IfSetInetAddr(const char* ifname, in_addr_t ip, int ioctlOpt);
+
+/**
+    获取指定网口的IP4地址.
+*/
+int IfGetIpInt(const char* ifname, in_addr_t* ip);
+
+/**
+    获取指定网口的IP地址.
+*/
+int IfGetIpStr(const char* ifname, char* ipBuf, int ipSize);
+
+/**
+    设置指定网口的IP4地址.
+*/
+int IfSetIpInt(const char* ifname, in_addr_t ip);
+
+/**
+    设置指定网口的IP4地址.
+*/
+int IfSetIpStr(const char* ifname, const char* ipStr);
+
+/**
+    获取指定网口的mask IP4地址.
+*/
+int IfGetMaskInt(const char* ifname, in_addr_t* ip);
+
+/**
+    获取指定网口的mask IP地址.
+*/
+int IfGetMaskStr(const char* ifname, char* ipBuf, int ipSize);
+
+/**
+    设置指定网口的mask IP4地址.
+*/
+int IfSetMaskInt(const char* ifname, uint32_t mask);
+
+/**
+    设置指定网口的mask IP4地址.
+*/
+int IfSetMaskStr(const char* ifname, const char* maskStr);
+
+/**
+    获取指定网口的广播IP4地址.
+*/
+int IfGetBroadcastInt(const char* ifname, in_addr_t* addr);
+
+/**
+    获取指定网口的广播IP4地址.
+*/
+int IfGetBroadcastStr(const char* ifname, char* addrBuf, int addrSize);
+
+/**
+    设置指定网口的广播IP4地址.
+*/
+int IfSetBroadcastInt(const char* ifname, in_addr_t addr);
+
+/**
+    设置指定网口的广播IP4地址.
+*/
+int IfSetBroadcastStr(const char* ifname, const char* addrStr);
+
+/**
+    获取指定网口的MAC地址.
+*/
+int IfGetMacBytes(const char* ifname, uint8_t* macBuf, int macLen);
+
+/**
+    获取指定网口的MAC地址.
+*/
+int IfGetMacStr(const char* ifname, char* macBuf, int macSize);
+
+/**
+    等待fd有信号.
+    fd可以工作于异步模式。
+*/
+int FdWait(int fd, int64_t timeout);
+
+/**
+    查询给定的fd是否可读.
+*/
+bool FdReadable(int fd, int* err);
+
+/**
+    查询给定的fd是否可写.
+*/
+bool FdWritable(int fd, int* err);
+
+/**
+    读取完整消息.
+*/
+int FdReadMsg(int fd, void* msgBuf, int msgSize);
+
+/**
+    写入完整消息.
+*/
+int FdWriteMsg(int fd, const void* msgData, int msgLen);
+
+/**
+    设置fd为异步模式.
+*/
+int FdSetAsync(int fd);
+
+/**
+    设置fd为阻塞模式.
+*/
+int FdSetBlock(int fd);
+
+/**
+    对listen socket执行accept.
+*/
+int SockAccept(int listenSock);
+
+/**
+    mqueue atom send.
+*/
+int MqAtomSend(const char* name, const void* data, int len, uint32_t oflag);
+
+/**
+    创建子进程执行指定程序.
+*/
+int ForkAndExeclp(const char* file, const char* arg, ...);
+
+/**
+    尝试lock指定的进程.
+*/
+int ProcTryLock(const char* pidFile, int* fd);
+
+/**
+    从linux like pid文件中读取pid.
+*/
+int GetPidByFile(const char* pidFile);
+
+/**
+    根据pid文件终止进程.
+*/
+int KillByPidFile(const char* pidFile, bool waitEnd, const char* procName);
+
+/**
+    目录不存在，则创建.
+*/
+int MkdirIfNeed(const char* dir, bool recursive);
+
+/**
+    获得文件的size，不改变文件位置指针.
+*/
+long FileGetSize(FILE* file);
+
+/**
+    加载文件到buf.
+*/
+long FileLoadToBuf(const char* filePath, uint8_t** data, bool rejectZeroSize);
+
+#   ifndef __HuaweiLite__
+
+/**
+    用常用参数创建eventfd.
+    仅适用于信号产生器类型。
+*/
+static inline int EventFdCreate(void)
+{
+    return eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
+}
+
+/**
+    用常用参数创建信号量模式的eventfd.
+    仅适用于信号量类型。
+*/
+static inline int SemFdCreate(void)
+{
+    return eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK | EFD_SEMAPHORE);
+}
+
+/**
+    poll all event.
+    常用于信号产生器，虽然可用于信号灯类型的eventfd，但不推荐。
+    仅用于nonblock模式。
+*/
+static inline uint64_t EventFdClear(int fd)
+{
+    uint64_t ret = 0;
+    uint64_t eval;
+
+    while (eventfd_read(fd, &eval) == 0) {
+        ret += eval;
+    }
+    int errnumber = errno;
+    HI_ASSERT(errnumber == EAGAIN || errnumber == EWOULDBLOCK);
+    return ret;
+}
+
+/**
+    为eventfd计数器加1.
+    可用于信号产生器或信号量。
+*/
+static inline void EventFdInc(int fd)
+{
+    if (eventfd_write((fd), 1) < 0) {
+        HI_ASSERT(0);
+    }
+}
+
+/**
+    信号量加1.
+*/
+static inline void SemFdInc(int fd)
+{
+    EventFdInc(fd);
+}
+
+/**
+    信号量减1.
+    仅用于信号量，仅用于nonblock模式。
+*/
+static inline int SemFdDec(int fd)
+{
+    uint64_t eval;
+    int ret;
+
+    ret = eventfd_read(fd, &eval);
+    int errnumber = errno;
+    HI_ASSERT((ret == 0 && eval == 1) || (ret < 0 && (errnumber == EAGAIN || errnumber == EWOULDBLOCK)));
+    return ret < 0 ? 0 : (int)eval;
+}
+
+#else // __huaweiLite__
+
+/**
+    用常用参数创建eventfd.
+    仅适用于信号产生器类型。
+*/
+static inline int EventFdCreate(void)
+{
+    return EVENTD_FD_CREATE_NUM;
+}
+
+/**
+    用常用参数创建信号量模式的eventfd.
+    仅适用于信号量类型。
+*/
+static inline int SemFdCreate(void)
+{
+    return SEM_FD_CREATE_NUM;
+}
+
+/**
+    poll all event.
+    常用于信号产生器，虽然可用于信号灯类型的eventfd，但不推荐。
+    仅用于nonblock模式。
+*/
+static inline uint64_t EventFdClear(int fd)
+{
+    return 0;
+}
+
+/**
+    为eventfd计数器加1.
+    可用于信号产生器或信号量。
+*/
+static inline void EventFdInc(int fd)
+{
+    return;
+}
+
+/**
+    信号量加1.
+*/
+static inline void SemFdInc(int fd)
+{
+    EventFdInc(fd);
+}
+
+/**
+    信号量减1.
+    仅用于信号量，仅用于nonblock模式。
+*/
+static inline int SemFdDec(int fd)
+{
+    return 0;
+}
+
+#endif // __HuaweiLite__
+
+/**
+    pthread mutex lock.
+*/
+static inline void MutexLock(pthread_mutex_t* mutex)
+{
+    if (pthread_mutex_lock(mutex) != 0) {
+        HI_ASSERT(0);
+    }
+}
+
+/**
+    pthread mutex lock.
+*/
+static inline void MutexUnlock(pthread_mutex_t* mutex)
+{
+    if (pthread_mutex_unlock(mutex) != 0) {
+        HI_ASSERT(0);
+    }
+}
+
+/**
+    pthread mutex destroy.
+*/
+static inline void MutexDestroy(pthread_mutex_t* mutex)
+{
+    if (pthread_mutex_destroy(mutex) != 0) {
+        HI_ASSERT(0);
+    }
+}
+
+/**
+    init recursive pmutex replaced PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP.
+*/
+void RecurMutexInit(pthread_mutex_t* mutex);
+
+/**
+    create a detached thread which not not be join.
+*/
+int DetachThreadCreate(pthread_t *thread, void *(*startRoutine)(void*), void *arg);
+
+/**
+    创建tcp server socket并listen.
+*/
+int TcpSvrCreate(uint16_t port, uint32_t ip, bool async, int backlog);
+
+/**
+    创建tcp client socket并connect.
+*/
+int TcpCltCreate(uint16_t port, uint32_t ip, bool async);
+
+/**
+    socketpair channel.
+*/
+typedef struct SkPair {
+    int in; // in fd
+    int out; // out fd
+}   SkPair;
+
+/**
+    create/destroy SkPair.
+*/
+int SkPairCreate(SkPair* chn);
+void SkPairDestroy(SkPair* chn);
+
+/**
+    SkPair是否为已成功创建.
+*/
+static inline bool SkPairValid(const SkPair* chn)
+{
+    HI_ASSERT(chn);
+    return chn->in >= 0 && chn->out >= 0;
+}
+
+/**
+    SkPair对象初始化.
+*/
+static inline void SkPairInit(SkPair* chn)
+{
+    HI_ASSERT(chn);
+    chn->in = -1;
+    chn->out = -1;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // POSIX_HELP_H
diff -urpBN hiopenais/src/hi_ext_util/strm_msg_sk.c hiopenais_modify/src/hi_ext_util/strm_msg_sk.c
--- hiopenais/src/hi_ext_util/strm_msg_sk.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/strm_msg_sk.c	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,494 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <strings.h>
+#include <stdarg.h>
+#include <limits.h>
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/socket.h>
+
+#include "hi_ext_util.h"
+#include "strm_msg_sk.h"
+
+/**
+    StrmMsgSk数据成员.
+*/
+struct StrmMsgSk {
+    pthread_mutex_t mutex;
+    EvtMon *emon;
+    bool closed; // 表示sock是否已close的状态
+    int sock; // TCP socket
+
+    int rxFd; // 向user指示收到消息的信号量
+    int txFd; // 向user指示发送缓冲可用的事件
+    int userFd; // 向服务线程指示有user请求改变状态，如user发送消息请求，user接收消息导致rxPause解除等
+
+    struct list_head txList; // 发送队列，用于缓存user提交的待发送消息
+    struct list_head rxList; // 接收队列，用于缓存从对端收到的完整消息
+
+    MemBlk *rxMsg; // 正在接收的不完整消息
+
+    bool txBusy; // 发送状态，表示TCP发送缓冲是否满
+    bool rxPaused; // 因rxList达到最大消息数量而暂停接收
+
+    uint32_t rxListSize; // rxList中的消息的总size，不包括正在接收的rxMsg的size
+    uint32_t rxMsgSize; // 正在接收的消息的size，仅当接收超出限制时才使用
+    uint32_t maxRxMsgSize; // 接收消息允许的最大size
+    uint32_t maxRxListSize; // 允许缓存接收消息的最大size
+};
+
+/**
+    尝试发送数据.
+*/
+static void SmsTxTry(StrmMsgSk* self)
+{
+    if (self->txBusy || self->closed) {
+        return;
+    }
+
+    // 虽然user线程会通过send()操作txList，但读取txList时不用加锁
+    // 但在将node从txList删除时，以及校验list是否为空时才需要加锁
+    // 检查list是否为空实际也是不需要加锁的，这里为保险起见做了加锁
+    while (!self->txBusy) {
+        bool empty;
+        MutexLock(&self->mutex);
+        empty = list_empty(&self->txList);
+        MutexUnlock(&self->mutex);
+        if (empty) {
+            break;
+        }
+
+        MemBlk *msg = list_entry(self->txList.next, MemBlk, lnode);
+        HI_ASSERT(msg->len > 0 && msg->offset < msg->len);
+        int len = msg->len - msg->offset;
+
+        int ret = write(self->sock, &msg->data[msg->offset], len);
+        if (ret > 0) {
+            if (ret == len) { // 该blk的所有数据均write
+                // 删除node时必须加锁，否则会与user线程通过send对txList的添加操作冲突
+                MutexLock(&self->mutex);
+                list_del(&msg->lnode);
+                MutexUnlock(&self->mutex);
+
+                MemBlkDelete(msg);
+            } else { // 该blk只write了部分数据
+                HI_ASSERT(ret < len);
+                msg->offset += ret;
+            }
+        } else if (ret < 0) {
+            if (errno == EAGAIN || errno == EWOULDBLOCK) {
+                LOGD("txTry detect EAGAIN\n");
+                self->txBusy = true;
+            } else {
+                LOGE("txTry FAIL, regard as CLOSED???, err='%s, %d'\n", strerror(errno), errno);
+            }
+        } else {
+            HI_ASSERT(0);
+        }
+    }
+}
+
+/**
+    尝试读取消息头数据.
+*/
+static bool SmsRxHdr(StrmMsgSk* self)
+{
+    HI_ASSERT(!self->rxMsg);
+    uint32_t msgLen = 0; // 消息的长度，含msgHdr
+    int ret;
+
+    // 读取消息头，其仅包含msgLen字段
+    if (self->rxMsgSize > 0) { // 这说明此前因为rxList总size超限，rx被pause了，这里直接取出保存的msgSize
+        HI_ASSERT(self->rxMsgSize > 0);
+        msgLen = self->rxMsgSize;
+        self->rxMsgSize = 0; // 先置0，此函数后面可能会再恢复它的值
+    } else { // 需要从sock读取sizeof(msgLen)
+        // 临时简化处理，将读取消息头当做原子操作，其可能会阻塞
+        LOGD("issue FdReadMsg ...\n");
+        ret = FdReadMsg(self->sock, &msgLen, sizeof(msgLen));
+        if (ret != sizeof(msgLen)) {
+            if (ret < 0) {
+                LOGW("FdReadMsg FAIL, regard as CLOSED\n");
+                self->closed = true;
+            }
+            LOGD("issue FdReadMsg FAIL, ret=%d, ...\n", ret);
+            return false;
+        }
+        msgLen = ntohl(msgLen); // 读出的是大端字序，需要转为本机字节顺序
+        LOGD("issue FdReadMsg done, ret=%d, msgLen=%u, ...\n", ret, msgLen);
+    }
+
+    // 检查msgLen是否超出maxRxMsgSize, NOTE: 不允许msg只包含msgHdr
+    if (msgLen <= sizeof(msgLen) || msgLen > self->maxRxMsgSize) {
+        LOGE("detect rx-msg size exceed limit, %u>%u, regard as CLOSED\n", msgLen, self->maxRxMsgSize);
+        self->closed = true;
+        return false;
+    }
+
+    // 检查被缓存的rxList中的消息加上此消息size后，是否超出设定的限制
+    // 为保险起见，这里在锁内执行这些操作，而不仅仅是加锁获得rxListSize
+    MutexLock(&self->mutex);
+    if (msgLen > self->maxRxListSize || self->rxListSize > self->maxRxListSize - msgLen) {
+        LOGW("detect rx-list size exceed limit, %u+%u>%u, pause rx\n", self->rxListSize, msgLen, self->maxRxListSize);
+        HI_ASSERT(!self->rxMsgSize);
+        self->rxMsgSize = msgLen;
+        self->rxPaused = true;
+        MutexUnlock(&self->mutex);
+        return false;
+    }
+    MutexUnlock(&self->mutex);
+
+    // 分配消息buf
+    HI_ASSERT(!self->rxMsg);
+    MemBlk *rxMsg = self->rxMsg = MemBlkNew(msgLen);
+    if (!rxMsg) { // 这里需要检查分配结果
+        LOGE("alloc rx-msg buf FAIL, regard as CLOSED, msgSize=%u\n", msgLen);
+        self->closed = true;
+        return false;
+    }
+
+    // 将msgHdr复制到消息中，此时不将msgLen添加到rxLiseSize中，而在消息接收完成，添加到rxList时再处理
+    rxMsg->len = sizeof(msgLen);
+    msgLen = htonl(msgLen);
+    if (memcpy_s(rxMsg->data, rxMsg->size, &msgLen, sizeof(msgLen)) != EOK) {
+        HI_ASSERT(0);
+    }
+    return true;
+}
+
+/**
+    尝试读取数据.
+*/
+static bool SmsRxTry(StrmMsgSk* self)
+{
+    int ret;
+
+    HI_ASSERT(!self->rxPaused); // 按现有设计，paused时是不会执行此函数的
+    if (self->closed) {
+        return false;
+    }
+
+    // 先接收消息头，以确定消息长度，并创建rxMsg
+    if (!self->rxMsg && !SmsRxHdr(self)) {
+        return false;
+    }
+
+    MemBlk *rxMsg = self->rxMsg;
+    HI_ASSERT(rxMsg);
+
+    // 读取数据，直到EAGAIN
+    while ((ret = read(self->sock, &rxMsg->data[rxMsg->len], rxMsg->size - rxMsg->len)) > 0) {
+        rxMsg->len += ret;
+        if (rxMsg->len == rxMsg->size) { // 当前消息接收完成
+            MutexLock(&self->mutex);
+            LOGD("emit MSG_IN evt\n");
+            self->rxMsg->offset = 0;
+            list_add_tail(&self->rxMsg->lnode, &self->rxList);
+            self->rxListSize += rxMsg->size;
+            self->rxMsg = NULL;
+            SemFdInc(self->rxFd);
+            MutexUnlock(&self->mutex);
+            return true;
+        } else {
+            HI_ASSERT(rxMsg->len < rxMsg->size);
+        }
+    }
+
+    // 处理错误码
+    if (ret == 0) {
+        LOGI("TMS: detect CLOSED on read\n");
+        self->closed = true;
+    } else if (errno != EAGAIN && errno != EWOULDBLOCK) {
+        LOGW("detect ERR on read, regard as CLOSED\n");
+        self->closed = true;
+    }
+    return false;
+}
+
+/**
+    收到tcp事件.
+*/
+static void SmsOnSock(void* user, int fd, uint32_t evts)
+{
+    StrmMsgSk *self = (StrmMsgSk*)user;
+    HI_ASSERT(self && self->sock == fd);
+    bool prevClosed = self->closed;
+
+    LOGD("onTcp, IN=%d, OUT=%d, ERR=%d ...\n",
+        ((evts & FDE_IN) ? 1 : 0), ((evts & FDE_OUT) ? 1 : 0), ((evts & FDE_ERR) ? 1 : 0));
+
+    // error，可能连接断开
+    if (evts & FDE_ERR) {
+        LOGW("onTcp detect ERR evts %#x, regard CLOSED\n", evts);
+        self->closed = true;
+        goto END;
+    }
+
+    // 数据可读
+    if ((evts & FDE_IN)) {
+        // paused的resume启动不在这里，而是在OnUser中检测
+        if (self->rxPaused) {
+            LOGW("ignore sock read, for in paused\n");
+        } else { // 未paused时才处理
+            while (SmsRxTry(self)) {} // 循环，可能收到多个消息
+            if (self->closed) {
+                goto END;
+            }
+        }
+    }
+
+    // buf可写
+    if (evts & FDE_OUT) {
+        // 可以在这里emit txFd事件
+        self->txBusy = false;
+        SmsTxTry(self);
+    }
+
+    // 未知且未处理事件
+    if (evts & ~(FDE_IN | FDE_OUT | FDE_ERR)) {
+        LOGE("onTcp detect un-handle evts %#x, ignore\n", evts);
+        goto END;
+    }
+
+    END:
+        if (self->closed && !prevClosed) {
+            LOGW("emit CLOSED evt, onTcp\n");
+            SemFdInc(self->rxFd);
+        }
+}
+
+/**
+    有user事件.
+*/
+static void SmsOnUser(void* user, int fd, uint32_t evts)
+{
+    StrmMsgSk* self = (StrmMsgSk*)user;
+    HI_ASSERT(self && self->userFd == fd);
+    EvtChkRet(evts, FDE_IN, fd);
+    bool prevClosed = self->closed;
+
+    EventFdClear(fd);
+
+    // 尝试发送，无论底层txBuf是否满
+    SmsTxTry(self);
+    if (self->closed && !prevClosed) {
+        LOGW("emit CLOSED evt, by tx, onUser\n");
+        SemFdInc(self->rxFd);
+        return;
+    }
+
+    // rxPaused时，执行一次resume检查和处理
+    if (self->rxPaused) {
+        // 判断是否可以解除paused，锁内执行
+        MutexLock(&self->mutex);
+        HI_ASSERT(!self->rxMsg);
+        HI_ASSERT(self->rxMsgSize > 0 && self->rxMsgSize <= self->maxRxListSize);
+        if (self->rxListSize < self->maxRxListSize - self->rxMsgSize) {
+            self->rxPaused = false;
+        }
+        MutexUnlock(&self->mutex);
+
+        // pause被解除后，立刻触发接收sock数据
+        if (!self->rxPaused) {
+            while (SmsRxTry(self)) {} // 循环接收
+            if (self->closed && !prevClosed) {
+                LOGW("emit CLOSED evt, by rx, onUser\n");
+                SemFdInc(self->rxFd);
+            }
+        }
+    }
+}
+
+/**
+    异步发送消息.
+*/
+int SmsSend(StrmMsgSk* self, MemBlk* msg)
+{
+    HI_ASSERT(self && msg);
+    int ret;
+
+    MutexLock(&self->mutex);
+    if (self->closed) {
+        LOGW("send FAIL, for conn closed, msg MUST be freed by user\n");
+        ret = -ESHUTDOWN;
+    } else {
+        msg->offset = 0;
+        list_add_tail(&msg->lnode, &self->txList);
+        // 通知服务线程处理，而不在这里直接txTry，以减小多线程处理复杂度
+        EventFdInc(self->userFd);
+        ret = 1; // 表示成功缓冲1个消息
+    }
+    MutexUnlock(&self->mutex);
+    return ret;
+}
+
+/**
+    异步接收消息.
+*/
+int SmsRecv(StrmMsgSk* self, MemBlk** msg)
+{
+    HI_ASSERT(self && msg);
+    int ret;
+
+    MutexLock(&self->mutex);
+    if (list_empty(&self->rxList)) {
+        // 基于容错考虑，当closed时，信号量就不减一了
+        *msg = NULL;
+        ret = self->closed ? 0 : -EAGAIN; // 通过返回0来指示连接是否断开
+    } else {
+        ret = SemFdDec(self->rxFd); // 消费1
+        HI_ASSERT(ret == 1);
+
+        *msg = list_entry(self->rxList.next, MemBlk, lnode);
+        list_del(self->rxList.next);
+        ret = 1;
+
+        // rxList总size超限解除处理，需要在锁内执行
+        uint32_t msgLen = (*msg)->size;
+        HI_ASSERT(self->rxListSize >= msgLen);
+        self->rxListSize -= msgLen;
+        if (self->rxPaused) { // 仅唤醒服务线程处理，这里并不检查是否该resume及重置rxPaused状态
+            EventFdInc(self->userFd);
+        }
+    }
+    MutexUnlock(&self->mutex);
+    return ret;
+}
+
+/**
+    获得可监视send fd.
+*/
+int SmsSendFd(StrmMsgSk* self)
+{
+    HI_ASSERT(self);
+    return self->txFd;
+}
+
+/**
+    获得可监视recv fd.
+*/
+int SmsRecvFd(StrmMsgSk* self)
+{
+    HI_ASSERT(self);
+    return self->rxFd;
+}
+
+/**
+    StrmMsgSk create.
+*/
+int SmsCreate(StrmMsgSk** sk, int sock, uint32_t maxRxMsgSize, uint32_t maxRxListSize)
+{
+    LOGI("TMS: create ...\n");
+    HI_ASSERT(sk && sock >= 0);
+    StrmMsgSk *self = NULL;
+    int ret;
+
+    *sk = NULL;
+
+    // 设置非阻塞模式
+    ret = FdSetAsync(sock);
+    HI_CHK_RET(ret, "FdSetAsync FAIL, ret=%d\n", ret);
+
+    self = (StrmMsgSk*)malloc(sizeof(*self));
+    if (!self) {
+        HI_ASSERT(0);
+    }
+    if (memset_s(self, sizeof(*self), 0, sizeof(*self)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    RecurMutexInit(&self->mutex);
+    self->closed = false;
+    self->sock = sock;
+
+    self->rxMsg = NULL;
+    self->txBusy = false;
+    self->rxPaused = false;
+    self->rxListSize = 0;
+    self->rxMsgSize = 0;
+    self->maxRxMsgSize = maxRxMsgSize ? maxRxMsgSize : UINT32_MAX;
+    self->maxRxListSize = maxRxListSize ? maxRxListSize : UINT32_MAX;
+
+    self->rxFd = SemFdCreate();
+    HI_ASSERT(self->rxFd >= 0);
+    self->txFd = EventFdCreate();
+    HI_ASSERT(self->txFd >= 0);
+    self->userFd = EventFdCreate();
+    HI_ASSERT(self->userFd >= 0);
+
+    INIT_LIST_HEAD(&self->txList);
+    INIT_LIST_HEAD(&self->rxList);
+
+    EmCreate(&self->emon);
+    if (EmAddFd(self->emon, sock, FDE_IN | FDE_OUT | FDE_ET, SmsOnSock, self) < 0) {
+        HI_ASSERT(0);
+    }
+    if (EmAddFd(self->emon, self->userFd, FDE_IN, SmsOnUser, self) < 0) {
+        HI_ASSERT(0);
+    }
+    EmStart(self->emon);
+
+    *sk = self;
+    LOGI("TMS: create done\n");
+    return 0;
+}
+
+/**
+    StrmMsgSk destroy.
+*/
+void SmsDestroy(StrmMsgSk* self)
+{
+    LOGI("TMS: destroy ...\n");
+    HI_ASSERT(self);
+
+    // 终止后台服务，并取消监听的fd
+    EmStop(self->emon);
+    if (EmDelFd(self->emon, self->sock) < 0) {
+        HI_ASSERT(0);
+    }
+    close(self->sock);
+    if (EmDelFd(self->emon, self->userFd) < 0) {
+        HI_ASSERT(0);
+    }
+    EmDestroy(self->emon);
+
+    // 清空rxList, txList中的消息
+    MutexLock(&self->mutex);
+    MemBlksDelete(&self->rxList);
+    MemBlksDelete(&self->txList);
+    MutexUnlock(&self->mutex);
+
+    // 删除正在接收的消息
+    if (self->rxMsg) {
+        MemBlkDelete(self->rxMsg);
+    }
+    HI_ASSERT(self->rxFd >= 0);
+    close(self->rxFd);
+    HI_ASSERT(self->txFd >= 0);
+    close(self->txFd);
+    HI_ASSERT(self->userFd >= 0);
+    close(self->userFd);
+
+    MutexDestroy(&self->mutex);
+
+    free(self);
+    LOGI("TMS: destroy done\n");
+}
+
diff -urpBN hiopenais/src/hi_ext_util/strm_msg_sk.h hiopenais_modify/src/hi_ext_util/strm_msg_sk.h
--- hiopenais/src/hi_ext_util/strm_msg_sk.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hi_ext_util/strm_msg_sk.h	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef STRM_MSG_SK_H
+#define STRM_MSG_SK_H
+
+#include <stdint.h>
+#include "hi_misc_util.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    Stream Message Socket type.
+*/
+typedef struct StrmMsgSk StrmMsgSk;
+
+/**
+    StrmMsgSk create.
+
+    @param sock[in]: 宸茬寤虹stream杩ャ
+*/
+int SmsCreate(StrmMsgSk** sk, int sock, uint32_t maxRxMsgSize, uint32_t maxRxListSize);
+
+/**
+    StrmMsgSk destroy.
+*/
+void SmsDestroy(StrmMsgSk* self);
+
+/**
+    寮姝ュ娑.
+*/
+int SmsSend(StrmMsgSk* self, MemBlk* msg);
+
+/**
+    寮姝ユユ舵.
+*/
+int SmsRecv(StrmMsgSk* self, MemBlk** msg);
+
+/**
+    峰瑙send fd.
+*/
+int SmsSendFd(StrmMsgSk* self);
+
+/**
+    峰瑙recv fd.
+*/
+int SmsRecvFd(StrmMsgSk* self);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // STRM_MSG_SK_H
diff -urpBN hiopenais/src/hiopenais/hiopenais.c hiopenais_modify/src/hiopenais/hiopenais.c
--- hiopenais/src/hiopenais/hiopenais.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hiopenais/hiopenais.c	2021-03-29 20:48:05.000000000 -0700
@@ -0,0 +1,534 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#ifdef CFG_HISTM
+#include "hicamera_control.h"
+#include "uvc_histreaming.h"
+#endif
+
+#include "hi_unf_cipher.h"
+
+#include "aic_mng.h"
+#include "uvc_dev.h"
+
+#include "hi_ext_util.h"
+#include "lite_httpd.h"
+#include "httpd_aic.h"
+#include "histm_aic.h"
+#include "uvc_aic.h"
+#include "strm_saver.h"
+#include "ext_plug.h"
+#include "mpp_help.h"
+#include "plug_mng.h"
+#include "inet_test_util.h"
+
+#define APP_PID_FILE        "/var/run/hiopenais.pid" // proc PID file, 暂时不支持配置
+
+#define APP_CFG_FILE        "./hiopenais.conf" // global app config file
+#define UVC_CFG_SEC         "uvc_dev0" // uvc dev0 config section name
+
+#define TCP_SVR1_PORT       8501 // tcp test server port
+#define TCP_SVR2_PORT       8502 // tcp test server port
+
+#define VB_BUF_WIDTH        2592 // 初始化VB时使用的width
+#define VB_BUF_HEIGHT       1944 // 初始化VB时使用的height
+#define VB_BUF_NUM          8 // VB buf的数目
+#define VB_BUF_TMP_NUM      20
+#define VB_BUF_TMP_WIDTH    480
+#define VB_BUF_TMP_HEIGHT   960
+
+#define SAVER_QUE_SIZE      10
+#define SAVER_FRM_PER_FILE  300
+#define SAVER_FILE_PFX      "/nfs/strm_que/"
+#define VO_PLUG_ID_MAX      9 // 加载的VO插件序号的最大值，从0开始
+#define HICLOCK_RUNTIME     10000 // 10s
+
+#define AICSTART_VI_OUTWIDTH    1920
+#define AICSTART_VI_OUTHEIGHT   1080
+#define AICSTART_VO_OUTWIDTH    1920
+#define AICSTART_VO_OUTHEIGHT   1080
+
+/**
+    The App datas.
+*/
+typedef struct TheApp {
+    uvc_dev_ext_t *uvcDev;
+    UvcAgent *uvcAgent;
+
+    StrmSaver *strmSaver;
+    struct list_head extList; // 加载的VO插件信息，元素类型为VoPlugLib
+
+    int stdinFlags;
+
+    // for tcp speed test
+    int tcpSvr1;
+    int tcpSvr2;
+    TcpMultiRx tcpMrx;
+}   TheApp;
+
+/**
+    tcp test server1有连接到达.
+*/
+static void OnTcpSvr1(void* user, int fd, uint32_t evts)
+{
+    LOGW("on tcp test svr1 ...\n");
+    EvtChkRet(evts, FDE_IN, fd);
+    pthread_t thrdId;
+    int sock;
+
+    sock = SockAccept(fd);
+    if (sock < 0) {
+        return;
+    }
+
+    if (DetachThreadCreate(&thrdId, TcpRxSpeedTest, (void*)(uintptr_t)sock)) {
+        HI_ASSERT(0);
+    }
+}
+
+/**
+    tcp test server2有连接到达.
+*/
+static void OnTcpSvr2(void* user, int fd, uint32_t evts)
+{
+    LOGW("on tcp test svr2 ...\n");
+    EvtChkRet(evts, FDE_IN, fd);
+    TcpMultiRx *self = (TcpMultiRx*)user;
+    pthread_t thrdId;
+    int sock;
+
+    sock = SockAccept(fd);
+    if (sock < 0) {
+        return;
+    }
+
+    if (self->sock >= 0) {
+        LOGE("discard new conn, for prev conn alive\n");
+        close(sock);
+        return;
+    }
+
+    self->sock = sock;
+    if (DetachThreadCreate(&thrdId, TcpMultiRxSpeedTest, self)) {
+        HI_ASSERT(0);
+    }
+}
+
+/**
+    测试usleep精度.
+*/
+void UsleepTest(void)
+{
+    LOGW("test usleep precision ...\n");
+    int64_t begTime = HiClockMs();
+    int64_t usNum = 0;
+    while (HiClockMs() - begTime < HICLOCK_RUNTIME) {
+        usleep(1);
+        usNum++;
+    }
+    if (usNum != 0) {
+        LOGW("usNum=%lld, cost=10,000,000us, usPrecision=%lld\n", usNum, HICLOCK_RUNTIME * 1000LL / usNum);
+    }
+}
+
+/**
+    注册histm cmd.
+*/
+static void StmCmdInit(TheApp* app)
+{
+#   ifdef CFG_HISTM
+    LOGI("MAIN: reg HiSTM cmd ...\n");
+    extern struct uvc_camera_cmd mappings[CMD_MAX_NUM];
+    for (int i = 0; i < 4; i++) {
+        if (hi_camera_register_cmd(&mappings[i]) < 0) {
+            printf("APP: register HiSTM cmd failed\n");
+        }
+    }
+    histream_reg_cmd_proc(app->uvcDev, run_cmd_func);
+    histream_reg_strm_off_proc(app->uvcDev, ResetUVCClientID);
+#   endif
+}
+
+/**
+    注销histm cmd.
+*/
+static void StmCmdExit(TheApp* app)
+{
+#   ifdef CFG_HISTM
+    SAMPLE_HISTM_Stop(); // start由UVC私有协议触发，此函数会检测是否已经start
+    histream_reg_cmd_proc(app->uvcDev, NULL);
+#   endif
+}
+
+/**
+    初始化MPP.
+*/
+static int MppInit(void)
+{
+    VbCfg vbCfg;
+
+    // log sensor type，以确认布署的版本是否对
+    int snsType;
+    const char *snsName = CurSnsType(0, &snsType);
+    LOGI("MAIN: SENSOR0_TYPE='%s, %d'\n", snsName, snsType);
+
+    VbCfgInit(&vbCfg);
+
+    VbCfgAddForSns(&vbCfg, VB_BUF_NUM, SENSOR0_TYPE); // sample为15块
+    VbCfgAddPool(&vbCfg, VB_BUF_NUM, VB_BUF_WIDTH, VB_BUF_HEIGHT); // sample为15块
+
+    VbCfgAddPool(&vbCfg, VB_BUF_TMP_NUM, VB_BUF_TMP_WIDTH, VB_BUF_TMP_HEIGHT); // sample为YUV420，这里为YUV422
+    VbCfgAddPool(&vbCfg, VB_BUF_TMP_NUM, VB_BUF_TMP_WIDTH, VB_BUF_TMP_HEIGHT); // sample为YUV420，这里为YUV422
+
+    return MppSysInit(&vbCfg);
+}
+
+/**
+    进程级信号处理器.
+*/
+static void SigProc(HI_S32 signo)
+{
+    signal(SIGINT, SIG_IGN);
+    signal(SIGTERM, SIG_IGN);
+
+    // detect SIGTERM/SIGINT, notify main thrd
+    // EmQuit()和main_emon_quit()均被设计为信号安全，可在这里调用
+    if (EmQuit(MainEvtMon()) < 0) {
+        _exit(HI_EC_ASSERT_FAIL);
+    }
+}
+
+/**
+    stdin有输入.
+*/
+static void OnStdin(void* user, int fd, uint32_t evts)
+{
+    HI_ASSERT(fd == STDIN_FILENO);
+
+    if (evts & ~(FDE_IN)) {
+        LOGE("detect un-handle job-end-fd evts, fd=%d, evts=%X\n", fd, evts);
+    }
+    if (!(evts & FDE_IN)) {
+        return;
+    }
+
+    // linux stdin特性，只有当输入换行符才会产生事件，不过即便不如此，下列代码也OK
+    char line[LARGE_BUF_SIZE]; // 一行的最大长度1024
+    while (fgets(line, sizeof(line), stdin)) {
+        // shell cmd must begin by '$', 'sh' or 'shell'
+        char *parser = line;
+        char *token = HiStrtoks(&parser, " \t\r\n");
+        if (!token || !*token) {
+            continue;
+        }
+
+        // 退出命令
+        if (strcmp(token, "quit") == 0 || strcmp(token, "exit") == 0) {
+            if (EmQuit(MainEvtMon()) < 0) {
+                _exit(HI_EC_ASSERT_FAIL);
+            }
+            break;
+        }
+
+        // 内置命令 ...
+        if (strcmp(token, "set_dbg_lev") == 0) {
+            token = HiStrtoks(&parser, "\r\n");
+            if (!token || !*token) {
+                LOGE("set_dbg_lev without lev\n");
+                continue;
+            }
+            HiSetDbgLev(atoi(token));
+            continue;
+        }
+
+        // shell cmd ...
+        if (strcmp(token, "$") != 0 && strcmp(token, "sh") != 0 && strcmp(token, "shell") != 0) {
+            continue;
+        }
+        token = HiStrtoks(&parser, "\r\n");
+        if (token && *token) {
+            LOGI("$ '%s'\n", token);
+            system(token);
+        }
+    }
+}
+
+/**
+    加载配置文件中指定的VO plugs并初始化它.
+*/
+static void VosInit(TheApp* app)
+{
+    char key[SMALL_BUF_SIZE];
+    int ret;
+
+    // 枚举conf中需要为0~VO_PLUG_ID_MAX的配置项，获取其插件文件名称，加载插件
+    for (int i = 0; i < VO_PLUG_ID_MAX + 1; i++) {
+        if (snprintf_s(key, sizeof(key), sizeof(key) - 1, "work_exts:plug%d", i) < 0) {
+            HI_ASSERT(0);
+        }
+        const char* plugName = GetCfgStr(key, NULL);
+        if (!plugName || !*plugName) {
+            continue;
+        }
+        LOGI("MAIN: load '%s' ...\n", plugName);
+
+        ExtPlugLib *plug = NULL;
+        ret = ExtPlugLoad(&plug, plugName);
+        if (ret < 0) {
+            LOGE("load '%s' FAIL, err=%d, ignore\n", plugName, ret);
+            continue;
+        }
+
+        ret = (int)AicAddStrmUser(plug->userItf, NULL);
+        if (!ret) {
+            LOGE("add '%s' strmUser to aic FAIL\n", plugName);
+            ExtPlugUnload(plug);
+            continue;
+        }
+
+        list_add(&plug->lnode, &app->extList);
+        LOGI("MAIN: load '%s' done\n", plugName);
+    }
+}
+
+/**
+    去初始化VO plugs并卸载它.
+*/
+static void VosExit(TheApp* app)
+{
+    struct list_head *pos = NULL;
+    struct list_head *next = NULL;
+    list_for_each_safe(pos, next, &app->extList) {
+        ExtPlugLib *plug = list_entry(pos, ExtPlugLib, lnode);
+        list_del_init(&plug->lnode);
+
+        if (!AicDelStrmUser(plug->userItf, NULL)) {
+            LOGE("del strmUser from aic FAIL\n");
+        }
+        ExtPlugUnload(plug);
+    }
+}
+
+/**
+    app init.
+*/
+int AppInit(TheApp* app)
+{
+    int ret;
+
+    // system
+    HiGlbLockInit();
+    cJSON_Hooks cjsonHooks = {
+        .malloc_fn = malloc,
+        .free_fn = free
+    };
+    cJSON_InitHooks(&cjsonHooks);
+    AppBaseInit(APP_CFG_FILE);
+
+    // sdk
+    ret = HI_UNF_CIPHER_Init();
+    HI_ASSERT(ret == HI_SUCCESS);
+    MppInit();
+    ret = OsdLibInit();
+    HI_ASSERT(ret == HI_SUCCESS);
+
+    ret = HttpdInit(0);
+    HI_ASSERT(ret == 0);
+
+    AicInit();
+
+    // uvc aic agent
+    uvc_create(&app->uvcDev, NULL, UVC_CFG_SEC);
+    if (app->uvcDev) {
+        UvcAgentCreate(&app->uvcAgent, app->uvcDev);
+    }
+
+    // httpd aic agent
+    HttpdAicInit();
+
+    // histm aic agent
+#ifdef CFG_HISTM
+    ret = StmAicInit();
+#endif
+    HI_EXP_LOGE(ret < 0, "StmAicInit() FAIL, ret=%d\n", ret);
+    StmCmdInit(app);
+
+    // stream file saver
+    app->strmSaver = NULL;
+    if (GetCfgBool("strm_saver:enable", false)) {
+        StrmSaverCreate(&app->strmSaver,
+            GetCfgInt("strm_saver:que_size", SAVER_QUE_SIZE),
+            GetCfgInt("strm_saver:frm_per_file", SAVER_FRM_PER_FILE),
+            GetCfgStr("strm_saver:file_prefix", SAVER_FILE_PFX));
+    }
+    // vo plus
+    VosInit(app);
+
+    // 设置stdin为异步模式，并监听之
+    app->stdinFlags = fcntl(STDIN_FILENO, F_GETFL, 0);
+    if (app->stdinFlags < 0 || fcntl(STDIN_FILENO, F_SETFL,
+        (uint32_t)app->stdinFlags | O_NONBLOCK) < 0) {
+        LOGE("set O_NONBLOCK for stdin FAIL, '%s'\n", strerror(errno));
+        app->stdinFlags = -1;
+    } else {
+        EmAddFd(MainEvtMon(), STDIN_FILENO, FDE_IN, OnStdin, NULL);
+    }
+
+    // for tcp speed test
+    app->tcpSvr1 = TcpSvrCreate(TCP_SVR1_PORT, 0, true, -1);
+    HI_ASSERT(app->tcpSvr1 >= 0);
+    app->tcpSvr2 = TcpSvrCreate(TCP_SVR2_PORT, 0, true, -1);
+    HI_ASSERT(app->tcpSvr2 >= 0);
+    EmAddFd(MainEvtMon(), app->tcpSvr1, FDE_IN, OnTcpSvr1, NULL);
+    EmAddFd(MainEvtMon(), app->tcpSvr2, FDE_IN, OnTcpSvr2, &app->tcpMrx);
+    return 0;
+}
+
+/**
+    app exit.
+*/
+int AppExit(TheApp* app)
+{
+    int ret;
+
+    // 启动watchdog,退出处理无法完成时，将exit进程
+    StartAppWd(-1);
+
+    // for tcp speed test
+    if (app->tcpSvr1 >= 0) {
+        EmDelFd(MainEvtMon(), app->tcpSvr1);
+        close(app->tcpSvr1);
+    }
+    if (app->tcpSvr2) {
+        EmDelFd(MainEvtMon(), app->tcpSvr2);
+        close(app->tcpSvr2);
+    }
+
+    // 恢复stdin flags，否则可能会导致vi等程序故障
+    if (app->stdinFlags >= 0) {
+        ret = fcntl(STDIN_FILENO, F_SETFL, app->stdinFlags);
+        HI_EXP_LOGE(ret < 0, "recover flags for stdin FAIL, '%s'\n", strerror(errno));
+        EmDelFd(MainEvtMon(), STDIN_FILENO);
+    }
+
+    // vo plugs
+    VosExit(app);
+    // stream file saver
+    if (app->strmSaver) {
+        StrmSaverDestroy(app->strmSaver);
+    }
+
+    // histm aic agent, 即便init失败，也要exit，且不会出错
+#   ifdef CFG_HISTM
+    ret = StmAicExit();
+#   endif
+    StmCmdExit(app);
+
+    // httpd aic agent
+    HttpdAicExit();
+
+    if (app->uvcAgent) {
+        UvcAgentDestroy(app->uvcAgent);
+    }
+    if (app->uvcDev) {
+        uvc_destroy(app->uvcDev);
+    }
+
+    AicExit();
+
+    // httpd
+    ret = HttpdExit();
+    HI_ASSERT(!ret);
+
+    // system
+    OsdLibExit();
+    MppSysExit();
+    HI_UNF_CIPHER_DeInit();
+    AppBaseExit();
+    HiGlbLockExit();
+    return 0;
+}
+
+/**
+    app entry.
+*/
+int main(int argc, char *argv[])
+{
+    TheApp app = {
+        .uvcDev = NULL,
+        .uvcAgent = NULL,
+        .strmSaver = NULL,
+        .stdinFlags = 0,
+        .tcpSvr1 = -1,
+        .tcpSvr2 = -1
+    };
+    INIT_LIST_HEAD(&app.extList);
+
+    // 确保进程只有唯一实例
+    if (ProcTryLock(APP_PID_FILE, NULL) != 0) {
+        LOGI("hiopenais is running, quit.\n");
+        return 98; // 错误码98
+    }
+
+    // 初始化过程较为耗时，需要先忽略终止信号
+    signal(SIGINT, SIG_IGN);
+    signal(SIGTERM, SIG_IGN);
+
+    // 重置驱动为支持RNDIS+UVC
+    LOGI("@@@ RNDIS_ONLY => RNDIS_UVC ...\n");
+    system("/komod/load_rndis_uvc.sh");
+    LOGI("@@@ RNDIS_ONLY => RNDIS_UVC done\n\n");
+
+    LOGI("*** HiOpenAIS %s ***\n", APP_VER);
+    LOGI("MAIN: app init ...\n");
+    AppInit(&app);
+
+    if (GetCfgBool("app:pre_start_vio", false)) {
+        AicStartVi(AIC_VIT_SENSOR, false, AICSTART_VI_OUTWIDTH, AICSTART_VI_OUTHEIGHT, -1);
+        AicStartVo(AIC_VOT_RTSPD, AICSTART_VO_OUTWIDTH, AICSTART_VO_OUTHEIGHT, PT_H264);
+    }
+
+    // main loop
+    LOGI("MAIN: app run ...\n");
+    signal(SIGINT, SigProc);
+    signal(SIGTERM, SigProc);
+    EmRun(MainEvtMon());
+    signal(SIGINT, SIG_IGN);
+    signal(SIGTERM, SIG_IGN);
+
+    if (GetCfgBool("app:pre_start_vio", false)) {
+        AicStopVo(AIC_VOT_RTSPD);
+        AicStopVi(AIC_VIT_SENSOR, false);
+    }
+
+    LOGI("MAIN: app exit ...\n");
+    AppExit(&app);
+    LOGI("MAIN: app end\n");
+    fflush(stdout);
+
+    // 重置驱动为只支持RNDIS
+    LOGI("\n@@@ RNDIS+UVC => RNDIS_ONLY ...\n");
+    system("/komod/load_rndis_only.sh");
+    LOGI("@@@ RNDIS_UVC => RNDIS_ONLY done\n");
+    return 0;
+}
+
diff -urpBN hiopenais/src/hiopenais/histm_aic.c hiopenais_modify/src/hiopenais/histm_aic.c
--- hiopenais/src/hiopenais/histm_aic.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hiopenais/histm_aic.c	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,375 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <signal.h>
+#include <stdint.h>
+#include <termios.h>
+#include <sys/time.h>
+#include <linux/limits.h>
+
+#include "hi_app_base.h"
+#include "aic_mng.h"
+#include "http_hdrs.h"
+#include "hi_stm_server.h"
+
+#include "histm_aic.h"
+
+/**
+    @mainpage
+
+    # 服务标识
+
+    histm用服务名称用plug uuid来标识。
+
+    # 回调线程转发
+
+    histm回调由histm服务线程调用，为简化线程模型，用channel来实现线程转发。
+    在回调中，将参数打包为事件，通过channel发送给主线程，有主线程来执行实际的处理。
+
+    按目前的使用定义，histm回调频率不高，对性能不敏感，暂时用HttpHdrs来打包参数，
+    其本质是map<string, string>。
+*/
+#ifndef API_DESC_PAD
+#define API_DESC_PAD
+#endif
+
+#define DEV_TYPE_DEF    "HiOpenaisCamera" // 默认设备类型
+
+/**
+    StmEvt处理函数类型.
+*/
+typedef void (*StmEvtProc)(HttpHdrs* params);
+
+/**
+    打包HiSTM事件回调的结构体.
+*/
+typedef struct StmEvt {
+    StmEvtProc proc; // 事件处理函数
+    HttpHdrs *params; // 事件参数
+}   StmEvt;
+
+/**
+    histm aic datas.
+*/
+static SkPair g_stmEvtChn = {
+    .in = -1,
+    .out = -1
+}; // 接收StmEvt的channel
+
+/**
+    stmEvtChn有事件到达.
+    此函数由主线程执行，histm回调最终在这里实现线程切换。
+*/
+static void OnStmEvtChn(void* user, int fd, int evts)
+{
+    EvtChkRet(evts, FDE_IN, fd);
+
+    StmEvt evt;
+    while (FdReadMsg(fd, &evt, sizeof(evt)) == sizeof(evt)) {
+        HI_ASSERT(evt.proc && evt.params);
+        evt.proc(evt.params);
+    }
+}
+
+/**
+    提供给AicMng的用于发送AI计算结果的回调函数.
+
+    此函数以异步方式(timeout=0)发送数据。虽然底层流控时，发送会失败，但这是可以的。
+    底层流控意味着网络故障，或待发送数据过多，且发送结果数据并不要求可靠。
+*/
+static void OnStmAiRes(void* user,
+    uintptr_t cltId, const char* plugUuid, const char* resJson, int resLen)
+{
+    uint32_t sentLen;
+    int ret;
+
+    ret = HI_STM_SendDataToClient(plugUuid, resJson, resLen, &sentLen, 0);
+    HI_EXP_LOGW(ret < 0, "HI_STM_SendDataToClient() FAIL, ret=%d\n", ret);
+}
+
+/**
+    在主线程中处理服务订阅/去订阅事件.
+*/
+static void StmSubsProc(HttpHdrs* params)
+{
+    uintptr_t cltId;
+    HI_STM_OPERATOR_E op;
+    const char *plugUuid = NULL;
+    const char *val = NULL;
+    int ret;
+
+    val = HttpHdrsFind(params, "cltId", NULL);
+    HI_ASSERT(val);
+    cltId = (uintptr_t)atoll(val);
+    val = HttpHdrsFind(params, "op", NULL);
+    HI_ASSERT(val);
+    op = atoi(val);
+    plugUuid = HttpHdrsFind(params, "serviceName", NULL);
+    HI_ASSERT(plugUuid && *plugUuid);
+
+    if (op == HI_STM_OPERATOR_SUBSCRIBE) {
+        ret = AicSubsAiSvc(cltId, plugUuid, OnStmAiRes, NULL);
+        HI_EXP_LOGE(ret < 0, "AicSubsAiSvc() FAIL, ret=%d\n", ret);
+    } else if (op == HI_STM_OPERATOR_UNSUBSCRIBE) {
+        ret = AicUnsubsAiSvc(cltId, plugUuid);
+        HI_EXP_LOGE(ret < 0, "AicUnsubsAiSvc() FAIL, ret=%d\n", ret);
+    } else { // 打包StmEvt时已经做了校验，不可能走到这个分支
+        HI_ASSERT(0);
+    }
+}
+
+/**
+    在主线程中处理OnCommand事件.
+*/
+static void StmCmdProc(HttpHdrs* params)
+{
+    const char *cmd = NULL;
+    const char *param = NULL;
+
+    cmd = HttpHdrsFind(params, "cmd", NULL);
+    HI_ASSERT(cmd);
+    param = HttpHdrsFind(params, "param", NULL); // param可为NULL
+    LOGI("STM-AIC: on cmd, cmd='%s', param='%s'\n", cmd, (param ? param : ""));
+}
+
+/**
+    在主线程中处理OnData事件.
+*/
+static void StmDataProc(HttpHdrs* params)
+{
+    uint32_t cltId;
+    const char *data = NULL;
+    const char *val = NULL;
+
+    val = HttpHdrsFind(params, "cltId", NULL);
+    HI_ASSERT(val);
+    cltId = (uint32_t)atol(val);
+    data = HttpHdrsFind(params, "data", NULL);
+    HI_ASSERT(data); // 不能hi_assert(data[0]), 因其可能是binary，data[0]可能为0
+
+    LOGI("STM-AIC: on data, cltId=%ud, dataLen=%d\n", cltId, strlen(data));
+}
+
+/**
+    收到服务订阅/去订阅OnEventNotify事件.
+*/
+static void OnStmSubs(const HI_U32 clientID,
+    HI_STM_OPERATOR_E op, HI_STM_SUBSCRIBE_SERVICE_S service)
+{
+    if (op != HI_STM_OPERATOR_SUBSCRIBE && op != HI_STM_OPERATOR_UNSUBSCRIBE) {
+        LOGE("unknown op %d\n", op);
+        return;
+    }
+    if (!service.serviceName[0]) {
+        LOGE("serviceName must not be NULL\n");
+        return;
+    }
+
+    HttpHdrs *params = HttpHdrsNew(0);
+    char val[INT_STR_BUF_SIZE];
+    int len;
+
+    len = snprintf_s(val, sizeof(val), sizeof(val) - 1, "%u", clientID);
+    HttpHdrsAdd(params, "cltId", -1, val, len);
+    len = snprintf_s(val, sizeof(val), sizeof(val) - 1, "%d", (int)op);
+    HttpHdrsAdd(params, "op", -1, val, len);
+    HttpHdrsAdd(params, "serviceName", -1, service.serviceName, -1);
+    len = snprintf_s(val, sizeof(val), sizeof(val) - 1, "%d", (int)service.dataSource);
+    HttpHdrsAdd(params, "dataSource", -1, val, len);
+    len = snprintf_s(val, sizeof(val), sizeof(val) - 1, "%d", (int)service.transport);
+    HttpHdrsAdd(params, "transport", -1, val, len);
+
+    StmEvt evt = {
+        .proc = StmSubsProc,
+        .params = params
+    };
+    bool ret = SkPairValid(&g_stmEvtChn);
+    HI_ASSERT(ret);
+    if (FdWriteMsg(g_stmEvtChn.out, &evt, sizeof(evt)) != sizeof(evt)) {
+        LOGE("post OnEventNotify StmEvt to chn FAIL");
+        HttpHdrsDelete(params);
+    }
+}
+
+/**
+    收到OnCommand事件.
+*/
+static void OnStmCmd(const HI_CHAR *cmd, const HI_CHAR *param)
+{
+    if (!cmd || !*cmd) {
+        LOGE("cmd must not be NULL\n");
+        return;
+    }
+
+    HttpHdrs *params = HttpHdrsNew(0);
+
+    HttpHdrsAdd(params, "cmd", -1, cmd, -1);
+    if (param && *param) {
+        HttpHdrsAdd(params, "param", -1, param, -1);
+    }
+
+    StmEvt evt = {
+        .proc = StmCmdProc,
+        .params = params
+    };
+    bool ret = SkPairValid(&g_stmEvtChn);
+    HI_ASSERT(ret);
+    if (FdWriteMsg(g_stmEvtChn.out, &evt, sizeof(evt)) != sizeof(evt)) {
+        LOGE("post OnCommand StmEvt to chn FAIL");
+        HttpHdrsDelete(params);
+    }
+}
+
+/**
+    收到OnData事件.
+
+    NOTE: 目前视data为string类型。但data理论上可以用binaray。将来若定义data为binary时，
+    需要修改此实现。可选2种修改方案，取决于性能需求，
+    A.  用base64来编码data为string，用于性能不敏感的场景。
+    B.  另外创建channel来传输data，用于性能敏感的场景。
+*/
+static void OnStmData(const HI_U32 clientID, const HI_CHAR *buffer, HI_U32 bufferLen)
+{
+    if (!buffer || !bufferLen) {
+        LOGE("data must not be NULL\n");
+        return;
+    }
+
+    HttpHdrs *params = HttpHdrsNew(0);
+    char val[INT_STR_BUF_SIZE];
+    int len;
+
+    len = snprintf_s(val, sizeof(val), sizeof(val) - 1, "%u", clientID);
+    HttpHdrsAdd(params, "cltId", -1, val, len);
+    HttpHdrsAdd(params, "data", -1, buffer, (int)bufferLen);
+
+    StmEvt evt = {
+        .proc = StmDataProc,
+        .params = params
+    };
+    bool ret = SkPairValid(&g_stmEvtChn);
+    HI_ASSERT(ret);
+    if (FdWriteMsg(g_stmEvtChn.out, &evt, sizeof(evt)) != sizeof(evt)) {
+        LOGE("post OnData StmEvt to chn FAIL");
+        HttpHdrsDelete(params);
+    }
+}
+
+/**
+    初始化.
+    需要列表AicMng中已加载的plug，以其为基础填充histm devInfo.
+*/
+int StmAicInit(void)
+{
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    const char *devType = GetCfgStr("dev_info:dev_name", DEV_TYPE_DEF);
+    HI_STM_DEVICE_INFO_S devInfo;
+    struct list_head plugInfos;
+    int svcNum = 0;
+    int ret;
+
+    // init g_stmEvtChn
+    res = SkPairValid(&g_stmEvtChn);
+    HI_ASSERT(!res);
+    ret = SkPairCreate(&g_stmEvtChn);
+    HI_ASSERT(ret >= 0);
+    if (EmAddFd(MainEvtMon(), g_stmEvtChn.in, FDE_IN, OnStmEvtChn, NULL) < 0) {
+        HI_ASSERT(0);
+    }
+
+    // init histm server
+    ret = HI_STM_InitServer(devType);
+    HI_EXP_GOTO(ret < 0, END, "HI_STM_InitServer() FAIL, ret=%d\n", ret);
+
+    // list working plugs
+    INIT_LIST_HEAD(&plugInfos);
+    ret = AicListWorkPlugs(&plugInfos);
+    HI_EXP_GOTO(ret < 0, END, "AicListWorkPlugs() FAIL, ret=%d\n", ret);
+
+    // 填充devInfo ...
+    if (memset_s(&devInfo, sizeof(devInfo), 0, sizeof(devInfo)) != EOK) {
+        HI_ASSERT(0);
+    }
+    HiStrxfrm(devInfo.devServiceType, devType, sizeof(devInfo.devServiceType));
+
+    // 填充service，视每一个working plug为一个服务，其uuid为servie name
+    while (!list_empty(&plugInfos)) {
+        AiPlugInfo *plug = list_entry(plugInfos.next, AiPlugInfo, lnode);
+
+        if (svcNum < HI_ARRAY_SIZE(devInfo.services)) {
+            devInfo.services[svcNum].outDataLen = 0; // HiSTM保留字段
+            devInfo.services[svcNum].transport = HI_STM_TRANSPORT_TCP; // HiSTM默认值
+            HiStrxfrm(devInfo.services[svcNum].serviceName, plug->uuid,
+                sizeof(devInfo.services[svcNum].serviceName));
+            svcNum++;
+        } else {
+            LOGE("too many working plugs, discard '%s'\n", plug->uuid);
+        }
+
+        list_del(plugInfos.next);
+        AiPlugInfoDelete(plug);
+    }
+
+    if (svcNum == 0) {
+        LOGW("no svc registered\n");
+        return 0;
+    }
+
+    devInfo.serviceNum = svcNum;
+    devInfo.observer.OnCommand = OnStmCmd;
+    devInfo.observer.OnData = OnStmData;
+    devInfo.observer.OnEventNotify = OnStmSubs;
+    ret = HI_STM_RegisterAiDevInfo(&devInfo);
+    HI_CHK_GOTO(ret, END, "HI_STM_RegisterAiDevInfo() FAIL, ret=%d\n", ret);
+    ret = 0;
+
+    END:
+        return ret;
+}
+
+/**
+    去初始化.
+*/
+int StmAicExit(void)
+{
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    int ret;
+
+    ret = HI_STM_DeInitServer();
+    HI_EXP_LOGE(ret, "HI_STM_DeInitServer() FAIL, ret=%d\n", ret);
+
+    // clean g_stmEvtChn ...
+    if (SkPairValid(&g_stmEvtChn)) {
+        if (EmDelFd(MainEvtMon(), g_stmEvtChn.in) < 0) {
+            HI_ASSERT(0);
+        }
+        // 清空stmEvtChn中未被处理的消息
+        StmEvt evt;
+        while (FdReadMsg(g_stmEvtChn.in, &evt, sizeof(evt)) == sizeof(evt)) {
+            HI_ASSERT(evt.params);
+            HttpHdrsDelete(evt.params);
+        }
+        SkPairDestroy(&g_stmEvtChn);
+    }
+    return 0;
+}
+
diff -urpBN hiopenais/src/hiopenais/histm_aic.h hiopenais_modify/src/hiopenais/histm_aic.h
--- hiopenais/src/hiopenais/histm_aic.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hiopenais/histm_aic.h	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HI_STM_AIC_H
+#define HI_STM_AIC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    濮.
+    姝ゅ瑕濮AicMng
+*/
+int StmAicInit(void);
+
+/**
+    诲濮.
+    诲濮藉诲濮AicMng
+*/
+int StmAicExit(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // HI_STM_AIC_H
diff -urpBN hiopenais/src/hiopenais/httpd_aic.c hiopenais_modify/src/hiopenais/httpd_aic.c
--- hiopenais/src/hiopenais/httpd_aic.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hiopenais/httpd_aic.c	2021-03-29 20:57:16.000000000 -0700
@@ -0,0 +1,1005 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <signal.h>
+#include <stdint.h>
+#include <termios.h>
+#include <sys/time.h>
+#include <linux/limits.h>
+
+#include "hi_app_base.h"
+#include "inet_test_util.h"
+#include "strm_msg_sk.h"
+#include "cjson_help.h"
+#include "lite_httpd.h"
+#include "aic_mng.h"
+#include "mpp_sess.h"
+
+#include "httpd_aic.h"
+
+/**
+    HTTP interface URLs.
+*/
+#define URL_SSE_EVT         "/aic/sse_evt"
+#define URL_GET_INFO        "/aic/get_info"
+#define URL_GET_STATUS      "/aic/get_status"
+#define URL_START_VI        "/aic/start_vi"
+#define URL_STOP_VI         "/aic/stop_vi"
+#define URL_START_VO        "/aic/start_vo"
+#define URL_STOP_VO         "/aic/stop_vo"
+#define URL_STOP_VIOS       "/aic/stop_vios"
+#define URL_SET_AI_PLUG     "/aic/set_ai_plug"
+#define URL_LIST_AI_PLUG    "/aic/list_ai_plug"
+#define URL_POST_PIC        "/aic/post_pic"
+#define URL_POST_MODEL      "/aic/post_model"
+#define URL_UPDATE_SOFT     "/aic/update_soft"
+
+/**
+    StrmMsg server port.
+*/
+#define STRM_SVR_PORT       8601 // StrmMsgSk TCP server port
+#define STRM_SVRS_PORT      8602 // StrmMsgSk sec TCP server port
+
+/**
+    update software甯搁.
+*/
+#define UPDATE_SOFT_DIR     "/update" // 瀛惧绾у褰
+#define UPDATE_SOFT_EXT     ".tar.gz" // 绾у浠跺缂
+#define UPDATE_SOFT_INFO    UPDATE_SOFT_DIR "/update.info" // 绾у淇℃浠
+#define UPDATE_WAIT_TIME    1000 // ユ跺绛寰堕达朵娇
+
+/**
+    浜浠剁稿冲父.
+*/
+#define ENAME_AI_RES        "aiRes" // AI璁＄缁浜浠跺
+
+/**
+    朵甯搁.
+*/
+#define ERR_RSP_BODY        "{ \"ret\": -1 }" // 璇搴body
+
+/**
+    SseNode.
+*/
+typedef struct SseNode {
+    struct list_head lnode;
+    SseReq *sse;
+}   SseNode;
+
+/**
+    httpd aic.
+*/
+typedef struct HttpAic {
+    SkPair httpEvtChn; // ユHttpdEvtchannel
+    int svcThrdNum; // 姝ｅㄨ琛版＄嚎绋扮
+    HttpReq *postPicReq; // 姝ｅㄦュhost post pic璇锋
+    int strmTcpSvr; // StrmMsgSkTCP server fd
+    StrmMsgSk *strmMsgSk; // 涓host浜やpic, json娑绔
+    struct list_head sseSessList; // SseNode list, 搴挎涓STL std::set
+
+    // aic stream info
+    PAYLOAD_TYPE_E codecType; // stream codec type, PT_BUTT琛ㄧず褰涓stream
+    int width; // stream width, -1琛ㄧず涓纭瀹锛浠ョ
+    int height; // stream height, -1琛ㄧず涓纭瀹锛浠ョ
+}   HttpAic;
+
+/**
+    HttpAicㄥ瀵硅薄.
+*/
+static HttpAic g_haic = {
+    .httpEvtChn = {
+        .in = -1,
+        .out = -1
+    },
+    .svcThrdNum = 0,
+    .postPicReq = NULL,
+    .strmTcpSvr = -1,
+    .strmMsgSk = NULL,
+    .sseSessList = LIST_HEAD_INIT(g_haic.sseSessList),
+
+    .codecType = PT_BUTT,
+    .width = -1,
+    .height = -1,
+};
+
+/**
+    存版ā澶绾跨.
+*/
+static void* PostModelThrd(void *user)
+{
+    HttpReq *req = (HttpReq*)user;
+    const char *rspStatus = "500";
+    char filePath[NORM_BUF_SIZE] = "?";
+    MemBlk *blk = NULL;
+    FILE *file = NULL;
+    int ret;
+    char stFilePath[PATH_MAX] = {0};
+
+    LOGI("HAIC: proc post model ...\n");
+
+    const char* hval = HttpHdrsFind(HttpReqReqHdrs(req), "filename", NULL);
+    HI_EXP_CMD_GOTO(!hval || !*hval, (rspStatus = "500"), END, "on post model without 'filename' hdr\n");
+
+    if (snprintf_s(filePath, sizeof(filePath), sizeof(filePath) - 1, "./plugs/%s", hval) < 0) {
+        HI_ASSERT(0);
+    }
+
+    if (!realpath(filePath, stFilePath)) {
+        LOGE("PostModelThrd filePath (%s) is not exit\n", filePath);
+        HI_ASSERT(0);
+    }
+    LOGI("PostModelThrd standard file path:%s\n", stFilePath);
+
+    file = fopen(stFilePath, "wb");
+    HI_EXP_CMD_GOTO(!file, (rspStatus = "500"), END,
+        "open '%s' for write FAIL, err='%s, %d'\n", stFilePath, strerror(errno), errno);
+
+    // read file blocks and write to fileone by one
+    while ((ret = HttpReqReadBody(req, &blk, false)) > 0) {
+        HI_ASSERT(blk);
+        int res = fwrite(blk->data, 1, blk->len, file);
+        HI_EXP_CMD_GOTO(res != blk->len, (rspStatus = "500"), END,
+            "write '%s' FAIL, err='%s, %d'\n", stFilePath, strerror(errno), errno);
+        MemBlkDelete(blk); // ゆユ锛free锛叉浣跨ㄥ凡缁剧璧婧
+    }
+    HI_EXP_CMD_GOTO(ret < 0, (rspStatus = "500"), END, "HttpReqReadBody FAIL, ret=%d\n", ret);
+    rspStatus = "200";
+
+    END:
+        HttpReqSimpleRsp(req, rspStatus);
+        HttpReqDelRef(req);
+        if (file) {
+            fclose(file);
+        }
+        LOGI("HAIC: proc post model done, name='%s', res='%s'\n", stFilePath, rspStatus);
+        __sync_sub_and_fetch(&g_haic.svcThrdNum, 1);
+        return NULL;
+}
+
+/**
+    绾ц蒋浠跺绾跨.
+*/
+static void* UpdateSoftThrd(void *user)
+{
+    HttpReq *req = (HttpReq*)user;
+    const char *rspStatus = "500";
+    char filePath[PATH_MAX] = "?";
+    FILE *infoFile = NULL; // update info file
+    int res;
+
+    LOGI("HAIC: proc update soft ...\n");
+
+    const char* fileName = HttpHdrsFind(HttpReqReqHdrs(req), "filename", NULL);
+    HI_EXP_CMD_GOTO((!fileName || !*fileName), (rspStatus = "500"), END,
+        "update soft without 'filename' hdr\n");
+
+    // ゆ浠跺缂涓".tar.gz"锛浠杩绉煎
+    int nameLen = strlen(fileName);
+    int extLen = strlen(UPDATE_SOFT_EXT);
+    if (nameLen <= extLen || strcmp(&fileName[nameLen - extLen], UPDATE_SOFT_EXT) != 0) {
+        LOGE("update soft FAIL, for '%s' not ext by '%s'\n", fileName, UPDATE_SOFT_EXT);
+        rspStatus = "500";
+        goto END;
+    }
+
+    // 瑕跺寤虹褰
+    res = MkdirIfNeed(UPDATE_SOFT_DIR, true);
+    HI_EXP_CMD_GOTO(res < 0, (rspStatus = "500"), END, "mkdir '%s' FAIL\n", UPDATE_SOFT_EXT);
+
+    // ユ跺苟淇瀛浠
+    if (snprintf_s(filePath, sizeof(filePath), sizeof(filePath) - 1, "%s/%s", UPDATE_SOFT_DIR, fileName) < 0) {
+        HI_ASSERT(0);
+    }
+    res = HttpdPutFile(req, filePath, false);
+    HI_EXP_CMD_GOTO(res < 0, (rspStatus = "500"), END, "get-save file FAIL, ret=%d\n", res);
+
+    // 灏浠跺娣诲update淇℃浠朵腑
+    infoFile = fopen(UPDATE_SOFT_INFO, "wb");
+    HI_EXP_CMD_GOTO(!infoFile, (rspStatus = "500"), END,
+        "open '%s' for 'wb' FAIL, err='%s, %d'\n", filePath, strerror(errno), errno);
+    res = fprintf(infoFile, "%s\n", filePath); // 存ョㄨ矾寰
+    HI_EXP_CMD_GOTO(res < 0, (rspStatus = "500"), END,
+        "write '%s' FAIL, err='%s, %d'\n", filePath, strerror(errno), errno);
+    rspStatus = "200";
+
+    END:
+        HttpReqSimpleRsp(req, rspStatus);
+        HttpReqDelRef(req);
+
+        if (infoFile) {
+            fclose(infoFile);
+        }
+        if (strcmp(rspStatus, "200") != 0) { // FAIL
+            LOGW("remove '%s' for proc FAIL\n", filePath);
+            remove(filePath); // 藉け璐
+        }
+
+        LOGI("HAIC: proc update soft done, name='%s', rsp='%s'\n", filePath, rspStatus);
+        __sync_sub_and_fetch(&g_haic.svcThrdNum, 1);
+
+        // ユ锛璇锋绯荤
+        if (strcmp(rspStatus, "200") == 0) { // OK
+            usleep(UPDATE_WAIT_TIME * HI_USLEEP_MS);
+            RebootSystem(-1);
+        }
+        return NULL;
+}
+
+/**
+    璁剧疆浠跺绾跨.
+*/
+static void* SetAiPlugThrd(void* param)
+{
+    RapiReq *req = (HttpReq*)param;
+    const char *inData = NULL;
+    int inLen;
+    cJSON *json = NULL;
+    const char *uuid = NULL;
+    AiPlugLib plug;
+
+    inData = RapiReqInData(req, &inLen);
+    HI_EXP_GOTO(!inData, END, "set_ai_plug without req-body\n");
+    LOGI("HAIC: on set_ai_plug, reqLen=%d, reqData=\n", inLen);
+    DOLOGI(HiDumpTxt(inData, inLen));
+
+    json = cJSON_Parse(inData);
+    HI_EXP_GOTO(!json, END, "OnSetAiPlug FAIL, for JSON parse FAIL\n");
+    uuid = JsonStr(json, "uuid", "");
+
+    LOGI("HAIC: call AicSetAiPlug(%s) ...\n", (*uuid ? uuid : "null"));
+    AicSetAiPlug(uuid, &plug, false);
+
+    END:
+        if (json) {
+            cJSON_Delete(json);
+        }
+        RapiReqReply(req, ERR_RSP_BODY, sizeof(ERR_RSP_BODY) - 1);
+        HttpReqDelRef(req);
+
+        if (__sync_sub_and_fetch(&g_haic.svcThrdNum, 1) < 0) {
+            HI_ASSERT(0);
+        }
+        return NULL;
+}
+
+/**
+    抽sse骞朵list涓.
+*/
+static void CloseSseNode(SseNode* node, bool closeSse)
+{
+    EmDelFd(MainEvtMon(), HttpReqCloseFd(node->sse));
+    list_del(&node->lnode);
+
+    AicUnsubsAiSvc((uintptr_t)node, NULL);
+    AicUnsubsEvt((uintptr_t)node, NULL);
+
+    if (closeSse) {
+        SseReqClose(node->sse, 0);
+    }
+    HttpReqDelRef(node->sse);
+
+    free(node);
+}
+
+/**
+    AIC缁姝stream.
+*/
+static void OnStrmOff(void* user)
+{
+    LOGI("HAIC: on strm off\n");
+    HttpAic *self = (HttpAic*)user;
+    HI_ASSERT(self == &g_haic);
+
+    self->codecType = PT_BUTT;
+    self->width = -1;
+    self->height = -1;
+}
+
+/**
+    AICstream.
+*/
+static bool OnStrmOn(void* user, int vencChn, PAYLOAD_TYPE_E codecType, int width, int height)
+{
+    LOGI("HAIC: on strm on, codec=%d, width=%d, height=%d\n", codecType, width, height);
+    HttpAic *self = (HttpAic*)user;
+    HI_ASSERT(self == &g_haic);
+
+    if (self->codecType != PT_BUTT) {
+        LOGW("onStrmOn without onStrmOff before\n");
+        OnStrmOff(user);
+    }
+
+    self->codecType = codecType;
+    self->width = width;
+    self->height = height;
+    return (codecType == PT_JPEG || codecType == PT_MJPEG) ? true : false;
+}
+
+/**
+    跺AIC浜ょframe.
+*/
+static void OnVencFrm(void* user, VencFrm* frm)
+{
+    HI_ASSERT(frm);
+    HttpAic *self = (HttpAic*)user;
+    HI_ASSERT(self == &g_haic);
+
+    if (!self->strmMsgSk) {
+        LOGW("tx pic discard, for no strm sk\n");
+        return;
+    }
+
+    // 骞抽㈠frame
+    MemBlk *pic = VencFrmToMblk(&frm->strm, NULL, sizeof(uint32_t));
+    if (!pic) {
+        return;
+    }
+
+    // 娣诲娑垮害header
+    HI_ASSERT(pic->offset >= sizeof(uint32_t));
+    pic->offset -= sizeof(uint32_t);
+    HiPutBe32(pic->size - pic->offset, &pic->data[pic->offset]);
+
+    int ret = SmsSend(self->strmMsgSk, pic);
+    if (ret != 1) {
+        MemBlkDelete(pic);
+    }
+}
+
+/**
+    瀹扮IAicStrmUserュ.
+*/
+static const IAicStrmUser G_HAIC_STRM_USER = {
+    .OnStrmOn = OnStrmOn,
+    .OnStrmOff = OnStrmOff,
+    .OnVencFrm = OnVencFrm,
+    .OnVideoFrm = NULL,
+};
+
+/**
+    堕post pic版.
+*/
+static void OnPostPicRead(void* user, int fd, uint32_t evts)
+{
+    HI_ASSERT(g_haic.postPicReq);
+    int ret;
+    ret = HttpReqReadFd(g_haic.postPicReq);
+    HI_ASSERT(fd == ret);
+    EvtChkRet(evts, FDE_IN, fd);
+    MemBlk *data = NULL;
+
+    EmDelFd(MainEvtMon(), fd);
+
+    ret = HttpReqReadBody(g_haic.postPicReq, &data, true);
+    if (ret <= 0) { // 璇锋琚瀵圭close/reset
+        LOGW("read PIC POST FAIL, ret=%d\n", ret);
+        HttpReqDelRef(g_haic.postPicReq);
+        g_haic.postPicReq = NULL;
+        return;
+    }
+    int res = HttpReqReqBodyEmpty(g_haic.postPicReq);
+    HI_ASSERT(res);
+
+    // 澶client锛澶剧
+    HttpReqSimpleRsp(g_haic.postPicReq, ret > 0 ? "200" : "500");
+    HttpReqDelRef(g_haic.postPicReq);
+    g_haic.postPicReq = NULL;
+
+    AicSubmitJpg(data->data, data->len, false);
+    MemBlkDelete(data);
+}
+
+/**
+    AIC浜浠跺.
+    绠瀹颁负SseSess浜浠.
+*/
+static void OnAicEvt(void* user, uint32_t cltId, const char* evtName, const char* evtJson, int evtLen)
+{
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    SseNode *node = (SseNode*)user;
+    HI_ASSERT((uintptr_t)node == cltId);
+
+    // 存ラ浼evtJson
+    int ret = SseReqPush(node->sse, -1, evtName, evtJson, evtLen);
+    HI_EXP_LOGE(ret < 0, "sse push aic evt FAIL, ret=%d\n", ret);
+}
+
+/**
+    AI璁＄缁浜浠跺.
+    绠瀹颁负SseSess浜浠.
+*/
+static void OnAiRes(void* user, uintptr_t cltId, const char* plugUuid, const char* resJson, int resLen)
+{
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    SseNode *node = (SseNode*)user;
+    HI_ASSERT((uintptr_t)node == cltId);
+
+    int size = resLen + strlen(plugUuid) + NORM_BUF_SIZE;
+    char *buf = (char*)malloc(size);
+    HI_ASSERT(buf);
+
+    // 灏resJson版村ぇjson涓
+    int len = snprintf_s(buf, size, size - 1, "{ \"plugUuid\": \"%s\", \"aiRes\": %s }", plugUuid, resJson);
+    HI_ASSERT(len > 0);
+
+    HI_ASSERT(node->sse);
+    int ret = SseReqPush(node->sse, -1, ENAME_AI_RES, buf, len);
+    free(buf);
+    HI_EXP_LOGE(ret < 0, "sse push ai res FAIL, ret=%d\n", ret);
+}
+
+/**
+    瑙sse closed.
+*/
+static void OnSseDisc(void* user, int fd, uint32_t evts)
+{
+    LOGI("HAIC: on sse disc ...\n");
+    SseNode *node = (SseNode*)user;
+    HI_ASSERT(node);
+    int ret = HttpReqCloseFd(node->sse);
+    HI_ASSERT(ret == fd);
+    EvtChkRet(evts, FDE_IN, fd);
+
+    CloseSseNode(node, false);
+}
+
+/**
+    跺clientsse create璇锋.
+*/
+static int OnSseConn(void* user, SseReq* req)
+{
+    LOGI("HAIC: on sse conn ...\n");
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    int ret;
+
+    ret = SseReqReply(req, 0);
+    if (ret < 0) {
+        LOGE("sse reply FAIL, ret=%d\n", ret);
+        HttpReqDelRef(req);
+        return ret;
+    }
+
+    SseNode *node = (SseNode*)malloc(sizeof(*node));
+    HI_ASSERT(node);
+    INIT_LIST_HEAD(&node->lnode);
+    node->sse = req;
+    list_add_tail(&node->lnode, &g_haic.sseSessList);
+
+    ret = AicSubsAiSvc((uintptr_t)node, NULL, OnAiRes, node);
+    HI_EXP_LOGE(ret < 0, "AicSubsAiSvc FAIL, ret=%d\n", ret);
+
+    ret = AicSubsEvt((uintptr_t)node, NULL, OnAicEvt, node);
+    HI_EXP_LOGE(ret < 0, "AicSubsEvt FAIL, ret=%d\n", ret);
+
+    if (EmAddFd(MainEvtMon(), HttpReqCloseFd(req), FDE_IN, OnSseDisc, node) < 0) {
+        HI_ASSERT(0);
+    }
+    return 0;
+}
+
+/**
+    跺clientget_info璇锋.
+*/
+static int OnGetInfo(void* user, HttpReq* req)
+{
+    int res = IsMainThrd();
+    HI_ASSERT(res);
+    int ret = 0;
+
+    char outBuf[LARGE_BUF_SIZE];
+    int outLen = snprintf_s(outBuf, sizeof(outBuf), sizeof(outBuf) - 1,
+        "{ \"ret\": %d, " "\"info\": { \"appName\": \"%s\", \"appVer\": \"%s\", \"sns0Name\": \"%s\" }" "}",
+        ret, APP_NAME, APP_VER, CurSnsType(0, NULL));
+    RapiReqReply(req, outBuf, outLen);
+    HttpReqDelRef(req);
+    return 0;
+}
+
+/**
+    跺clientget_status璇锋.
+*/
+static int OnGetStatus(void* user, HttpReq* req)
+{
+    LOGI("HAIC: call AicGetStatus() ...\n");
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    MemBlk *reply = MemBlkNew2(HUGE_BUF_SIZE, TINY_BUF_SIZE); // ensure by xiao
+    HI_ASSERT(reply);
+
+    int ret = AicGetStatus(reply);
+    if (ret < 0) {
+        MemBlkDelete(reply);
+        RapiReqReply(req, ERR_RSP_BODY, sizeof(ERR_RSP_BODY) - 1);
+    } else {
+        HI_ASSERT(reply->len > 0);
+        MemBlkPrefixStr(reply, "{ \"ret\": 0, \"status\": ", -1);
+        MemBlkSuffixStr(reply, "\n}", -1);
+        RapiReqReply2(req, reply);
+    }
+
+    HttpReqDelRef(req);
+
+    return 0;
+}
+
+/**
+    跺clientstart_vi璇锋.
+*/
+static int OnStartVi(void* user, RapiReq* req)
+{
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    const char *inData = NULL;
+    int inLen;
+    cJSON *json = NULL;
+    int ret = -1;
+
+    inData = RapiReqInData(req, &inLen);
+    HI_EXP_GOTO(!inData, END, "start_vi without req-body\n");
+    DOLOGI((printf("HAIC: OnStartVi, reqLen=%d, reqData=\n", inLen),
+        HiDumpTxt(inData, inLen)));
+
+    json = cJSON_Parse(inData);
+    HI_EXP_GOTO(!json, END, "parse JSON FAIL\n");
+
+    int viType = JsonInt(json, "viType", -1);
+    int outWidth = JsonInt(json, "outWidth", -1);
+    int outHeight = JsonInt(json, "outHeight", -1);
+    if ((viType < 0 || viType >= AIC_VIT_BUTT) || outWidth <= 0 || outHeight <= 0) {
+        LOGE("param err\n");
+        goto END;
+    }
+
+    LOGI("HAIC: call AicStartVi(%d, true, %d, %d, -1) ...\n", viType, outWidth, outHeight);
+    ret = AicStartVi(viType, true, outWidth, outHeight, -1);
+
+    END:
+        if (json) {
+            cJSON_Delete(json);
+        }
+
+        char outBuf[NORM_BUF_SIZE];
+        int outLen = snprintf_s(outBuf, sizeof(outBuf), sizeof(outBuf) - 1, "{ \"ret\": %d }", ret);
+        RapiReqReply(req, outBuf, outLen);
+        HttpReqDelRef(req);
+        return 0;
+}
+
+/**
+    跺clientstop_vi璇锋.
+*/
+static int OnStopVi(void* user, RapiReq* req)
+{
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    const char *inData = NULL;
+    int inLen;
+    cJSON *json = NULL;
+    int ret = -1;
+
+    inData = RapiReqInData(req, &inLen);
+    HI_EXP_GOTO(!inData, END, "stop_vi without req-body\n");
+    DOLOGI((printf("HAIC: OnStopVi, reqLen=%d, reqData=\n", inLen),
+        HiDumpTxt(inData, inLen)));
+
+    json = cJSON_Parse(inData);
+    HI_EXP_GOTO(!json, END, "parse JSON FAIL\n");
+
+    int viType = JsonInt(json, "viType", -1);
+    if ((viType < 0 || viType >= AIC_VIT_BUTT)) {
+        LOGE("param err\n");
+        goto END;
+    }
+
+    LOGI("HAIC: call AicStopVi(%d) ...\n", viType);
+    ret = AicStopVi(viType, true);
+
+    END:
+        if (json) {
+            cJSON_Delete(json);
+        }
+
+        char outBuf[NORM_BUF_SIZE];
+        int outLen = snprintf_s(outBuf, sizeof(outBuf), sizeof(outBuf) - 1, "{ \"ret\": %d }", ret);
+        RapiReqReply(req, outBuf, outLen);
+        HttpReqDelRef(req);
+        return 0;
+}
+
+/**
+    跺clientstart_vo璇锋.
+*/
+static int OnStartVo(void* user, RapiReq* req)
+{
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    const char *inData = NULL;
+    int inLen;
+    cJSON *json = NULL;
+    int ret = -1;
+
+    inData = RapiReqInData(req, &inLen);
+    HI_EXP_GOTO(!inData, END, "start_vo without req-body\n");
+    DOLOGI((printf("HAIC: OnStopVo, reqLen=%d, reqData=\n", inLen),
+        HiDumpTxt(inData, inLen)));
+
+    json = cJSON_Parse(inData);
+    HI_EXP_GOTO(!json, END, "parse JSON FAIL\n");
+
+    int voType = JsonInt(json, "voType", -1);
+    int outWidth = JsonInt(json, "outWidth", -1);
+    int outHeight = JsonInt(json, "outHeight", -1);
+    // 浠host start/stop type IP
+    if (voType != AIC_VOT_IP || outWidth <= 0 || outHeight <= 0) {
+        LOGE("param err\n");
+        goto END;
+    }
+
+    LOGI("HAIC: call AicStartVo(%d, %d, %d, MJPEG) ...\n", voType, outWidth, outHeight);
+    ret = AicStartVo(voType, outWidth, outHeight, PT_MJPEG);
+    HI_CHK_GOTO(ret, END, "start vo FAIL\n");
+
+    ret = (int)AicAddStrmUser(&G_HAIC_STRM_USER, &g_haic);
+    HI_ASSERT(ret);
+
+    END:
+        if (json) {
+            cJSON_Delete(json);
+        }
+
+        char outBuf[NORM_BUF_SIZE];
+        int outLen = snprintf_s(outBuf, sizeof(outBuf), sizeof(outBuf) - 1, "{ \"ret\": %d }", ret);
+        RapiReqReply(req, outBuf, outLen);
+        HttpReqDelRef(req);
+        return 0;
+}
+
+/**
+    跺clientstop_vo璇锋.
+*/
+static int OnStopVo(void* user, RapiReq* req)
+{
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    const char *inData = NULL;
+    int inLen;
+    cJSON *json = NULL;
+    int ret = -1;
+
+    inData = RapiReqInData(req, &inLen);
+    HI_EXP_GOTO(!inData, END, "stop_vo without req-body\n");
+    DOLOGI((printf("HAIC: OnStopVo, reqLen=%d, reqData=\n", inLen),
+        HiDumpTxt(inData, inLen)));
+
+    json = cJSON_Parse(inData);
+    HI_EXP_GOTO(!json, END, "parse JSON FAIL\n");
+
+    int voType = JsonInt(json, "voType", -1);
+    // 浠host start/stop type IP
+    HI_EXP_GOTO(voType != AIC_VOT_IP, END, "param err\n");
+
+    LOGI("HAIC: call AicStopVo(%d) ...\n", voType);
+    AicDelStrmUser(&G_HAIC_STRM_USER, &g_haic);
+    ret = AicStopVo(voType);
+
+    END:
+        if (json) {
+            cJSON_Delete(json);
+        }
+
+        char outBuf[NORM_BUF_SIZE];
+        int outLen = snprintf_s(outBuf, sizeof(outBuf), sizeof(outBuf) - 1, "{ \"ret\": %d }", ret);
+        RapiReqReply(req, outBuf, outLen);
+        HttpReqDelRef(req);
+        return 0;
+}
+
+/**
+    跺clientstop_vios璇锋.
+*/
+static int OnStopVios(void* user, RapiReq* req)
+{
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    int ret;
+
+    LOGI("HAIC: call AicStopVios ...\n");
+    AicDelStrmUser(&G_HAIC_STRM_USER, &g_haic);
+    ret = AicStopVios(true);
+
+    char outBuf[NORM_BUF_SIZE];
+    int outLen = snprintf_s(outBuf, sizeof(outBuf), sizeof(outBuf) - 1, "{ \"ret\": %d }", ret);
+    RapiReqReply(req, outBuf, outLen);
+    HttpReqDelRef(req);
+    return 0;
+}
+
+/**
+    跺clientset_ai_plug璇锋.
+*/
+static int OnSetAiPlug(void* user, RapiReq* req)
+{
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    pthread_t thrdId;
+    int ret;
+
+    __sync_add_and_fetch(&g_haic.svcThrdNum, 1);
+    ret = DetachThreadCreate(&thrdId, SetAiPlugThrd, req);
+    if (ret < 0) {
+        LOGE("pthread_create FAIL, err='%s (%d)'\n", strerror(errno), errno);
+        if (__sync_sub_and_fetch(&g_haic.svcThrdNum, 1) < 0) {
+            HI_ASSERT(0);
+        }
+        HI_ASSERT(0);
+        HttpReqReset(req, 0);
+        HttpReqDelRef(req);
+    }
+    return 0;
+}
+
+/**
+    跺clientlist_ai_plug璇锋.
+*/
+static int OnListAiPlug(void* user, RapiReq* req)
+{
+    LOGI("HAIC: call AicListAiPlugs() ...\n");
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    MemBlk *reply = NULL;
+
+    int ret = AicListAiPlugs(&reply, TINY_BUF_SIZE);
+    if (ret < 0) {
+        RapiReqReply(req, ERR_RSP_BODY, sizeof(ERR_RSP_BODY) - 1);
+    } else {
+        char buf[SMALL_BUF_SIZE];
+        int len = snprintf_s(buf, sizeof(buf), sizeof(buf) - 1, "{ \"ret\": %d, \"plugs\": ", ret);
+        HI_ASSERT(len > 0);
+        MemBlkPrefixStr(reply, buf, len);
+        MemBlkSuffixStr(reply, "\n}", -1);
+        RapiReqReply2(req, reply);
+    }
+
+    HttpReqDelRef(req);
+    return 0;
+}
+
+/**
+    跺clientaic_post_pic璇锋.
+*/
+static int OnPostPic(void* user, HttpReq* req)
+{
+    bool ret = IsMainThrd();
+    HI_ASSERT(ret);
+
+    if (g_haic.postPicReq) {
+        LOGW("discard pic POST, for post exist\n");
+        HttpReqReset(req, 0);
+        HttpReqDelRef(req);
+        return 0;
+    }
+    g_haic.postPicReq = req;
+
+    int fd = HttpReqReadFd(req);
+    if (EmAddFd(MainEvtMon(), fd, FDE_IN, OnPostPicRead, NULL) < 0) {
+        HI_ASSERT(0);
+    }
+    return 0;
+}
+
+/**
+    跺clientaic_post_model璇锋.
+*/
+static int OnPostModel(void* user, HttpReq* req)
+{
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    pthread_t thrdId;
+    int ret;
+
+    __sync_add_and_fetch(&g_haic.svcThrdNum, 1);
+    ret = DetachThreadCreate(&thrdId, PostModelThrd, req);
+    if (ret < 0) {
+        LOGE("pthread_create FAIL, err='%s (%d)'\n", strerror(errno), errno);
+        if (__sync_sub_and_fetch(&g_haic.svcThrdNum, 1) < 0) {
+            HI_ASSERT(0);
+        }
+        HI_ASSERT(0);
+        HttpReqReset(req, 0);
+        HttpReqDelRef(req);
+    }
+    return 0;
+}
+
+/**
+    跺clientaic_update_soft璇锋.
+*/
+static int OnUpdateSoft(void* user, HttpReq* req)
+{
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    pthread_t thrdId;
+    int ret;
+
+    __sync_add_and_fetch(&g_haic.svcThrdNum, 1);
+    ret = DetachThreadCreate(&thrdId, UpdateSoftThrd, req);
+    if (ret < 0) {
+        LOGE("pthread_create FAIL, err='%s (%d)'\n", strerror(errno), errno);
+        if (__sync_sub_and_fetch(&g_haic.svcThrdNum, 1) < 0) {
+            HI_ASSERT(0);
+        }
+        HI_ASSERT(0);
+        HttpReqReset(req, 0);
+        HttpReqDelRef(req);
+    }
+    return 0;
+}
+
+/**
+    StrmMsgSk版拌揪.
+*/
+static void OnStrmSkRx(void* user, int fd, uint32_t evts)
+{
+    HI_ASSERT(g_haic.strmMsgSk);
+    int ret;
+    ret = SmsRecvFd(g_haic.strmMsgSk);
+    HI_ASSERT(fd == ret);
+    EvtChkRet(evts, FDE_IN, fd);
+    MemBlk *msg = NULL;
+
+    ret = SmsRecv(g_haic.strmMsgSk, &msg);
+    if (ret == 1) {
+        HI_ASSERT(msg && msg->size > sizeof(uint32_t));
+        AicSubmitJpg(&msg->data[sizeof(uint32_t)], msg->size - sizeof(uint32_t), false);
+        MemBlkDelete(msg);
+    } else if (ret == 0) {
+        LOGW("detect strmMsgSk closed\n");
+        SmsDestroy(g_haic.strmMsgSk);
+        g_haic.strmMsgSk = NULL;
+    } else { // ret < 0
+        HI_ASSERT(0); // 涓搴璇ュ虹
+    }
+}
+
+/**
+    StrmMsgSk server妫娴TCP杩ュ拌揪.
+*/
+static void OnStrmSvrConn(void* user, int fd, uint32_t evts)
+{
+    HI_ASSERT(fd == g_haic.strmTcpSvr);
+    EvtChkRet(evts, FDE_IN, fd);
+
+    if (g_haic.strmMsgSk) {
+        EmDelFd(MainEvtMon(), SmsRecvFd(g_haic.strmMsgSk));
+        SmsDestroy(g_haic.strmMsgSk);
+        g_haic.strmMsgSk = NULL;
+    }
+
+    int sock = SockAccept(fd);
+    if (sock < 0 || SmsCreate(&g_haic.strmMsgSk, sock, 0, 0) < 0) {
+        HI_ASSERT(0);
+        return;
+    }
+    if (EmAddFd(MainEvtMon(),
+        SmsRecvFd(g_haic.strmMsgSk), FDE_IN, OnStrmSkRx, NULL) < 0) {
+        HI_ASSERT(0);
+    }
+}
+
+/**
+    濮.
+*/
+int HttpdAicInit(void)
+{
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    res = SkPairValid(&g_haic.httpEvtChn);
+    HI_ASSERT(!res);
+    int ret;
+    ret = SkPairCreate(&g_haic.httpEvtChn);
+    HI_ASSERT(ret >= 0);
+    HttpdMonChn(g_haic.httpEvtChn, NULL);
+
+    g_haic.strmTcpSvr = TcpSvrCreate(STRM_SVR_PORT, 0, true, -1);
+    HI_ASSERT(g_haic.strmTcpSvr >= 0);
+    if (EmAddFd(MainEvtMon(), g_haic.strmTcpSvr, FDE_IN, OnStrmSvrConn, NULL) < 0) {
+        HI_ASSERT(0);
+    }
+
+    HttpdRegSse(URL_SSE_EVT, OnSseConn, NULL, g_haic.httpEvtChn);
+    HttpdRegRapi(URL_GET_INFO, OnGetInfo, NULL, g_haic.httpEvtChn);
+    HttpdRegRapi(URL_GET_STATUS, OnGetStatus, NULL, g_haic.httpEvtChn);
+    HttpdRegRapi(URL_START_VI, OnStartVi, NULL, g_haic.httpEvtChn);
+    HttpdRegRapi(URL_STOP_VI, OnStopVi, NULL, g_haic.httpEvtChn);
+    HttpdRegRapi(URL_START_VO, OnStartVo, NULL, g_haic.httpEvtChn);
+    HttpdRegRapi(URL_STOP_VO, OnStopVo, NULL, g_haic.httpEvtChn);
+    HttpdRegRapi(URL_STOP_VIOS, OnStopVios, NULL, g_haic.httpEvtChn);
+    HttpdRegRapi(URL_SET_AI_PLUG, OnSetAiPlug, NULL, g_haic.httpEvtChn);
+    HttpdRegRapi(URL_LIST_AI_PLUG, OnListAiPlug, NULL, g_haic.httpEvtChn);
+    HttpdRegHttp(URL_POST_PIC, "POST", OnPostPic, NULL, g_haic.httpEvtChn, HRF_REQ_BODY_ONE);
+    HttpdRegHttp(URL_POST_MODEL, "POST", OnPostModel, NULL, g_haic.httpEvtChn, 0);
+    HttpdRegHttp(URL_UPDATE_SOFT, "POST", OnUpdateSoft, NULL, g_haic.httpEvtChn, 0);
+    return 0;
+}
+
+/**
+    诲濮.
+*/
+int HttpdAicExit(void)
+{
+    static const int sleepPerLoop = 10; // 姣娆″惊sleepms
+    bool ret = IsMainThrd();
+    HI_ASSERT(ret);
+
+    HttpdUnreg(URL_SSE_EVT);
+    HttpdUnreg(URL_GET_INFO);
+    HttpdUnreg(URL_GET_STATUS);
+    HttpdUnreg(URL_START_VI);
+    HttpdUnreg(URL_STOP_VI);
+    HttpdUnreg(URL_START_VO);
+    HttpdUnreg(URL_STOP_VO);
+    HttpdUnreg(URL_SET_AI_PLUG);
+    HttpdUnreg(URL_LIST_AI_PLUG);
+    HttpdUnreg(URL_POST_PIC);
+    HttpdUnreg(URL_POST_MODEL);
+    HttpdUnreg(URL_UPDATE_SOFT);
+
+    if (g_haic.strmMsgSk) {
+        SmsDestroy(g_haic.strmMsgSk);
+        g_haic.strmMsgSk = NULL;
+    }
+    if (g_haic.strmTcpSvr >= 0) { // NOTE: 姝ゅcreate戒澶辫触
+        close(g_haic.strmTcpSvr);
+        g_haic.strmTcpSvr = -1;
+    }
+
+    if (g_haic.postPicReq) {
+        HttpReqReset(g_haic.postPicReq, 0);
+        HttpReqDelRef(g_haic.postPicReq);
+        g_haic.postPicReq = NULL;
+    }
+
+    while (!list_empty(&g_haic.sseSessList)) {
+        SseNode *node = list_entry(g_haic.sseSessList.next, SseNode, lnode);
+        CloseSseNode(node, true);
+    }
+
+    SkPairValid(&g_haic.httpEvtChn);
+    HttpdUnmonChn(g_haic.httpEvtChn, NULL);
+
+    // 绛寰扮嚎绋缁
+    if (g_haic.svcThrdNum > 0) {
+        LOGI("HAIC: wait svc thrd end, num=%d, ...\n", g_haic.svcThrdNum);
+        while (g_haic.svcThrdNum > 0) {
+            usleep(((long)sleepPerLoop) * HI_USLEEP_MS);
+        }
+        usleep(((long)sleepPerLoop) * HI_USLEEP_MS); // 灏介璁╁扮嚎绋琚OS姣锛浣涓蹇椤
+        LOGI("HAIC: wait svc thrd end done\n");
+    }
+
+    // 娓绌httpdEvtChn涓琚澶娑
+    HttpdClearChn(g_haic.httpEvtChn);
+    SkPairDestroy(&g_haic.httpEvtChn);
+    return 0;
+}
+
diff -urpBN hiopenais/src/hiopenais/httpd_aic.h hiopenais_modify/src/hiopenais/httpd_aic.h
--- hiopenais/src/hiopenais/httpd_aic.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hiopenais/httpd_aic.h	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HTTPD_AIC_H
+#define HTTPD_AIC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    濮.
+    姝ゅ瑕濮httpd, AicMng
+*/
+int HttpdAicInit(void);
+
+/**
+    诲濮.
+    诲濮藉诲濮httpd, AicMng
+*/
+int HttpdAicExit(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // HTTPD_AIC_H
+
diff -urpBN hiopenais/src/hiopenais/strm_isp.c hiopenais_modify/src/hiopenais/strm_isp.c
--- hiopenais/src/hiopenais/strm_isp.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hiopenais/strm_isp.c	2021-03-29 04:21:14.000000000 -0700
@@ -0,0 +1,263 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <signal.h>
+#include <stdint.h>
+#include <termios.h>
+#include <sys/time.h>
+#include <sys/prctl.h>
+
+#include "uvc_strm.h"
+
+#include "hi_ext_util.h"
+#include "histream.h"
+#include "mpp_help.h"
+#include "strm_isp.h"
+
+#define U8FREQUENCY_NUM1        50
+#define U8FREQUENCY_NUM2        60
+#define FREQUENCY_SET_VALUE1    1
+#define FREQUENCY_SET_VALUE2    2
+#define AUTO_MODE_SET_VALUE     4
+#define ANSOLUTE_TIME_SET_VALUE 100
+
+/*************************************************************************************************
+    Processing Unit Operation Functions
+    ヨsample锛涔淇
+*************************************************************************************************/
+#define SP_STRM_ISP_PU
+
+static uint16_t StrmBrightnessGet(void)
+{
+    ISP_CSC_ATTR_S stCSCAttr;
+
+    HI_MPI_ISP_GetCSCAttr(0, &stCSCAttr);
+    return (uint16_t)stCSCAttr.u8Luma;
+}
+
+static uint16_t StrmContrastGet(void)
+{
+    ISP_CSC_ATTR_S stCSCAttr;
+
+    HI_MPI_ISP_GetCSCAttr(0, &stCSCAttr);
+    return (uint16_t)stCSCAttr.u8Contr;
+}
+
+static uint16_t StrmHueGet(void)
+{
+    ISP_CSC_ATTR_S stCSCAttr;
+
+    HI_MPI_ISP_GetCSCAttr(0, &stCSCAttr);
+    return (uint16_t)stCSCAttr.u8Hue;
+}
+
+static uint8_t StrmPowerLineFrequencyGet(void)
+{
+    ISP_EXPOSURE_ATTR_S stExpAttr;
+
+    HI_MPI_ISP_GetExposureAttr(0, &stExpAttr);
+    if (stExpAttr.stAuto.stAntiflicker.u8Frequency != U8FREQUENCY_NUM1 &&
+        stExpAttr.stAuto.stAntiflicker.u8Frequency != U8FREQUENCY_NUM2) {
+        return 0;
+    }
+    return (stExpAttr.stAuto.stAntiflicker.u8Frequency == U8FREQUENCY_NUM1) ? 0x1 : 0x2;
+}
+
+static uint16_t StrmSaturationGet(void)
+{
+    ISP_CSC_ATTR_S stCSCAttr;
+
+    HI_MPI_ISP_GetCSCAttr(0, &stCSCAttr);
+    return (uint16_t)stCSCAttr.u8Satu;
+}
+
+static uint8_t StrmWhiteBalanceTemperatureAutoGet(void)
+{
+    ISP_WB_ATTR_S stWBAttr;
+
+    HI_MPI_ISP_GetWBAttr(0, &stWBAttr);
+    return (stWBAttr.enOpType == OP_TYPE_AUTO) ? 0x1 : 0x0;
+}
+
+static uint16_t StrmWhiteBalanceTemperatureGet(void)
+{
+    ISP_WB_INFO_S stWBInfo;
+
+    HI_MPI_ISP_QueryWBInfo(0, &stWBInfo);
+    return (uint16_t)stWBInfo.u16ColorTemp;
+}
+
+static void StrmBrightnessSet(uint16_t v)
+{
+    ISP_CSC_ATTR_S stCSCAttr;
+
+    HI_MPI_ISP_GetCSCAttr(0, &stCSCAttr);
+    stCSCAttr.u8Luma = v;
+    HI_MPI_ISP_SetCSCAttr(0, &stCSCAttr);
+}
+
+static void StrmContrastSet(uint16_t v)
+{
+    ISP_CSC_ATTR_S stCSCAttr;
+
+    HI_MPI_ISP_GetCSCAttr(0, &stCSCAttr);
+    stCSCAttr.u8Contr = v;
+    HI_MPI_ISP_SetCSCAttr(0, &stCSCAttr);
+}
+
+static void StrmHueSet(uint16_t v)
+{
+    ISP_CSC_ATTR_S stCSCAttr;
+
+    HI_MPI_ISP_GetCSCAttr(0, &stCSCAttr);
+    stCSCAttr.u8Hue = v;
+    HI_MPI_ISP_SetCSCAttr(0, &stCSCAttr);
+}
+
+static void StrmPowerLineFrequencySet(uint8_t v)
+{
+    HI_S32 s32Ret;
+    ISP_EXPOSURE_ATTR_S stExpAttr;
+
+    HI_MPI_ISP_GetExposureAttr(0, &stExpAttr);
+    if (v == 0) {
+        stExpAttr.stAuto.stAntiflicker.bEnable = HI_FALSE;
+    } else if (v == FREQUENCY_SET_VALUE1) {
+        stExpAttr.stAuto.stAntiflicker.bEnable = HI_TRUE;
+        stExpAttr.stAuto.stAntiflicker.u8Frequency = U8FREQUENCY_NUM1;
+    } else if (v == FREQUENCY_SET_VALUE2) {
+        stExpAttr.stAuto.stAntiflicker.bEnable = HI_TRUE;
+        stExpAttr.stAuto.stAntiflicker.u8Frequency = U8FREQUENCY_NUM2;
+    }
+
+    s32Ret = HI_MPI_ISP_SetExposureAttr(0, &stExpAttr);
+    if (s32Ret != HI_SUCCESS) {
+        LOGE("HI_MPI_ISP_SetExposureAttr err 0x%x\n", s32Ret);
+    }
+}
+
+static void StrmSaturationSet(uint16_t v)
+{
+    ISP_CSC_ATTR_S stCSCAttr;
+
+    HI_MPI_ISP_GetCSCAttr(0, &stCSCAttr);
+    stCSCAttr.u8Satu = v;
+    HI_MPI_ISP_SetCSCAttr(0, &stCSCAttr);
+}
+
+static void StrmWhiteBalanceTemperatureAutoSet(uint8_t v)
+{
+    ISP_WB_ATTR_S stWBAttr;
+
+    HI_MPI_ISP_GetWBAttr(0, &stWBAttr);
+    stWBAttr.enOpType = (v == 1) ? OP_TYPE_AUTO : OP_TYPE_MANUAL;
+    HI_MPI_ISP_SetWBAttr(0, &stWBAttr);
+}
+
+static void StrmWhiteBalanceTemperatureSet(uint16_t v)
+{
+    ISP_WB_INFO_S stWBInfo;
+    ISP_WB_ATTR_S stWBAttr;
+    HI_U16 u16ColorTemp;
+    HI_U16 u16AWBGain[4];
+
+    HI_MPI_ISP_QueryWBInfo(0, &stWBInfo);
+    HI_MPI_ISP_GetWBAttr(0, &stWBAttr);
+
+    u16ColorTemp = v;
+    HI_MPI_ISP_CalGainByTemp(0, &stWBAttr, u16ColorTemp, 0, u16AWBGain);
+
+    stWBAttr.enOpType = OP_TYPE_MANUAL;
+    if (memcpy_s(&stWBAttr.stManual, sizeof(stWBAttr.stManual), u16AWBGain, sizeof(stWBAttr.stManual)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    HI_MPI_ISP_SetWBAttr(0, &stWBAttr);
+}
+
+/*************************************************************************************************
+    Input Terminal Operation Functions
+    ヨsample锛涔淇
+*************************************************************************************************/
+#define SP_STRM_ISP_IT
+
+static uint8_t StrmExposureAutoModeGet(void)
+{
+    ISP_EXPOSURE_ATTR_S stExpAttr;
+
+    HI_MPI_ISP_GetExposureAttr(0, &stExpAttr);
+    return (stExpAttr.enOpType == OP_TYPE_AUTO) ? 0x02 : 0x04;
+}
+
+static uint32_t StrmExposureAnsoluteTimeGet(void)
+{
+    ISP_EXPOSURE_ATTR_S stExpAttr;
+
+    HI_MPI_ISP_GetExposureAttr(0, &stExpAttr);
+    return stExpAttr.stManual.u32ExpTime;
+}
+
+static void StrmExposureAutoModeSet(uint8_t v)
+{
+    ISP_EXPOSURE_ATTR_S stExpAttr;
+
+    HI_MPI_ISP_GetExposureAttr(0, &stExpAttr);
+    stExpAttr.enOpType = (v == AUTO_MODE_SET_VALUE) ? OP_TYPE_MANUAL : OP_TYPE_AUTO;
+    HI_MPI_ISP_SetExposureAttr(0, &stExpAttr);
+}
+
+static void StrmExposureAnsoluteTimeSet(uint32_t v)
+{
+    ISP_EXPOSURE_ATTR_S stExpAttr;
+
+    HI_MPI_ISP_GetExposureAttr(0, &stExpAttr);
+    stExpAttr.stManual.u32ExpTime = v * ANSOLUTE_TIME_SET_VALUE;
+    stExpAttr.stManual.enExpTimeOpType = OP_TYPE_MANUAL;
+    HI_MPI_ISP_SetExposureAttr(0, &stExpAttr);
+}
+
+/*************************************************************************************************
+    Stream Control Operation Functions End
+*************************************************************************************************/
+struct processing_unit_ops g_strmIspPuOps = {
+    .brightness_get = StrmBrightnessGet,
+    .contrast_get = StrmContrastGet,
+    .hue_get = StrmHueGet,
+    .power_line_frequency_get = StrmPowerLineFrequencyGet,
+    .saturation_get = StrmSaturationGet,
+    .white_balance_temperature_auto_get = StrmWhiteBalanceTemperatureAutoGet,
+    .white_balance_temperature_get = StrmWhiteBalanceTemperatureGet,
+
+    .brightness_set = StrmBrightnessSet,
+    .contrast_set = StrmContrastSet,
+    .hue_set = StrmHueSet,
+    .power_line_frequency_set = StrmPowerLineFrequencySet,
+    .saturation_set = StrmSaturationSet,
+    .white_balance_temperature_auto_set = StrmWhiteBalanceTemperatureAutoSet,
+    .white_balance_temperature_set = StrmWhiteBalanceTemperatureSet,
+};
+
+struct input_terminal_ops g_strmIspItOps = {
+    .exposure_ansolute_time_get = StrmExposureAnsoluteTimeGet,
+    .exposure_auto_mode_get = StrmExposureAutoModeGet,
+    .exposure_ansolute_time_set = StrmExposureAnsoluteTimeSet,
+    .exposure_auto_mode_set = StrmExposureAutoModeSet,
+};
+
diff -urpBN hiopenais/src/hiopenais/strm_isp.h hiopenais_modify/src/hiopenais/strm_isp.h
--- hiopenais/src/hiopenais/strm_isp.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hiopenais/strm_isp.h	2021-03-29 04:21:31.000000000 -0700
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef STRM_ISP_H
+#define STRM_ISP_H
+
+#include "uvc_strm.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct processing_unit_ops g_strmIspPuOps;
+extern struct input_terminal_ops g_strmIspItOps;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // STRM_ISP_H
diff -urpBN hiopenais/src/hiopenais/strm_saver.c hiopenais_modify/src/hiopenais/strm_saver.c
--- hiopenais/src/hiopenais/strm_saver.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hiopenais/strm_saver.c	2021-03-29 20:47:34.000000000 -0700
@@ -0,0 +1,261 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <limits.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include "hi_ext_util.h"
+#include "mpp_help.h"
+#include "aic_mng.h"
+#include "strm_saver.h"
+
+/**
+    AIC Stream File Saver.
+*/
+struct StrmSaver {
+    EvtMon *emon;
+    SkPair chn;
+
+    FILE *file; // 褰寮ㄦュstream浠跺ユ
+    bool fileErr; // 浠舵浣璇锛缁灏涓浠
+
+    // stream稿
+    size_t frmId; // 跺扮frameID
+    PAYLOAD_TYPE_E codecType;
+    int width;
+    int height;
+
+    // config by user
+    char *filePfx; // 浠跺缂锛褰
+    size_t queSize; // 褰㈤size
+    size_t frmPerFile; // 姣涓浠舵澶уㄧframe
+};
+
+static inline void SaverClearStrm(StrmSaver* self)
+{
+    self->frmId = 0;
+    self->codecType = PT_BUTT;
+    self->width = -1;
+    self->height = -1;
+}
+
+static int SaverOpenFile(StrmSaver* self)
+{
+    char stFilePath[PATH_MAX] = {0};
+    const char *fileExt = "";
+
+    if (self->codecType == PT_H264) {
+        fileExt = ".h264";
+    } else if (self->codecType == PT_H265) {
+        fileExt = ".h265";
+    } else if (self->codecType == PT_MJPEG) {
+        fileExt = ".mjpeg";
+    } else {
+        fileExt = ".unkn";
+    }
+
+    HI_ASSERT(self->frmPerFile > 0);
+    int id = self->frmId / self->frmPerFile % self->queSize;
+
+    if (!realpath(self->filePfx, stFilePath)) {
+        LOGI("fileName:%s, stFilePath:%s\n", self->filePfx, stFilePath);
+        HI_ASSERT(0);
+    }
+    if (snprintf_s(stFilePath, sizeof(stFilePath), sizeof(stFilePath) - 1,
+        "%s%04d%s", self->filePfx, id, fileExt) < 0) {
+        HI_ASSERT(0);
+    }
+    LOGI("SaverOpenFile standard file path:%s\n", stFilePath);
+    LOGI("SAVER: %s <= %d frames ...\n", stFilePath, self->frmPerFile);
+    self->file = fopen(stFilePath, "wb");
+    if (!self->file) {
+        LOGE("open '%s' for 'wb' FAIL, err='%s, %d'\n", stFilePath, strerror(errno), errno);
+        self->fileErr = true;
+        return -1;
+    }
+    return 0;
+}
+
+static void SaverOnFrmChn(void* user, int fd, uint32_t evts)
+{
+    HI_ASSERT(user);
+    StrmSaver *self = (StrmSaver*)user;
+    HI_ASSERT(fd == self->chn.in);
+    EvtChkRet(evts, FDE_IN, fd);
+    VencFrm *frm = NULL;;
+
+    if (FdReadMsg(fd, &frm, sizeof(VencFrm *)) != sizeof(VencFrm *)) { // need ensure by xiao
+        return;
+    }
+    HI_ASSERT(frm);
+
+    if (self->fileErr) {
+        goto END;
+    }
+    if (!self->file && SaverOpenFile(self) < 0) {
+        goto END;
+    }
+
+    if (VencFrmToFile(&frm->strm, self->file) < 0) {
+        LOGE("stop writing file, for writing FAIL\n");
+        fclose(self->file);
+        self->file = NULL;
+        self->fileErr = true;
+        goto END;
+    }
+
+    self->frmId++;
+    if (self->frmId % self->frmPerFile == 0) {
+        fclose(self->file);
+        self->file = NULL;
+    }
+
+    END:
+        HI_ASSERT(frm);
+        VencFrmDelRef(frm);
+}
+
+static void SaverOnStrmOff(void* user)
+{
+    LOGI("SAVER: on strm off\n");
+    HI_ASSERT(user);
+    StrmSaver *self = (StrmSaver*)user;
+
+    if (self->file) {
+        fclose(self->file);
+        self->file = NULL;
+    }
+    SaverClearStrm(self);
+}
+
+static bool SaverOnStrmOn(void* user, int vencChn, PAYLOAD_TYPE_E codecType, int width, int height)
+{
+    LOGI("SAVER: on strm on, codec=%d, width=%d, height=%d\n", codecType, width, height);
+    HI_ASSERT(user);
+    StrmSaver *self = (StrmSaver*)user;
+
+    if (self->codecType != PT_BUTT) {
+        LOGW("onStrmOn without onStrmOff before\n");
+        SaverOnStrmOff(user);
+    }
+    HI_ASSERT(!self->file);
+
+    self->frmId = 0;
+    self->codecType = codecType;
+    self->width = width;
+    self->height = height;
+    return true;
+}
+
+static void SaverOnVencFrm(void* user, VencFrm* frm)
+{
+    HI_ASSERT(user && frm);
+    StrmSaver *self = (StrmSaver*)user;
+
+    VencFrmAddRef(frm);
+    if (FdWriteMsg(self->chn.out, &frm, sizeof(VencFrm*)) != sizeof(VencFrm*)) { // need ensure by xiao
+        LOGE("post frm to svc thrd FAIL\n");
+        VencFrmDelRef(frm);
+    }
+}
+
+static const IAicStrmUser G_SAVER_STRM_USER = {
+    .OnStrmOn = SaverOnStrmOn,
+    .OnStrmOff = SaverOnStrmOff,
+    .OnVencFrm = SaverOnVencFrm,
+    .OnVideoFrm = NULL,
+};
+
+int StrmSaverCreate(StrmSaver** saver, int queSize, int frmPerFile, const char* filePfx)
+{
+    HI_ASSERT(saver);
+    HI_ASSERT(filePfx && *filePfx);
+    HI_ASSERT(queSize > 0);
+    HI_ASSERT(frmPerFile > 0);
+    *saver = NULL;
+    int ret;
+
+    StrmSaver *self = (StrmSaver*)malloc(sizeof(*self));
+    HI_ASSERT(self);
+    if (memset_s(self, sizeof(*self), 0, sizeof(*self)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    ret = EmCreate(&self->emon);
+    HI_ASSERT(ret == 0);
+    ret = SkPairCreate(&self->chn);
+    HI_ASSERT(ret == 0);
+    ret = EmAddFd(self->emon, self->chn.in, FDE_IN, SaverOnFrmChn, self);
+    HI_ASSERT(ret == 0);
+
+    self->file = NULL;
+    self->fileErr = false;
+    SaverClearStrm(self);
+
+    self->filePfx = HiStrdup(filePfx);
+    self->queSize = queSize;
+    self->frmPerFile = frmPerFile;
+
+    ret = EmStart(self->emon);
+    HI_ASSERT(ret == 0);
+
+    ret = (int)AicAddStrmUser(&G_SAVER_STRM_USER, self);
+    HI_ASSERT(ret);
+
+    *saver = self;
+    LOGI("SAVER: started, queSize=%d, frmPerFile=%d, filePfx='%s'\n", self->queSize, self->frmPerFile, self->filePfx);
+    return 0;
+}
+
+void StrmSaverDestroy(StrmSaver* self)
+{
+    HI_ASSERT(self);
+    int ret;
+
+    ret = (int)AicDelStrmUser(&G_SAVER_STRM_USER, self);
+    HI_ASSERT(ret);
+
+    HI_ASSERT(self->emon);
+    ret = EmStop(self->emon);
+    HI_ASSERT(ret == 0);
+
+    bool res = SkPairValid(&self->chn);
+    HI_ASSERT(res);
+    ret = EmDelFd(self->emon, self->chn.in);
+    HI_ASSERT(ret == 0);
+
+    VencFrm *frm = NULL;
+    while (FdReadMsg(self->chn.in, &frm, sizeof(VencFrm *)) == sizeof(VencFrm *)) { // need ensure by xiao
+        VencFrmDelRef(frm);
+    }
+    SkPairDestroy(&self->chn);
+
+    if (self->file) {
+        fclose(self->file);
+    }
+    if (self->filePfx) {
+        free(self->filePfx);
+    }
+
+    EmDestroy(self->emon);
+    free(self);
+}
+
diff -urpBN hiopenais/src/hiopenais/strm_saver.h hiopenais_modify/src/hiopenais/strm_saver.h
--- hiopenais/src/hiopenais/strm_saver.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hiopenais/strm_saver.h	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AIC_STRM_SAVER_H
+#define AIC_STRM_SAVER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct StrmSaver StrmSaver;
+
+int StrmSaverCreate(StrmSaver** saver, int queSize, int frmPerFile, const char* filePfx);
+void StrmSaverDestroy(StrmSaver* self);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // AIC_STRM_SAVER_H
diff -urpBN hiopenais/src/hiopenais/uvc_aic.c hiopenais_modify/src/hiopenais/uvc_aic.c
--- hiopenais/src/hiopenais/uvc_aic.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hiopenais/uvc_aic.c	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,377 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <limits.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include "histream.h"
+#include "hi_ext_util.h"
+#include "mpp_help.h"
+#include "aic_mng.h"
+#include "uvc_strm.h"
+#include "uvc_def.h"
+#include "uvc_aic.h"
+
+/**
+    UVC Agent of AIC.
+*/
+struct UvcAgent {
+    uvc_dev_ext_t *uvcDev; // uvc device used
+
+    // aic stream稿
+    PAYLOAD_TYPE_E videoCodec;
+    int videoWidth;
+    int videoHeight;
+    int vencChn;
+
+    // uvc stream稿
+    bool uvcWorking; // UVC stream宸茬started锛uvc_dev寮
+    bool strmMatch; // UVC stream姹涓aic stream归锛虫煎绱绛涓
+    encoder_property uvcProp; // uvc渚prop
+
+    bool inInitTx; // 姝ｅㄥ濮剧
+};
+
+/**
+    uvc_dev瀹扮讹堕ㄥㄥ瀵硅薄. 灏ュ淇逛负澶涓UvcAgent瀹渚卞.
+*/
+static UvcAgent *g_uaic = NULL;
+
+/**
+    灏UVC绱煎杞涓MPP.
+*/
+static HI_S32 PixfmtUvcToMpp(unsigned int uvcFmt)
+{
+    if (uvcFmt == V4L2_PIX_FMT_YUYV) {
+        return PIXEL_FORMAT_YVU_SEMIPLANAR_422;
+    } else {
+        return PIXEL_FORMAT_YVU_SEMIPLANAR_420;
+    }
+}
+
+/**
+    灏UVCcodec type杞涓MPP(payload type).
+*/
+static PAYLOAD_TYPE_E CodecUvcToMpp(uint32_t fcc)
+{
+    PAYLOAD_TYPE_E t;
+
+    switch (fcc) {
+        case V4L2_PIX_FMT_MJPEG:
+            t = PT_MJPEG;
+            break;
+
+        case V4L2_PIX_FMT_H264:
+            t = PT_H264;
+            break;
+
+        case V4L2_PIX_FMT_YUYV:
+        default:
+            t = PT_MJPEG;
+            break;
+    }
+    return t;
+}
+
+/**
+    ゆUVCstream姹涓AICstream杈烘归.
+*/
+static void ChkStrmMatch(UvcAgent* self)
+{
+    if (!self->uvcWorking || self->videoCodec == PT_BUTT) {
+        return;
+    }
+
+    encoder_property *uvcProp = &self->uvcProp;
+    PAYLOAD_TYPE_E codecType = CodecUvcToMpp(uvcProp->format);
+
+    self->strmMatch = (codecType == self->videoCodec &&
+        uvcProp->width == self->videoWidth && uvcProp->height == self->videoHeight);
+
+    // H.264/H.265IDR璇锋
+    if (self->strmMatch && (self->videoCodec == PT_H264 || self->videoCodec == PT_H265)) {
+        LOGW("set IDR\n");
+        int ret = HI_MPI_VENC_RequestIDR(self->vencChn, HI_TRUE);
+        HI_EXP_LOGE(ret, "HI_MPI_VENC_RequestIDR FAIL, ret=%#x\n", ret);
+    }
+}
+
+/**
+    褰UVC strm琚host姝.
+*/
+static int OnUvcStopStrm(void)
+{
+    LOGI("UVC-AIC: on UVC strm stop ...\n");
+    bool ret = IsMainThrd();
+    HI_ASSERT(ret);
+    HI_ASSERT(g_uaic);
+    UvcAgent *self = g_uaic;
+
+    AicStopVo(AIC_VOT_UVC);
+    AicStopVi(AIC_VIT_SENSOR, false);
+
+    self->uvcWorking = false;
+    self->strmMatch = false;
+
+    LOGI("UVC-AIC: on UVC strm stop done\n");
+    return 0;
+}
+
+/**
+    褰UVC strm琚host.
+*/
+static int OnUvcStartStrm(void)
+{
+    LOGI("UVC-AIC: on UVC strm start ...\n");
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    HI_ASSERT(g_uaic);
+    UvcAgent *self = g_uaic;
+    int ret;
+
+    encoder_property *uvcProp = &self->uvcProp;
+    PIXEL_FORMAT_E pixFormat = PixfmtUvcToMpp(uvcProp->format);
+    PAYLOAD_TYPE_E codecType = CodecUvcToMpp(uvcProp->format);
+    uint32_t width = self->uvcProp.width;
+    uint32_t height = self->uvcProp.height;
+
+    LOGI("UVC-AIC: start UVC strm, codec=%d, size={%ux%u} ...\n", codecType, width, height);
+
+    // 朵涓ょ煎
+    if (uvcProp->format == V4L2_PIX_FMT_YUYV || uvcProp->format == V4L2_PIX_FMT_YUV420) {
+        LOGE("UVC-AIC: not supp YUYV, YUV420 now\n");
+        return -1;
+    }
+
+    // VO涓哄
+    ret = AicStartVo(AIC_VOT_UVC, width, height, codecType);
+    HI_EXP_RET(ret < 0, ret, "start VOT_UVC FAIL, ret=%d\n", ret);
+
+    ret = AicStartVi(AIC_VIT_SENSOR, false, width, height, pixFormat);
+    if (ret < 0) {
+        LOGE("start VIT_SENSOR FAIL, ret=%d\n", ret);
+        AicStopVo(AIC_VOT_UVC);
+        return ret;
+    }
+
+    self->uvcWorking = true;
+    ChkStrmMatch(self);
+
+    // 褰aic瀹viType涓HOST讹initPic
+    if (self->strmMatch && AicGetViType() == AIC_VIT_HOST &&
+        (ret = AicTxInitPic()) >= 0) {
+        self->inInitTx = true;
+    }
+
+    LOGI("UVC-AIC: on UVC strm start done\n");
+    return ret;
+}
+
+/**
+    褰UVC璇锋峰IDR frame.
+*/
+static HI_S32 OnUvcSetIdr(void)
+{
+    LOGD("UVC-AIC: on UVC set IDR ...\n");
+    bool res = IsMainThrd();
+    HI_ASSERT(res);
+    HI_ASSERT(g_uaic);
+    UvcAgent *self = g_uaic;
+
+    if (self->uvcWorking && self->vencChn >= 0 &&
+        (self->videoCodec == PT_H264 || self->videoCodec == PT_H265)) {
+        LOGI("UVC-AIC: setIdr\n");
+        int ret = HI_MPI_VENC_RequestIDR(g_uaic->vencChn, HI_TRUE);
+        HI_EXP_LOGE(ret, "HI_MPI_VENC_RequestIDR FAIL, ret=%#x\n", ret);
+        return ret;
+    } else {
+        LOGI("UVC-AIC: setIdr ignore, for vencChn=%d, codecType=%d\n", self->vencChn, self->videoCodec);
+        return 0;
+    }
+}
+
+/**
+    UVC璁剧疆strm灞.
+*/
+static HI_S32 OnUvcSetProp(encoder_property *p)
+{
+    LOGD("UVC-AIC: on UVC set prop ...\n");
+    bool ret = IsMainThrd();
+    HI_ASSERT(ret);
+    HI_ASSERT(g_uaic);
+    UvcAgent *self = g_uaic;
+
+    self->uvcProp = *p;
+    return 0;
+}
+
+/**
+    渚缁UVC璋ュｉ.
+*/
+static struct stream_control_ops g_uvcScOps = {
+    .init = NULL,
+    .startup = OnUvcStartStrm,
+    .shutdown = OnUvcStopStrm,
+    .set_idr = OnUvcSetIdr,
+    .set_property = OnUvcSetProp,
+};
+
+/**
+    AicMng寮strm off.
+*/
+static void OnAicStrmOff(void* user)
+{
+    LOGI("SAVER: on strm off\n");
+    HI_ASSERT(user);
+    UvcAgent *self = (UvcAgent*)user;
+
+    self->vencChn = -1;
+    self->videoWidth = 0;
+    self->videoHeight = 0;
+    self->videoCodec = PT_BUTT;
+
+    self->strmMatch = false;
+}
+
+/**
+    AicMng寮strm on.
+*/
+static bool OnAicStrmOn(void* user, int vencChn, PAYLOAD_TYPE_E codecType, int width, int height)
+{
+    LOGI("UVC-AIC: on strm on, codec=%d, width=%d, height=%d\n", codecType, width, height);
+    HI_ASSERT(user);
+    UvcAgent *self = (UvcAgent*)user;
+
+    if (self->videoCodec != PT_BUTT) {
+        LOGW("onStrmOn without onStrmOff before\n");
+        OnAicStrmOff(user);
+    }
+
+    self->vencChn = vencChn;
+    HI_ASSERT(width > 0 && height > 0);
+    self->videoWidth = width;
+    self->videoHeight = height;
+    self->videoCodec = codecType;
+
+    ChkStrmMatch(self);
+    return true;
+}
+
+/**
+    AicMng寮strm frm.
+*/
+static void OnAicVencFrm(void* user, VencFrm* frm)
+{
+    HI_ASSERT(user && frm);
+    UvcAgent *self = (UvcAgent*)user;
+    int ret;
+
+    if (!self->uvcWorking) {
+        return;
+    }
+    if (!self->strmMatch) {
+        LOGD("discard aic frm, for strm not match\n");
+        return;
+    }
+
+    MemBlk *mblk = uvc_alloc_buf(self->uvcDev);
+    if (!mblk) {
+        return;
+    }
+
+    VencFrmToMblk(&frm->strm, mblk, 0);
+    ret = uvc_tx_frm(self->uvcDev, mblk);
+    HI_EXP_LOGE(ret < 0, "tx frm to UVC FAIL, ret=%d\n", ret);
+
+    // 杩ゆinInitTx锛涓ゆaic瀹vitype
+    if (self->inInitTx) {
+        self->inInitTx = false;
+        if (!uvc_strm_ready(self->uvcDev) && (ret = AicTxInitPic()) >= 0) {
+            self->inInitTx = true;
+        }
+    }
+}
+
+/**
+    瀹扮AicMng StrmUserュ.
+*/
+static const IAicStrmUser G_UVC_STRM_USER = {
+    .OnStrmOn = OnAicStrmOn,
+    .OnStrmOff = OnAicStrmOff,
+    .OnVencFrm = OnAicVencFrm,
+    .OnVideoFrm = NULL,
+};
+
+/**
+    寤哄苟UVC AIC agent.
+*/
+int UvcAgentCreate(UvcAgent** agent, uvc_dev_ext_t* uvcDev)
+{
+    HI_ASSERT(!g_uaic);
+    HI_ASSERT(agent && uvcDev);
+    *agent = NULL;
+    int ret;
+
+    UvcAgent *self = (UvcAgent*)malloc(sizeof(*self));
+    HI_ASSERT(self);
+    if (memset_s(self, sizeof(*self), 0, sizeof(*self)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    self->vencChn = -1;
+    self->videoWidth = 0;
+    self->videoHeight = 0;
+    self->videoCodec = PT_BUTT;
+    self->uvcWorking = false;
+    self->strmMatch = false;
+    self->inInitTx = false;
+
+    self->uvcDev = uvcDev;
+    histream_register_mpi_ops_ext(&g_uvcScOps, &g_strmIspPuOps, &g_strmIspItOps, NULL);
+
+    ret = (int)AicAddStrmUser(&G_UVC_STRM_USER, self);
+    HI_ASSERT(ret);
+
+    *agent = g_uaic = self;
+    LOGI("UVC-AIC: created\n");
+    return 0;
+}
+
+/**
+    缁姝㈠苟姣UVC AIC agent.
+*/
+void UvcAgentDestroy(UvcAgent* self)
+{
+    HI_ASSERT(g_uaic);
+    HI_ASSERT(self && self == g_uaic);
+    int ret;
+
+    ret = (int)AicDelStrmUser(&G_UVC_STRM_USER, self);
+    HI_ASSERT(ret);
+
+    histream_register_mpi_ops_ext(NULL, NULL, NULL, NULL);
+    HI_ASSERT(self->uvcDev);
+
+    free(self);
+    g_uaic = NULL;
+    LOGI("UVC-AIC: destroyed\n");
+}
+
diff -urpBN hiopenais/src/hiopenais/uvc_aic.h hiopenais_modify/src/hiopenais/uvc_aic.h
--- hiopenais/src/hiopenais/uvc_aic.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/hiopenais/uvc_aic.h	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UVC_AIC_H
+#define UVC_AIC_H
+
+#include "histream.h"
+#include "uvc_dev.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern struct processing_unit_ops g_strmIspPuOps;
+extern struct input_terminal_ops g_strmIspItOps;
+
+/**
+    UvcAgent type.
+*/
+typedef struct UvcAgent UvcAgent;
+
+/**
+    寤哄苟UVC AIC agent.
+*/
+int UvcAgentCreate(UvcAgent** agent, uvc_dev_ext_t* uvcDev);
+
+/**
+    缁姝㈠苟姣UVC AIC agent.
+*/
+void UvcAgentDestroy(UvcAgent* self);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // UVC_AIC_H
diff -urpBN hiopenais/src/lite_http/http_def.h hiopenais_modify/src/lite_http/http_def.h
--- hiopenais/src/lite_http/http_def.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/lite_http/http_def.h	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HTTP_DEF_H
+#define HTTP_DEF_H
+
+#include "hi_ext_def.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    甯哥http header name瀹涔.
+*/
+#define HH_CONTENT_TYPE         "content-type"
+#define HH_ACCEPT               "accept" // req only
+#define HH_CONTENT_LENGTH       "content-length"
+#define HH_METHOD               ":method"
+#define HH_SCHEME               ":scheme"
+#define HH_AUTHORITY            ":authority"
+#define HH_HOST                 ":host"
+#define HH_PATH                 ":path"
+#define HH_STATUS               ":status" // rsp only
+#define HH_LAST_EVT_ID          "last-event-id" // for SSE
+
+/**
+    甯哥http status (response code)瀹涔.
+*/
+#define HRSP_OK                 200
+
+/**
+    http method.
+*/
+#define HM_GET                  "GET"
+#define HM_HEAD                 "HEAD"
+#define HM_PUT                  "PUT"
+#define HM_POST                 "POST"
+
+/**
+    http method code (uint32_t).
+*/
+#define HMC_ALL                 0xFFFFFFFF
+#define HMC_GET                 HI_BIT0
+#define HMC_HEAD                HI_BIT1
+#define HMC_PUT                 HI_BIT4
+#define HMC_POST                HI_BIT5
+
+/**
+    ョcontent-type.
+*/
+#define HCT_RAPI                "application/json"
+#define HCT_SSE                 "text/event-stream"
+
+/**
+    椤瑰父.
+*/
+#define HTTP_METHOD_MAX         16 // method string buf max
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // HTTP_DEF_H
diff -urpBN hiopenais/src/lite_http/http_hdrs.c hiopenais_modify/src/lite_http/http_hdrs.c
--- hiopenais/src/lite_http/http_hdrs.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/lite_http/http_hdrs.c	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,225 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "hi_ext_util.h"
+#include "http_hdrs.h"
+
+/**
+    实现说明.
+
+    header大小写不敏感，可用hi_stricmp(), HiStrincmp()比较。
+    nameLen, valueLen的设置是为了避免user使用时重新求长度，降低性能损失。
+*/
+#define DESIGN_DESC
+
+/**
+    表示一个http header.
+
+    为减少动态内存分配，HttpHdr设计为长度可变对象，可变部分中存储name和value。
+    存储的name和value需要以0终结。
+
+    创建HttpHdr时，需要根据name和value的长度确定对象的长度。
+*/
+typedef struct HttpHdr {
+    struct list_head lnode; // 作为list节点
+    char* name; // name，指向buf中的name部分，实际指向buf[0]
+    char* value; // value，指向buf中的value部分
+    int nameLen; // name的string len
+    int valueLen; // value的string len
+    char buf[0]; // 在对象创建时确定长度的可变buf，存储name和value的内容
+}   HttpHdr;
+
+/**
+    HttpHdrs数据成员.
+
+    为简化实现，目前用固定数组来存储header。将来可修改为动态数据或链表。
+    目前未提供remove API，因此add的header均存储在table的前部。
+
+    也可用linux_list.h中的list来组织HttpHdr。
+*/
+struct HttpHdrs {
+    struct list_head hdrList; // HttpHdr链表头
+    int hdrNum; // hdrTab中存储的header的数目。
+};
+
+/**
+    创建HttpHdr.
+
+    可用offsetof(HttpHdr, buf)获得HttpHdr不含buf的部分的字节长度。
+*/
+HttpHdr* HttpHdrNew(const char* name, int nameLen, const char* value, int valueLen)
+{
+    HI_ASSERT(name && *name);
+    HI_ASSERT(value && *value);
+    HttpHdr *self = NULL;
+    int size;
+
+    if (nameLen < 0) {
+        nameLen = strlen(name);
+    }
+    if (valueLen < 0) {
+        valueLen = strlen(value);
+    }
+    size = sizeof(*self) + nameLen + 1 + valueLen + 1; // 用offsetof替代计算
+
+    self = (HttpHdr*)malloc(size);
+    HI_ASSERT(self);
+    self->name = self->buf;
+    self->value = self->buf + nameLen + 1;
+    self->nameLen = nameLen;
+    self->valueLen = valueLen;
+    if (memcpy_s(self->name, self->nameLen, name, nameLen) != EOK) {
+        HI_ASSERT(0);
+    }
+    self->name[nameLen] = 0;
+    if (memcpy_s(self->value, self->valueLen, value, valueLen) != EOK) {
+        HI_ASSERT(0);
+    }
+    self->value[valueLen] = 0;
+    INIT_LIST_HEAD(&self->lnode);
+    return self;
+}
+
+/**
+    析构函数.
+*/
+HttpHdrs* HttpHdrsNew(int rsv)
+{
+    HttpHdrs *self;
+
+    self = (HttpHdrs*)malloc(sizeof(*self));
+    if (!self) {
+        HI_ASSERT(0);
+    }
+    INIT_LIST_HEAD(&self->hdrList);
+    self->hdrNum = 0;
+    return self;
+}
+
+/**
+    析构函数.
+*/
+void HttpHdrsDelete(HttpHdrs* self)
+{
+    HI_ASSERT(self);
+    struct list_head *node = NULL;
+    struct list_head *next = NULL;
+    HttpHdr *hdr = NULL;
+
+    list_for_each_safe(node, next, &self->hdrList) {
+        hdr = list_entry(node, HttpHdr, lnode);
+        free(hdr);
+    }
+    free(self);
+}
+
+/**
+    添加header.
+*/
+bool HttpHdrsAdd(HttpHdrs* self, const char* name, int nameLen, const char* value, int valueLen)
+{
+    HI_ASSERT(self);
+    HttpHdr *hdr = NULL;
+
+    hdr = HttpHdrNew(name, nameLen, value, valueLen);
+    HI_ASSERT(hdr);
+    list_add_tail(&hdr->lnode, &self->hdrList);
+    self->hdrNum++;
+    return true;
+}
+
+/**
+    查找header.
+*/
+const char* HttpHdrsFind(const HttpHdrs* self, const char* name, int* valueLen)
+{
+    HI_ASSERT(self);
+    HI_ASSERT(name && *name);
+    struct list_head *node = NULL;
+    HttpHdr *hdr = NULL;
+
+    list_for_each(node, &self->hdrList) {
+        hdr = list_entry(node, HttpHdr, lnode);
+        if (HiStricmp(hdr->name, name) == 0) {
+            if (valueLen) {
+                *valueLen = hdr->valueLen;
+            }
+            return hdr->value;
+        }
+    }
+
+    if (valueLen) {
+        *valueLen = 0;
+    }
+    return NULL;
+}
+
+/**
+    获取header数目.
+*/
+int HttpHdrsSize(const HttpHdrs* self)
+{
+    HI_ASSERT(self);
+    return self->hdrNum;
+}
+
+/**
+    创建枚举器.
+
+    枚举器总是指向已获取节点，即其next为即将获取节点。这与常规的方式不同。
+    list root是不含节点的。
+*/
+void HttpHdrsEnumInit(const HttpHdrs* self, uintptr_t* it)
+{
+    HI_ASSERT(self && it);
+    *it = (uintptr_t)&self->hdrList;
+}
+
+/**
+    枚举.
+*/
+bool HttpHdrsEnumNext(const HttpHdrs* self, uintptr_t* it,
+    const char** name, int* nameLen, const char** value, int* valueLen)
+{
+    HI_ASSERT(self && it);
+    struct list_head *node = (struct list_head*)*it;
+    HttpHdr *hdr = NULL;
+
+    if (node->next != &self->hdrList) {
+        hdr = list_entry(node->next, HttpHdr, lnode);
+        if (name) {
+            *name = hdr->name;
+        }
+        if (nameLen) {
+            *nameLen = hdr->nameLen;
+        }
+        if (value) {
+            *value = hdr->value;
+        }
+        if (valueLen) {
+            *valueLen = hdr->valueLen;
+        }
+
+        *it = (uintptr_t)node->next;
+        return true;
+    } else {
+        return false;
+    }
+}
+
diff -urpBN hiopenais/src/lite_http/http_hdrs.h hiopenais_modify/src/lite_http/http_hdrs.h
--- hiopenais/src/lite_http/http_hdrs.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/lite_http/http_hdrs.h	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HTTP_HDRS_H
+#define HTTP_HDRS_H
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    HttpHdrs对象声明.
+
+    所有数据成员均为私有，在.c中定义。
+
+    HttpHdrs代表一个http请求或一个响应的header list。每个HttpHdrs有任意多个header组成，
+    每个header有name，value对组成。
+
+    @note header name大小写不敏感。比较时，可使用hi_stricmp()不区分大小写比较。
+*/
+typedef struct HttpHdrs HttpHdrs;
+
+/**
+    构造函数.
+
+    @param rsv 保留，应置为NULL。
+*/
+HttpHdrs* HttpHdrsNew(int rsv);
+
+/**
+    析构函数.
+*/
+void HttpHdrsDelete(HttpHdrs* self);
+
+/**
+    添加header.
+
+    @param nameLen name string的长度。置为-1表示长度未知，可用strlen()获得。
+    @param valueLen value string的长度。置为-1表示长度未知，可用strlen()获得。
+
+    @return 保留，总是返回true。
+*/
+bool HttpHdrsAdd(HttpHdrs* self, const char* name, int nameLen, const char* value, int valueLen);
+
+/**
+    查找header.
+
+    @note 返回的value指向HttpHdrs内部buf，user不应free。
+
+    @param valueLen 返回找到的value的string len。可置为NULL。
+    @return 返回第一个匹配的header的value。返回NULL表示对应header不存在。
+*/
+const char* HttpHdrsFind(const HttpHdrs* self, const char* name, int* valueLen);
+
+/**
+    获取header数目.
+*/
+int HttpHdrsSize(const HttpHdrs* self);
+
+/**
+    简单枚举.
+
+    枚举器类型为intptr_t。
+    enumInit()初始化枚举器。
+    enumNext()枚举下一个元素。
+
+    enumNext()枚举到元素时，通过参数返回枚举到的header的内容。
+
+    @demo
+        const char *name, *value;
+        intptr_t it;
+        HttpHdrsEnumInit(self, &it);
+        while (HttpHdrsEnumNext(self, &it, &name, &value) {
+            printf("name='%s', value='%s'\n", name, value);
+        }
+
+    @param it 枚举器地址。
+    @param name 返回枚举到的header的name。可置为NULL表示不返回该数据。
+    @param value 返回枚举到的header的value。可置为NULL表示不返回该数据。
+    @param nameLen 返回枚举到的name的string len。可置为NULL表示不返回该数据。
+    @param valueLen 返回枚举到的val的string len。可置为NULL表示不返回该数据。
+
+    @return enumNext()枚举到元素是返回true，否则返回false。返回false表示没有更多元素。
+*/
+void HttpHdrsEnumInit(const HttpHdrs* self, uintptr_t* it);
+bool HttpHdrsEnumNext(const HttpHdrs* self, uintptr_t* it,
+    const char** name, int* nameLen, const char** value, int* valueLen);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // HTTP_HDRS_H
diff -urpBN hiopenais/src/lite_http/http_rapi.c hiopenais_modify/src/lite_http/http_rapi.c
--- hiopenais/src/lite_http/http_rapi.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/lite_http/http_rapi.c	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,147 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "http_req.h"
+#include "http_rapi.h"
+
+/**
+    @mainpage
+
+    rapi为最简单的请求模型，user只关心入参和出参，不关心header。
+*/
+#define DESIGN_DESC_PAD
+
+/**
+    设置出参.
+
+    需要先判断HttpReq状态。
+    首先write rsp headers，然后再write rsp body。
+*/
+int RapiReqReply(HttpReq* self, const char* outData, int outLen)
+{
+    HI_ASSERT(self && outData);
+    MemBlk *out = NULL;
+
+    // 目前允许0 outBody
+    if (outLen < 0) {
+        outLen = strlen(outData);
+    }
+
+    HI_ASSERT(outLen > 0);
+    out = MemBlkNew(outLen);
+    HI_ASSERT(out);
+    if (memcpy_s(out->data, out->size, outData, outLen) != EOK) {
+        HI_ASSERT(0);
+    }
+    out->len = outLen;
+    return RapiReqReply2(self, out);
+}
+
+/**
+    replyx.
+*/
+int RapiReqReply2(HttpReq* self, MemBlk* out)
+{
+    HI_ASSERT(self && out);
+    HttpHdrs *rspHdrs = NULL;
+    char bodyLen[INT_STR_BUF_SIZE];
+    int res;
+
+    // NOTE: 不需要校验HttpReq状态，HttpReq会处理 ...
+    LOGI("HTTP: rapi reply, len=%d ...\n", out ? out->len : 0);
+
+    // 组织rsp headers
+    rspHdrs = HttpHdrsNew(0);
+    HI_ASSERT(rspHdrs);
+    HttpHdrsAdd(rspHdrs, HH_STATUS, -1, "200", -1);
+    HttpHdrsAdd(rspHdrs, HH_CONTENT_TYPE, -1, HCT_RAPI, -1);
+    if (snprintf_s(bodyLen, sizeof(bodyLen), sizeof(bodyLen) - 1, "%d", out->len) < 0) {
+        HI_ASSERT(0);
+    }
+    HttpHdrsAdd(rspHdrs, HH_CONTENT_LENGTH, -1, bodyLen, -1);
+
+    // write response (hdrs + body)
+    // NOTE: 不能delete out，其由HttpReq负责释放
+    res = HttpReqWriteRsp(self, rspHdrs, out);
+    HttpHdrsDelete(rspHdrs);
+    if (res < 0) {
+        LOGE("HttpReqWriteRsp FAIL, err=%d\n", res);
+        return res;
+    }
+    return 0;
+}
+
+/**
+    获得请求入参.
+*/
+const char* RapiReqInData(HttpReq* self, int* len)
+{
+    MemBlk *body = NULL;
+
+    if (HttpReqReqBody(self, &body) < 0) { // req body freed
+        if (len) {
+            *len = 0;
+        }
+        return NULL;
+    }
+
+    HI_ASSERT(body);
+    if (len) {
+        *len = body->len;
+    }
+    return (char*)body->data;
+}
+
+/**
+    init HttpReq.
+
+    在此函数中判断请求的相关信息是否符合rapi的约定，不符合的，则返回错误。
+    由调用者负责发送错误响应?
+*/
+int RapiReqInit(HttpReq* self)
+{
+    HI_ASSERT(self);
+    HttpHdrs *hdrs = NULL;
+    const char *hval = NULL;
+
+    hdrs = HttpReqReqHdrs(self);
+    HI_ASSERT(hdrs);
+
+    // 检查method, RAPI只支持POST
+    hval = HttpHdrsFind(hdrs, HH_METHOD, NULL);
+    if (!hval || HiStricmp(hval, HM_POST) != 0) {
+        return -1;
+    }
+
+    // 检查content-type
+    hval = HttpHdrsFind(hdrs, HH_CONTENT_TYPE, NULL);
+    if (!hval || !HiStristr(hval, HCT_RAPI)) {
+        return -1;
+    }
+    // 检查accept是否含有指定的格式
+    hval = HttpHdrsFind(hdrs, HH_ACCEPT, NULL);
+    if (!hval || (!HiStristr(hval, HCT_RAPI) && !strstr(hval, "*"))) {
+        return -1;
+    }
+
+    // 设置flags，以用一个buf保存req body
+    HttpReqAddFlag(self, HRF_REQ_BODY_ONE);
+    return 0;
+}
+
diff -urpBN hiopenais/src/lite_http/http_rapi.h hiopenais_modify/src/lite_http/http_rapi.h
--- hiopenais/src/lite_http/http_rapi.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/lite_http/http_rapi.h	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HTTP_RAPI_H
+#define HTTP_RAPI_H
+
+#include "hi_misc_util.h"
+#include "http_def.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    @mainpage
+
+    RapiReq表示一次远程调用。目前定义的是简单模型，
+    rapi的输入参数一次性获得，输出参数也一次性给出。
+
+    user在收到rapi请求，完成处理后，调用RapiReq_reply()回复client。
+    回复后，当次rapi请求即告完成。
+
+    RapiReq实例从HttpReq实例扩展(派生)，由RapiReqInit()完成扩展。
+    通常，RapiReqInit()由分发器负责调用。
+*/
+#ifndef API_DESC_PAD
+#define API_DESC_PAD
+#endif
+
+/**
+    RapiReq对象类型声明.
+    RapiReq扩展由HttpReq对象的扩展成员表示，对外透明。
+*/
+typedef struct HttpReq RapiReq;
+
+/**
+    reply rapi.
+
+    user完成rapi请求后，调用此函数设置设置出参，并发送响应。
+    @note: 对每个RapiReq，user只能调用一次该函数。
+
+    @func replyx()为no-copy版本，user调用MemBlk_new()创建buf，填充buf，调用此函数。
+    无论replyx()是否返回错误，out均由replyx()负责释放，user不应再引用，也不能将其释放。
+
+    @demo replyx()
+        MemBlk *out = MemBlkNew(1024);
+        out->buf[i] = xxx; // fill out->buf
+        out->len = xxx; // set data len
+        RapiReqReply2(req, out);
+        // NOTE: user不应再引用out，也不能将其释放
+
+    @param outData: 出参数据。
+    @param outLen: outData string len。可置为-1。
+    @param out: 出参数据。
+
+    @return: 成功则返回0，否则返回负数。
+*/
+int RapiReqReply(RapiReq* self, const char* outData, int outLen);
+int RapiReqReply2(RapiReq* self, MemBlk* outData);
+
+/**
+    获得请求入参.
+
+    返回对象维持的入参数据的指针。其指向的地址在@func freeReq()被调用前均有效。
+
+    @param len: 返回入参数据字节长度。置为NULL表示不返回入参长度。
+    @return 返回对象维持的入参数据数据地址。返回NULL表示入参数据已被freeReq()释放。
+*/
+const char* RapiReqInData(RapiReq* self, int* len);
+
+/**
+    初始化RapiReq.
+
+    此函数相当于RapiReq的构造函数，从HttpReq对象派生RapiReq对象。
+    仅供分发器使用，user不应调用。
+*/
+int RapiReqInit(RapiReq* self);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // HTTP_RAPI_H
diff -urpBN hiopenais/src/lite_http/http_req.h hiopenais_modify/src/lite_http/http_req.h
--- hiopenais/src/lite_http/http_req.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/lite_http/http_req.h	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,289 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HTTP_REQ_H
+#define HTTP_REQ_H
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "hi_ext_util.h"
+#include "http_hdrs.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    @mainpage
+
+    HttpReq表示一次http请求。
+
+    HttpReq由http server负责创建，user不能直接构造。server收齐client发送的req headers后，
+    创建HttpReq，并提交给user。提交方式由server定义。
+
+    user可通过HttpReq获得req headers, req body，write rsp (headers, body)。
+
+    HttpReq是全功能版本，可支持小数据请求，大数据请求。请求可快速完成，也可持续任意时间。
+    RapiReq, SseReq均基于HttpReq实现。
+
+    user读写req/rsp body数据时，可以选择阻塞或异步模式。当user创建服务线程来处理请求时，
+    一般选择阻塞模式，否则user一般选择异步模式，监听readFd/writeFd产生信号。
+*/
+#ifndef API_DESC_PAD
+#define API_DESC_PAD
+#endif
+
+/**
+    HttpReq对象类型声明.
+*/
+typedef struct HttpReq HttpReq;
+
+/**
+    http请求handler.
+*/
+typedef int (*HttpReqProc)(void* user, HttpReq* req);
+
+/**
+    HttpReq对象扩展处理函数类型.
+*/
+typedef int (*HttpReqExt)(HttpReq* req);
+
+/**
+    HttpReq status.
+*/
+#define HRS_REQ_HDRS_END        HI_BIT0 // request headers已收齐
+#define HRS_REQ_BODY_END        HI_BIT1 // request body已收齐
+#define HRS_RSP_HDRS_END        HI_BIT2 // user提交完response headers
+#define HRS_RSP_BODY_END        HI_BIT3 // user提交完response body，无body时，在hdrs提交完时视body提交完
+// #define HRS_RSP_TRAN_END     HI_BIT4 // 所有response数据已传输完成 (提交给OS)
+#define HRS_LOC_RESET           HI_BIT5 // 请求被本端user reset，即发出了RST frame
+#define HRS_PEER_RESET          HI_BIT6 // 请求被对端reset，即收到了RST frame
+#define HRS_CLOSED              HI_BIT7 // 无论是本端发起，还是对端发起，request最终closed
+
+/**
+    HttpReq flags.
+*/
+#define HRF_REQ_BODY_ONE        HI_BIT0 // 将req body保存为一个整块
+
+/**
+    获取request header.
+*/
+HttpHdrs* HttpReqReqHdrs(HttpReq* self);
+
+/**
+    返回请求的method header.
+*/
+const char* HttpReqReqMethod(HttpReq* self);
+
+/**
+    返回请求的path header.
+*/
+const char* HttpReqReqPath(HttpReq* self);
+
+/**
+    返回请求的query list.
+
+    query list是PATH中'?'之后的部分。
+
+    @return: 返回query list，请求中没有query list时，返回NULL。
+*/
+const char* HttpReqQueryList(HttpReq* self);
+
+/**
+    获取request body [protected].
+
+    当req body收齐后，user可调用此函数获取HttpReq内部保存的body。
+    @note: 此函数供HttpReq派生对象使用，user不应调用此函数。
+
+    @param body: 返回HttpReq保存的request body。
+    @return: 成功则返回0，否则返回负数。
+*/
+int HttpReqReqBody(HttpReq* self, MemBlk** body);
+
+/**
+    读取request body.
+
+    此函数每次返回一块收到的数据。通过@param end指示body是否读取完成。
+
+    线程模型，见@mainpage。
+
+    @param data: 返回一个chunk。
+    @param async: 是否为异步操作模式。
+
+    @return: 成功则返回收到的chunk的字节长度，可为0，否则返回负数。
+*/
+int HttpReqReadBody(HttpReq* self, MemBlk** data, bool async);
+
+/**
+    write response header.
+
+    user组织好rsp header后，调用此函数。对于一个HttpReq，user只能调用一次该函数。
+    线程模型，见@mainpage。
+
+    @param rspHdrs: rsp header。
+    @param rspEnd: rsp是否结束。当rsp无body时，应置其为end。
+
+    @return: 成功则返回0，否则返回负数。
+*/
+int HttpReqWriteHdrs(HttpReq* self, const HttpHdrs* rspHdrs, bool rspEnd);
+
+/**
+    write response body.
+
+    user调用此函数向client发送rsp body。每次发送一块数据。通过@param end指示body是否发送完成。
+    线程模型，见@mainpage。
+
+    @param data: chunk data。
+    @param end: 指示body是否发送完成。
+    @param async: 是否为异步操作模式。
+
+    @return: 成功则返回成功发送的字节数，可能<len，否则返回负数。
+*/
+int HttpReqWriteBody(HttpReq* self, MemBlk* data, bool end, bool async);
+
+/**
+    write full response.
+
+    相当于顺序执行writeHdrs(end=false), writeBody(end=true, async=true)。
+*/
+int HttpReqWriteRsp(HttpReq* self, const HttpHdrs* hdrs, MemBlk* body);
+
+/**
+    返回HttpReq关联的readFd.
+
+    当有reqBody数据达到时，@param readFd会有信号，user可监视该fd。
+    HttpReq目前实现为按需创建readFd，当user调用此函数时，其才会被创建。
+*/
+int HttpReqReadFd(HttpReq* self);
+
+/**
+    返回HttpReq关联的writeFd.
+
+    当有rspBody发送缓冲可用时，@param writeFd会有信号，user可监视该fd。
+    HttpReq目前实现为按需创建writeFd，当user调用此函数时，其才会被创建。
+*/
+int HttpReqWriteFd(HttpReq* self);
+
+/**
+    返回HttpReq关联的closeFd.
+
+    当有HttpReq被对端reset/close时，@param closeFd会有信号，user可监视该fd。
+    HttpReq目前实现为按需创建closeFd，当user调用此函数时，其才会被创建。
+*/
+int HttpReqCloseFd(HttpReq* self);
+
+/**
+    释放请求数据.
+
+    释放req hdrs和req body。
+*/
+void HttpReqFreeReq(HttpReq* self);
+
+/**
+    获得HttpReq的当前状态.
+*/
+uint32_t HttpReqStatus(HttpReq* self);
+
+/**
+    reset.
+*/
+int HttpReqReset(HttpReq* self, int reason);
+
+/**
+    设置附加对象 [protected].
+
+    相当于派生HttpReq类。
+    @note: 此函数供HttpReq派生对象使用，user不应调用此函数。
+
+    可附加destroy函数，当HttpReq销毁时，会执行该destroy()函数销毁附加对象。
+    设置@param obj为NULL表示去除附加对象。
+*/
+void HttpReqSetExt(HttpReq* self, void* obj, void(*destroy)(void* obj));
+
+/**
+    获取附加对象 [protected].
+
+    @note: 此函数供HttpReq派生对象使用，user不应调用此函数。
+*/
+void* HttpReqGetExt(HttpReq* self);
+
+/**
+    clear flags [protected].
+*/
+uint32_t HttpReqClearFlag(HttpReq* self, uint32_t flags);
+
+/**
+    add flags [protected].
+*/
+uint32_t HttpReqAddFlag(HttpReq* self, uint32_t flags);
+
+/**
+    对象引用计数加一.
+
+    @return 增加后的计数，但其值仅供参考，user不得使用返回值。
+*/
+int HttpReqAddRef(HttpReq* self);
+
+/**
+    对象引用计数减一.
+
+    当user不在引用对象时，应调用此函数。否则会出现内存泄漏。
+    返回值仅供参考，user不必关心。
+
+    @return 删除引用后对象的参考引用计数。为0表示对象已被销毁。
+*/
+int HttpReqDelRef(HttpReq* self);
+
+/**
+    查询ReqBody是否已经收齐.
+*/
+bool HttpReqReqBodyEnd(HttpReq* self);
+
+/**
+    查询ReqBody是否为NULL.
+*/
+bool HttpReqReqBodyEmpty(HttpReq* self);
+
+/**
+    注册/注销onBodyEnd事件handler.
+
+    当req body收齐，会回调@param onBodyEnd函数。
+
+    @note: 调用此函数时，req body已收齐，则会在此函数中直接回调@param onBodyEnd。
+    @note: onBodyEnd()回调由底层分发线程调用，user负责线程安全。
+
+    @param onBodyEnd: handler。置为NULL，表示注销。
+*/
+bool HttpReqSetOnBodyEnd(HttpReq* self, HttpReqProc onBodyEnd, void* user);
+
+/**
+    设置/获取附加处理器.
+
+    HttpReq提供了便于分发器等使用的附加存储。
+    HttpReq对此不做任何解释，也不会使用，只提供set/get接口。
+*/
+void HttpReqSetAttachProc(HttpReq* self, HttpReqProc proc, void* user, int flags);
+void HttpReqGetAttachProc(HttpReq* self, HttpReqProc* proc, void** user, int* flags);
+
+/**
+    发送简单响应，完成http请求.
+*/
+int HttpReqSimpleRsp(HttpReq* req, const char* status);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // HTTP_REQ_H
diff -urpBN hiopenais/src/lite_http/http_sse.c hiopenais_modify/src/lite_http/http_sse.c
--- hiopenais/src/lite_http/http_sse.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/lite_http/http_sse.c	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,251 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "http_sse.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "hi_ext_util.h"
+#include "http_req.h"
+#include "http_def.h"
+
+#define LEN_EXTRA     7
+#define DATA_BYTES    6
+#define LEN_OFFSET    6
+#define EVTNAME_BUFLEN_OFFSET           8
+#define EVTID_BUFLEN_OFFSET             5
+#define EVTID_BUFLEN_OFFSET_INT32MAX    16
+#define LINENUM_MULTIPLY                7
+
+/**
+    编码sse消息.
+*/
+static int SseReqEnc(MemBlk *blk, int32_t evtId, const char* evtName, const char* evtData)
+{
+    char *buf = (char*)blk->data;
+    int bufLen = blk->size;
+    int len = 0;
+
+    if (evtName && *evtName) { // event
+        len += snprintf_s(buf + len, bufLen - len, bufLen - len - 1, "event: %s\n", evtName);
+    }
+    if (evtId >= 0) { // id
+        len += snprintf_s(buf + len, bufLen - len, bufLen - len - 1, "id: %d\n", (int)evtId);
+    }
+
+    if (evtData && *evtData) { // data，为每行添加<data: >前缀
+        const char *lines = evtData;
+        const char *line;
+        int lineLen;
+        while ((line = HiStrtokx(&lines, "\r\n", &lineLen)) != NULL) {
+            HI_ASSERT(lineLen >= 0);
+            HI_ASSERT(len + lineLen + LEN_EXTRA < bufLen);
+            if (memcpy_s(buf + len, bufLen - len, "data: ", DATA_BYTES) != EOK) { // line prefix
+                HI_ASSERT(0);
+            }
+            len += LEN_OFFSET;
+            if (lineLen > 0) { // line content
+                int sret = memcpy_s(buf + len, bufLen - len, line, lineLen);
+                HI_ASSERT(sret == EOK);
+                len += lineLen;
+            }
+            buf[len] = '\n'; // <LF>
+            len++;
+        }
+    }
+
+    buf[len++] = '\n'; // 标识消息结束的最末<LF>
+    HI_ASSERT(len + 1 < bufLen); // 没有处理错误时，编码的消息不应充满buf
+    blk->len = len;
+    return len;
+}
+
+/**
+    向client push一条event.
+
+    此函数实现SSE协议的server端事件encode。
+
+    @note: 目前未校验evtData是否为空。后续可斟酌是否处理。要校验比较嗦，涉及到evtName
+    是否存在，是否为默认消息名，是否存在evtId等。需要仔细阅读协议的限制。
+*/
+int SseReqPush(SseReq* self, int32_t evtId,
+    const char* evtName, const char* evtData, int evtLen)
+{
+    HI_ASSERT(self);
+    int res;
+
+    // 校验evtName，不能含有'\r\n'
+    char *ret = NULL;
+    if (evtName != NULL) {
+        ret = strpbrk(evtName, "\r\n");
+    }
+    HI_ASSERT(ret == NULL);
+    HI_ASSERT(evtId >= 0 || (evtName && *evtName) || (evtData && *evtData));
+
+    // NOTE: 不需要校验HttpReq状态，HttpReq会处理 ...
+    LOGD("HTTP: sse push, id=%d, name='%s', len=%d ...\n", (int)evtId, evtName ? evtName : "", evtLen);
+
+    // 调整evtData和evtLen，以简化后续处理
+    if (evtLen < 0) {
+        evtLen = evtData ? strlen(evtData) : 0;
+    } else {
+        HI_ASSERT(evtData);
+    }
+    evtData = evtData ? evtData : "";
+
+    // 计算容纳消息体的长度需求 ...
+    int bufLen = evtLen; // msg buf的长度
+    if (evtName && *evtName) { // event
+        bufLen += EVTNAME_BUFLEN_OFFSET; // 'event:<sp>\n'
+        bufLen += strlen(evtName);
+    }
+    if (evtId >= 0) { // id
+        bufLen += EVTID_BUFLEN_OFFSET; // 'id:<sp>\n'
+        bufLen += EVTID_BUFLEN_OFFSET_INT32MAX; // int32 max
+    }
+    if (evtLen > 0) { // data
+        int lineNum = HiStrchrc(evtData, '\n') + 1;
+        bufLen += lineNum * LINENUM_MULTIPLY; // lineNum * ('data:<sp>\n')
+    }
+
+    // 当编码不出消息时，说明参数传入错误
+    HI_ASSERT(bufLen > 0);
+    HI_EXP_RET(!bufLen, -1, "param err\n");
+    bufLen += sizeof(uint32_t); // 末尾<LF>及0终结符，及多2个保留字符空间
+
+    // 分配buf，编码消息 ...
+    MemBlk* blk = MemBlkNew(bufLen); // ensure by xiao
+    HI_ASSERT(blk);
+    int len = SseReqEnc(blk, evtId, evtName, evtData);
+    HI_ASSERT(len > 0);
+
+    // write response body
+    res = HttpReqWriteBody(self, blk, false, true);
+
+    return res < 0 ? res : len;
+}
+
+/**
+    响应请求.
+*/
+int SseReqReply(SseReq* self, int code)
+{
+    HttpHdrs *rspHdrs = NULL;
+    char codeStr[TINY_BUF_SIZE];
+    int res;
+
+    // NOTE: 不需要校验HttpReq状态，HttpReq会处理 ...
+    if (snprintf_s(codeStr, sizeof(codeStr), sizeof(codeStr) - 1, "%s", (code < 0 ? "404" : "200")) < 0) {
+        HI_ASSERT(0);
+    }
+    LOGI("HTTP: sse reply, code={%d, %s} ...\n", code, codeStr);
+
+    // 组织rsp headers
+    rspHdrs = HttpHdrsNew(0);
+    HI_ASSERT(rspHdrs);
+    HttpHdrsAdd(rspHdrs, HH_STATUS, -1, codeStr, -1);
+    if (code == 0) {
+        HttpHdrsAdd(rspHdrs, HH_CONTENT_TYPE, -1, HCT_SSE, -1);
+    }
+
+    // write response headers
+    res = HttpReqWriteHdrs(self, rspHdrs, false);
+    HttpHdrsDelete(rspHdrs);
+    return res;
+}
+
+/**
+    请求终止sse会话.
+*/
+int SseReqClose(SseReq* self, int reason)
+{
+    uint32_t status;
+
+    // 错误关闭，则reset
+    if (reason < 0) {
+        LOGW("sse close, reset for reason=%d\n", reason);
+        return HttpReqReset(self, reason);
+    }
+
+    // 若还没有reply，则reset
+    status = HttpReqStatus(self);
+    if (!(status & HRS_RSP_HDRS_END)) {
+        LOGW("sse close, reset for not reply before\n");
+        return HttpReqReset(self, reason);
+    }
+
+    // 正常关闭, 发送EOB ...
+    LOGI("HTTP: sse close, tx EOB\n");
+    return HttpReqWriteBody(self, NULL, true, true);
+}
+
+/**
+    获取sse请求中携带的last-evt-id.
+    @note: 不需要校验状态。
+*/
+int32_t SseReqLastEvtId(SseReq* self)
+{
+    HI_ASSERT(self);
+    HttpHdrs *hdrs = NULL;
+    const char *hval = NULL;
+
+    hdrs = HttpReqReqHdrs(self);
+    if (!hdrs) { // HttpReq_freeIn()会删除req hdrs
+        LOGE("req hdrs freed by freeReq()\n");
+        return -1;
+    }
+
+    // 从hdrs中获取last-evt-id
+    hval = HttpHdrsFind(hdrs, HH_LAST_EVT_ID, NULL);
+    if (!hval || !*hval) { // client未提供，非错误
+        return -1;
+    }
+    return atoi(hval);
+}
+
+/**
+    init SseReq.
+
+    在此函数中判断请求的相关信息是否符合rapi的约定，不符合的，则返回错误。
+    由调用者负责发送错误响应?
+*/
+int SseReqInit(SseReq* self)
+{
+    HI_ASSERT(self);
+    HttpHdrs *hdrs = NULL;
+    const char *hval = NULL;
+
+    hdrs = HttpReqReqHdrs(self);
+    HI_ASSERT(hdrs);
+
+    // 检查method, SSE只支持GET
+    hval = HttpHdrsFind(hdrs, HH_METHOD, NULL);
+    if (!hval || HiStricmp(hval, HM_GET) != 0) {
+        LOGE("sse init FAIL, for not GET\n");
+        return -1;
+    }
+    // 检查accept是否含有指定的格式
+    hval = HttpHdrsFind(hdrs, HH_ACCEPT, NULL);
+    if (!hval || !HiStristr(hval, HCT_SSE)) {
+        LOGE("sse init FAIL, for accept mismatch\n");
+        return -1;
+    }
+
+    // 扩展SseReq ...
+    return 0;
+}
+
diff -urpBN hiopenais/src/lite_http/http_sse.h hiopenais_modify/src/lite_http/http_sse.h
--- hiopenais/src/lite_http/http_sse.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/lite_http/http_sse.h	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HTTP_SSE_H
+#define HTTP_SSE_H
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    @mainpage
+
+    SseReq表示一个server sent event请求。该请求可持续任意长度的时间，可视为push会话。
+    user可通过SseReq接口向client push event。
+
+    SseReq实例从HttpReq实例扩展(派生)，由SseReqInit()完成扩展。
+    通常，SseReqInit()由分发器负责调用。
+*/
+#ifndef API_DESC_PAD
+#define API_DESC_PAD
+#endif
+
+/**
+    SseReq对象类型声明.
+    SseReq扩展由HttpReq对象的扩展成员表示，对外透明。
+*/
+typedef struct HttpReq SseReq;
+
+/**
+    向client push一条event.
+
+    此函数只是将event写入底层发送缓冲，不会阻塞。
+    此函数线程安全，可由任意线程调用。
+
+    @note: 当底层发送缓冲满时，此函数会返回-EAGAIN。由user确定后续是否继续发送。
+    当底层发送缓冲有空时，目前未提供事件通知机制。将来会优化。
+
+    @param evtId: 事件的id，置为-1表示无id。
+    @param evtName: 事件名，置为NULL表示用默认名称，即"message"。
+    @param evtData: 事件体，string。可为NULL，表示无事件体。
+    @param evtLen: evtData的string len，可置为-1。
+    @param flags: 保留，置为0。
+
+    @return: 成功则返回0，否则返回负值。其中返回-EAGAIN表示发送缓冲满。
+*/
+int SseReqPush(SseReq* self, int32_t evtId,
+    const char* evtName, const char* evtData, int evtLen);
+
+/**
+    响应sse会话请求.
+
+    当user通过收到SseReq后，应调用此函数响应请求。但对每个请求，只能调用一次。
+    可在user实现的SseReqProc函数中调用此函数。
+
+    @param code: 为0表示接受，负数表示拒绝。拒绝码将来补充。
+    @return: 成功则返回0，否则返回负值。
+*/
+int SseReqReply(SseReq* self, int code);
+
+/**
+    请求终止sse会话.
+
+    当user希望终止sse会话时，应调用此函数。注意此函数与@func reply()不同。
+
+    @param reason: close原因，保留，置为0。
+    @return: 成功则返回0，否则返回负值。
+*/
+int SseReqClose(SseReq* self, int reason);
+
+/**
+    获取sse请求中携带的last-evt-id.
+
+    当底层连接异常断开时，client会自动重新建立到server的连接，并且在请求中给出
+    last-evt-id。server可向client push漏掉的event。不过这是可选的，取决于上层设计。
+    首次请求时，client请求中不会携带last-evt-id。
+
+    @return 返回client发来的last-evt-id。-1表示client未发送last-evt-id。
+*/
+int32_t SseReqLastEvtId(SseReq* self);
+
+/**
+    初始化SseReq.
+
+    此函数相当于SseReq的构造函数，从HttpReq对象扩展(派生)SseReq对象。
+    仅供分发器使用，user不应调用。
+*/
+int SseReqInit(SseReq* self);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // HTTP_SSE_H
diff -urpBN hiopenais/src/lite_http/http_svr.c hiopenais_modify/src/lite_http/http_svr.c
--- hiopenais/src/lite_http/http_svr.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/lite_http/http_svr.c	2021-03-29 20:42:34.000000000 -0700
@@ -0,0 +1,2500 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <limits.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <linux/tcp.h>
+
+#include <openssl/ssl.h>
+#include <openssl/err.h>
+#include <openssl/conf.h>
+#include <nghttp2/nghttp2.h>
+
+#include "hi_ext_util.h"
+#include "http_util.h"
+#include "http_hdrs.h"
+#include "http_req.h"
+#include "http_svr.h"
+
+/**
+    @mainpage
+
+    一个HttpSvr代表一个HTTP2 server，监听一个TCP端口。有连接到达时，为每一个TCP连接创建
+    一个HttpSess。HttpSvr同时会记录每一个未关闭的HttpSess。
+
+    一个HttpSess代表一个HTTP2 session，与一个TCP连接对应。一个HttpSess可同时承载多个
+    HttpReq。HttpSess会维持和管理未被destroy的HttpReq。当对应的TCP连接断开后，HttpSess
+    会close并旗下所有HttpReq，并解除对它们的引用。
+
+    一个HttpReq代表一个HTTP2 request。由HttpSess负责创建。由HttpSvr负责将其提交给user。
+
+    由于HttpReq对象会提交给user处理，HttpReq维持了引用计数，当user完成HttpReq的处理后，
+    应调用HttpReqDelRef()解除对HttpReq的引用。同时HttpReq所属HttpSess也会建立对HttpReq
+    的引用，当检测到client close/reset的HttpReq时，HttpSess会关闭HttpReq，并解除对
+    HttpReq的引用。当对HttpReq的所有引用都解除(计数值变为0)时，HttpReq会destroy self。
+
+    HttpSess也维持了引用计数，旗下所有HttpReq均会建立对它的引用，HttpReq被destroy后，会
+    解除对它的引用。HttpSvr也会建立对HttpSess的引用，当HttpSess断开或reset，或底层TCP连接
+    断开，HttpSess将会被HttpSvr从其维持的表格中删除，并解除引用。当对HttpSess的所有引用
+    均解除后(计数值变为0)，HttpSess会destroy self。
+
+    HttpSvr提供了HttpReq孤儿检测机制，当HttpSess检测到HttpReq被对端close/reset时，会将其
+    从HttpSess容器中删除，并添加到HttpSvr的孤儿列表(reqList)中，同时解除对其的引用。参见
+    @function HttpSessCloseOne。当HttpReq被destroy时，会从HttpSvr的孤儿列表中将自身删除。
+    当HttpSvr销毁时，如果孤儿列表中存在HttpReq，则说明有HttpReq未被user解除引用，属于资源
+    泄漏，user应检查其代码。HttpSvr会trace出所有孤儿HttpReq 。
+
+    HttpSvr未提供对HttpSess的直接孤儿检测。实际上HttpSess并不与user直接交互，HttpSvr能确保
+    在stop时会将其close。而HttpReq会引用HttpSess，因此HttpSess的泄漏只有一种可能，即HttpReq
+    泄漏，只要无HttpReq泄漏，则HttpSess也不会泄漏。HttpSvr的对应实现错误则有底层的heap
+    泄漏检测机制暴露。
+
+    HttpSvr与HttpSess为一对多的关系，HttpSess与HttpReq也是一对多的关系。HttpSvr与HttpReq无
+    直接关系，HttpSvr中维持的reqList只是孤儿列表。
+
+    不引起歧义时，HttpSvr,HttpSess,HttpReq也常统称为HttpSvr。
+
+    目前设计为仅由一个线程来驱动(服务)整个HttpSvr。用EvtMon来监视TCP，及user触发的事件。
+
+    HttpSvr提供的API是线程安全的，而user的调用可能来自多个线程，因此HttpSvr要做线程加锁保护。
+    由于整个HttpSvr仅由一个服务线程来驱动，只用一个互斥不会造成性能的过大损失。但目前采用的是
+    HttpSess级的互斥，相对于整个HttpSvr用一个互斥，存在一些微妙的差异，user调用可获得更高性能。
+    例如，当驱动线程正在处理HttpSess[i]时，user对其他HttpSess(通过HttpReq)的访问可以不用与
+    驱动线程竞争锁，可以更快获得响应。
+
+    user通过HttpReq发送响应时，为避免由user线程直接执行到nghttp2的代码中(由于有锁保护，要这样
+    处理也不会有问题)，HttpSess中引入了userEvt的事件感知器，HttpReq发送响应的API中，在将数据
+    存储到发送队列中后，会notify userEvt，驱动线程监视到userEvt有信号后再执行(由驱动线程执行)。
+
+    HttpReq支持阻塞/异步方式读写body。为此引入readFd, writeFd，user可监视它们，当其有信号时，
+    再执行实际的读写操作，以在user代码中实现异步操作。user以阻塞方式读写HttpReq时也会用到
+    readFd, writeFd，会在HttpReq的读写接口中等待它们有信号。
+
+    多数应用场景下，user往往会在HttpReq收齐req body后才会收到server提交的HttpReq，此时req body
+    已经准备好，user可直接获取。发送rsp body时，典型场景也是user提供一个完整的body。这种典型
+    的场景做了更高层的抽象RapiReq。对于这种情况，是不需要readFd, writeFd的，因此HttpReq设计
+    为按需创建readFd, writeFd。可替身性能，减小资源需求。
+
+    HttpSvr只会向user提交HttpReq，而不会做多路复用处理(mux)，这一般由更上层的server来实现，
+    其会根据用户注册的URL和处理器来将HttpReq分发给具体的处理器。
+
+    为简化实现，降低复杂度，对HttpReq, HttpSess的destroy都统一由驱动线程负责。为此引入了
+    destroyChn，当触发destroy的不是驱动线程时，会向destroyChn发送DestroyMethod事件，驱动线程
+    监听并读取到destroyChn的事件后，在执行实际的destroy处理。
+
+    对于HttpReq发送rsp body，本地流控方式为约定队列size，size是MemBlk对象的数量，而不管
+    实际的数据大小。当que满时，user的阻塞write将被阻塞，异步write将返回-EAGAIN。
+*/
+#define DESIGN_DESC_PAD
+
+/**
+    杂项常量.
+*/
+#define HREQ_TX_QUE_SIZE    3 // 发送队列的size，用于本地流控
+#define HSVR_LISTEN_QUE     10 // listen backlog
+
+/**
+    Destroy通用函数类型.
+*/
+typedef void (*DestroyFunc)(void* self);
+typedef struct DestroyMethod {
+    void *obj;
+    DestroyFunc func;
+}   DestroyMethod;
+
+/**
+    HttpReq数据成员
+*/
+struct HttpReq {
+    int refNum; // 引用计数
+    struct list_head lnode; // HttpReq作为链表节点
+    struct HttpSess *sess; // this所属的HttpSess
+    struct HttpSvr *svr; // this所属的HttpSvr
+
+    uint32_t status; // 请求的当前状态
+    uint32_t flags; // control flags
+
+    HttpHdrs *reqHdrs; // 接收到的req hdrs
+    const char* reqPath; // reqHdrs(':path')引用
+    char reqMethod[HTTP_METHOD_MAX]; // ':method'
+    int64_t reqCtLen; // req content-length
+
+    struct list_head reqDatas; // 收到的req data chunk list
+    struct list_head rspDatas; // 待发送的rsp data chunk list
+    int reqDataNum; // reqDatas中的chunk数
+    int rspDataNum; // reqDatas中的chunk数
+
+    MemBlk *reqFullBody; // 正在接收的完整body，仅在收齐需求时，在收齐前使用，收齐后移到reqDatas中
+
+    bool txPaused; // 发送body data被挂起，等待新的user数据达到
+    int txDataEvt; // 用于唤醒发送线程的事件
+    int rxDataEvt; // 用于唤醒接收线程的事件
+    int closeEvt; // 指示请求已closed的事件
+
+    int ngStrmId; // H2 stream id
+    nghttp2_session *ngSess; // 与tcp连接绑定的sess
+
+    void *onBodyEndUser; // onBodyEnd事件接收者
+    HttpReqProc onBodyEndProc; // onBodyEnd事件处理函数
+
+    HttpReqProc attachProc; // 附件处理器
+    void* attachUser; // 附件user
+    int attachFlags; // 附件flags
+
+    void *extObj; // 附加对象
+    void (*extFree)(void*); // extObj destroy func
+};
+
+/**
+    HttpSess数据成员.
+*/
+typedef struct HttpSess {
+    int refNum; // 引用计数，旗下的HttpReq会引用它，以确定其是否可destroy
+    struct list_head lnode; // 作为链表节点
+    pthread_mutex_t mutex; // nglib sess线程不安全，且要与user，需要锁保护
+    pthread_t thrdId; // 驱动线程的ID
+    HttpSvr *svr; // owner http server
+
+    SSL *ssl; // 对应的SSL句柄，通过它读写加密数据
+    int sock; // 对应的TCP socket
+    uint64_t rxBytes; // 接收到的总字节数
+    char cltAddr[IP_STR_BUF_SIZE]; // client ip:port
+
+    nghttp2_session *ngSess; // 对应的nghttps session
+    int userEvt; // event of user
+
+    struct list_head reqList; // HttpReq list
+    int reqNum; // HttpReq number in reqList
+}   HttpSess;
+
+/**
+    HttpSvr数据成员.
+*/
+struct HttpSvr {
+    EvtMon *evtm; // the EvtMon depended
+    pthread_t thrdId; // 驱动线程的ID
+
+    SSL_CTX *sslCtx; // open ssl context
+    int listenFd; // listen socket
+
+    struct list_head sessList; // HttpSess list
+    int sessNum; // sess number in sessList
+
+    struct list_head reqList; // HttpReq孤儿list
+    int reqNum; // HttpReq number in reqList
+
+    HttpReqProc onReqProc; // req handler proc
+    void* onReqUser; // req handler user
+
+    SkPair destroyChn; // 传输DestroyMethod事件的chn，用于destroy HttpReq, HttpSess
+};
+
+/**************************************************************************************************
+    HttpReq
+**************************************************************************************************/
+#define SP_HTTP_UTIL
+
+/**
+    用常量字符串生成nglib nv.
+*/
+#define MAKE_NG_NV(NAME, VALUE) \
+    { (uint8_t *)(NAME), (uint8_t *)(VALUE), sizeof(NAME) - 1, sizeof(VALUE) - 1, NGHTTP2_NV_FLAG_NONE }
+
+/**
+    server自身添加的外headers.
+*/
+static const nghttp2_nv G_SVR_EXT_HDRS[] = {
+    MAKE_NG_NV("Access-Control-Allow-Origin", "*"), // 允许跨域访问
+    MAKE_NG_NV("Cache-Control", "no-cache, no-store, must-revalidate"), // 禁止缓存
+};
+
+/**
+    将HttpHdrs转换为nghttp_nva.
+*/
+static int HdrsToNg2(const HttpHdrs* hdrs, nghttp2_nv** nvaOut)
+{
+    static const int extHdrNum = HI_ARRAY_SIZE(G_SVR_EXT_HDRS);
+    nghttp2_nv *nva = NULL;
+    uintptr_t it;
+    int num;
+    int i;
+
+    num = HttpHdrsSize(hdrs);
+    HI_ASSERT(num > 0);
+    num += extHdrNum; // 增加补充的headers数量
+    nva = (nghttp2_nv*)malloc(num * sizeof(*nva));
+    HI_ASSERT(nva);
+    if (memset_s(nva, (num * sizeof(*nva)), 0, (num * sizeof(*nva))) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    HttpHdrsEnumInit(hdrs, &it);
+    for (i = 0; HttpHdrsEnumNext(hdrs, &it,
+        (const char**)&nva[i].name, (int*)&nva[i].namelen,
+        (const char**)&nva[i].value, (int*)&nva[i].valuelen); i++) {
+    }
+    HI_ASSERT(i + extHdrNum == num);
+
+    // 补充额外的header
+    if (memcpy_s(&nva[i], (num - i) * sizeof(*nva), G_SVR_EXT_HDRS, extHdrNum * sizeof(*nva)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    *nvaOut = nva;
+    return num;
+}
+
+/**
+    alpn callback.
+*/
+static int OnSslAlpn(SSL *ssl,
+    const unsigned char **out, unsigned char *outlen,
+    const unsigned char *in, unsigned int inlen, void *arg)
+{
+    int res;
+
+    res = nghttp2_select_next_protocol((unsigned char **)out, outlen, in, inlen);
+    if (res != 1) {
+        LOGE("ALPN select prot FAIL, in data is\n");
+        HiDumpHex(in, inlen);
+        return SSL_TLSEXT_ERR_NOACK;
+    }
+    return SSL_TLSEXT_ERR_OK;
+}
+
+/* *
+    Create SSL_CTX.
+*/
+static SSL_CTX* CreateSslCtx(const char *keyFile, const char *certFile)
+{
+    SSL_CTX *sslCtx = NULL;
+    EC_KEY *ecdh = NULL;
+
+    sslCtx = SSL_CTX_new(SSLv23_server_method());
+    if (!sslCtx) {
+        LOGE("create SSL/TLS context FAIL, err='%s'\n", ERR_error_string(ERR_get_error(), NULL));
+        return NULL;
+    }
+
+    // 暂时删除了条件: | SSL_OP_CIPHER_SERVER_PREFERENCE
+    SSL_CTX_set_options(sslCtx,
+        SSL_OP_ALL | SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 |
+        SSL_OP_NO_COMPRESSION | SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION); // added on 2021.3.13
+
+    ecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
+    if (!ecdh) {
+        LOGE("EC_KEY_new_by_curv_name() FAIL, err='%s'\n", ERR_error_string(ERR_get_error(), NULL));
+        goto ERR_END;
+    }
+    SSL_CTX_set_tmp_ecdh(sslCtx, ecdh);
+    EC_KEY_free(ecdh);
+
+    if (SSL_CTX_use_PrivateKey_file(sslCtx, keyFile, SSL_FILETYPE_PEM) != 1) {
+        LOGE("read priv key file %s FAIL\n", keyFile);
+        goto ERR_END;
+    }
+    if (SSL_CTX_use_certificate_chain_file(sslCtx, certFile) != 1) {
+        LOGE("read cert file '%s' FAIL\n", certFile);
+        goto ERR_END;
+    }
+
+    // ALPN must
+#   if OPENSSL_VERSION_NUMBER >= 0x10002000L
+    SSL_CTX_set_alpn_select_cb(sslCtx, OnSslAlpn, NULL);
+#   else
+    HI_ASSERT(0); // 必须支持ALPN
+#   endif // OPENSSL_VERSION_NUMBER >= 0x10002000L
+    return sslCtx;
+
+    ERR_END:
+        if (sslCtx) {
+            SSL_CTX_free(sslCtx);
+        }
+        return NULL;
+}
+
+/**
+    创建SSL会话.
+*/
+static SSL* CreateSslSess(SSL_CTX* ctx, int fd)
+{
+    // create ssl sess
+    SSL *ssl = SSL_new(ctx);
+    if (!ssl) {
+        LOGE("create SSL/TLS sess FAIL, err='%s'\n", ERR_error_string(ERR_get_error(), NULL));
+        return NULL;
+    }
+    BIO *wbio = SSL_get_wbio(ssl);
+    BIO *rbio = SSL_get_rbio(ssl);
+    HI_ASSERT(!wbio && !rbio);
+
+    // 将fd关联到ssl中
+    BIO *bio = BIO_new_socket(fd, 0);
+    SSL_set_bio(ssl, bio, bio);
+    // 确认#Don't explode if we decide to realloc a chunk we're writing from in the output buffer
+    SSL_set_mode(ssl, SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);
+    SSL_set_accept_state(ssl);
+    int ret = SSL_is_server(ssl);
+    HI_ASSERT(ret);
+    return ssl;
+}
+
+/**************************************************************************************************
+    前向申明
+**************************************************************************************************/
+#define SP_HTTP_DECL
+
+/**
+    lock HttpSess.
+*/
+static inline void HttpSessLock(HttpSess* self)
+{
+    MutexLock(&self->mutex);
+}
+
+/**
+    unlock HttpSess.
+*/
+static inline void HttpSessUnlock(HttpSess* self)
+{
+    MutexUnlock(&self->mutex);
+}
+
+/**
+    其他HttpSess前向申明.
+*/
+static int HttpSessAddRef(HttpSess* self);
+static int HttpSessDelRef(HttpSess* self);
+
+/**
+    将HttpReq添加到孤儿列表中.
+    必然由驱动线程执行，无需加锁。
+*/
+static void HttpSvrAddReq(HttpSvr* self, HttpReq* req)
+{
+    list_add_tail(&req->lnode, &self->reqList);
+    self->reqNum++;
+    HI_ASSERT(self->reqNum > 0);
+}
+
+/**
+    将HttpReq从孤儿列表中删除.
+    必然由驱动线程执行，无需加锁。
+*/
+static void HttpSvrDelReq(HttpSvr* self, HttpReq* req)
+{
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->thrdId);
+    list_del(&req->lnode);
+    self->reqNum--;
+    HI_ASSERT(self->reqNum >= 0);
+}
+
+/**
+    其他HttpSvr前向申明.
+*/
+static void HttpSvrDelSess(HttpSvr* self, HttpSess* sess);
+
+/**************************************************************************************************
+    HttpReq
+**************************************************************************************************/
+#define SP_HTTP_REQ
+
+/**
+    判断该HttpReq是否已被user close.
+*/
+static inline bool HttpReqClosed(HttpReq* self)
+{
+    return self->status & HRS_CLOSED;
+}
+
+/**
+    判断该HttpReq是否已被底层reset.
+*/
+static inline bool HttpReqReseted(HttpReq* self)
+{
+    return self->status & (HRS_LOC_RESET | HRS_PEER_RESET);
+}
+
+/**
+    resume nghttp2 tx.
+*/
+static void HttpReqResumeTx(HttpReq* self, bool end)
+{
+    if (end) {
+        self->status |= HRS_RSP_BODY_END;
+    }
+
+    // 如果nglib发送数据被pause，则将其resume
+    if (self->txPaused) {
+        HI_ASSERT(self->ngSess);
+        nghttp2_stream *stream = nghttp2_session_find_stream(self->ngSess, self->ngStrmId); // need ensure
+        HI_ASSERT(stream);
+        int res = nghttp2_session_resume_data(self->ngSess, self->ngStrmId);
+        if (res < 0) {
+            LOGW("writeBody() RESUME tx FAIL, err='%d, %s'\n", res, nghttp2_strerror(res));
+        } else {
+            self->txPaused = false;
+            EventFdInc(self->sess->userEvt); // 唤醒驱动线程
+        }
+    }
+}
+
+/**
+    用多块buf存储reqBody的普通处理.
+*/
+static int HttpReqRxBodyNorm(HttpReq* self, const uint8_t *data, size_t len)
+{
+    MemBlk *blk = MemBlkNew(len + sizeof(uintptr_t)); // 保留空间用于写入0x00
+    HI_ASSERT(blk);
+    if (memcpy_s(blk->data, blk->size, data, len) != EOK) {
+        HI_ASSERT(0);
+    }
+    blk->len = len;
+    blk->data[blk->len] = 0;
+
+    // 理论上是不需要加锁的，因为readBody()会先成功dec信号量后才会读取reqDatas
+    HttpSessLock(self->sess);
+    list_add_tail(&blk->lnode, &self->reqDatas);
+    self->reqDataNum++;
+    HttpSessUnlock(self->sess);
+
+    if (self->rxDataEvt >= 0) {
+        LOGD("emit data-arrived evt\n");
+        EventFdInc(self->rxDataEvt);
+    }
+    return 0;
+}
+
+/**
+    用一块buf存储reqBody的特殊处理.
+*/
+static int HttpReqRxBodyOne(HttpReq* self, const uint8_t *data, size_t len)
+{
+    // 无full body buf时，create with content-length
+    if (!self->reqFullBody) {
+        if (self->reqCtLen <= 0) {
+            LOGW("onChunkRx() without content-length, reset strm\n");
+            HI_ASSERT(self->ngSess);
+            nghttp2_submit_rst_stream(self->ngSess, 0, self->ngStrmId, NGHTTP2_PROTOCOL_ERROR);
+            return 0;
+        }
+
+        self->reqFullBody = MemBlkNew(self->reqCtLen + sizeof(uintptr_t)); // 保留空间用于写入0x00
+        if (!self->reqFullBody) {
+            LOGE("alloc reqBody buf FAIL, content-length=%jd, reset strm\n", self->reqCtLen);
+            HI_ASSERT(self->ngSess);
+            nghttp2_submit_rst_stream(self->ngSess, 0, self->ngStrmId, NGHTTP2_PROTOCOL_ERROR);
+            return 0;
+        }
+        HI_ASSERT(self->reqFullBody);
+    }
+    MemBlk *blk = self->reqFullBody;
+
+    // cheak the size
+    if (len + blk->len > blk->size) {
+        LOGE("onChunkRx(), but total(%zu) > bufsize(%d)\n", len + blk->len, blk->size);
+        HI_ASSERT(self->ngSess);
+        nghttp2_submit_rst_stream(self->ngSess, 0, self->ngStrmId, NGHTTP2_PROTOCOL_ERROR);
+        return 0;
+    }
+
+    // copy chunk data to the blk
+    HI_ASSERT(blk->size > blk->len + len); // 须大于，而不能大于等于
+    if (memcpy_s(blk->data + blk->len, blk->size - blk->len, data, len) != EOK) {
+        HI_ASSERT(0);
+    }
+    blk->len += len;
+    blk->data[blk->len] = 0;
+
+    // 收齐后，将buf移动到reqDatas中
+    if ((int64_t)blk->len == self->reqCtLen) {
+        HttpSessLock(self->sess);
+        list_add_tail(&blk->lnode, &self->reqDatas);
+        self->reqDataNum++;
+        self->reqFullBody = NULL;
+        HttpSessUnlock(self->sess);
+
+        if (self->rxDataEvt >= 0) {
+            LOGD("emit data-arrived evt\n");
+            EventFdInc(self->rxDataEvt);
+        }
+    }
+
+    return 0;
+}
+
+/**
+    Called when nghttp2 library emits single header name/value pair.
+
+    @type nghttp2_on_header_callback().
+    set by nghttp2_session_callbacks_set_on_header_callback().
+*/
+static int HttpReqOnHdrRx(nghttp2_session *session, const nghttp2_frame *frame,
+    const uint8_t *name, size_t namelen, const uint8_t *value, size_t valuelen, uint8_t flags, void *userData)
+{
+    HttpReq *self = nghttp2_session_get_stream_user_data(session, frame->hd.stream_id);
+    HI_ASSERT(self);
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->sess->thrdId);
+
+    // For DATA and HEADERS frame, this callback may be called after on_stream_close_callback
+    if (HttpReqClosed(self)) {
+        LOGW("onHdrRx(), but strm closed by lib before%s, ignore\n", (self ? ", self=null" : ""));
+        return 0;
+    }
+
+    // 当user已请求reset，或已检测到对端reset时，discard该hdr
+    if (HttpReqReseted(self)) {
+        LOGW("onHdrRx(), but req RESET by %s before, discard\n",
+            (self->status | HRS_LOC_RESET) ? "usr" : "peer");
+        return 0;
+    }
+    // 容错处理，当req hdrs已经收齐时，discard该hdr
+    if (self->status & HRS_REQ_HDRS_END) {
+        LOGW("onHdrRx(), but all req hdrs rx before, discard\n");
+        return 0;
+    }
+
+    // 添加到reqHdrs
+    if (!self->reqHdrs) {
+        self->reqHdrs = HttpHdrsNew(0);
+        HI_ASSERT(self->reqHdrs);
+    }
+    if (!HttpHdrsAdd(self->reqHdrs, (const char*)name, namelen, (const char*)value, valuelen)) {
+        // 错误原因通常为name重复，忽略容错
+        LOGW("add hdr <%s: %s> FAIL, discard\n", name, value);
+        return 0;
+    }
+
+    // 特别处理content-type
+    if (HiStricmp((char*)name, HH_CONTENT_LENGTH) == 0) {
+        if (self->reqCtLen > 0) {
+            LOGW("detect repeat 'content-length', prev=%jd, new=%s\n", self->reqCtLen, value);
+        }
+        self->reqCtLen = atoll((char*)value);
+    } else if (!self->reqPath && HiStricmp((char*)name, HH_PATH) == 0) { // 特别处理:path
+        self->reqPath = HttpHdrsFind(self->reqHdrs, HH_PATH, NULL);
+        HI_ASSERT(self->reqPath);
+    } else if (!*self->reqMethod && HiStricmp((char*)name, HH_METHOD) == 0) { // 特别处理:method
+        HiStrxfrm(self->reqMethod, (char*)value, sizeof(self->reqMethod));
+    }
+    return 0;
+}
+
+/**
+    Callback function invoked when a chunk of data in DATA frame is received.
+
+    @note: 不应在此函数中通过flags的NGHTTP2_FLAG_END_STREAM来判断请求数据是否收齐，
+    而应在onFrmRx()中判断。
+
+    @type nghttp2_on_data_chunk_recv_callback().
+    set by nghttp2_session_callbacks_set_on_data_chunk_recv_callback().
+ */
+static int HttpReqOnChunkRx(nghttp2_session *session,
+    uint8_t flags, int32_t streamId, const uint8_t *data, size_t len, void *userData)
+{
+    HttpReq *self = (HttpReq*)nghttp2_session_get_stream_user_data(session, streamId);
+    HI_ASSERT(self);
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->sess->thrdId);
+
+    // For DATA and HEADERS frame, this callback may be called after on_stream_close_callback.
+    if (HttpReqClosed(self)) {
+        LOGW("onChunkRx(), but strm closed by lib before%s, ignore\n", (self ? ", self=null" : ""));
+        return 0;
+    }
+
+    // 当user已请求reset，或已检测到对端reset时，discard该chunk
+    if (HttpReqReseted(self)) {
+        LOGW("onChunkRx(), but req RESET by %s before, discard\n",
+            (self->status | HRS_LOC_RESET) ? "usr" : "peer");
+        return 0;
+    }
+
+    if (len == 0) {
+        LOGW("onChunkRx() with 0 size chunk, ignore\n");
+        return 0;
+    }
+
+    if (!(self->flags & HRF_REQ_BODY_ONE)) { // 常规处理，动态创建一块
+        return HttpReqRxBodyNorm(self, data, len);
+    } else { // 特别处理，用一块buf存储reqBody
+        int ret = list_empty(&self->reqDatas);
+        HI_ASSERT(self->reqDataNum == 0 && ret);
+        return HttpReqRxBodyOne(self, data, len);
+    }
+}
+
+/**
+ * Callback function invoked when the library wants to read data from
+ * the |source|.  The read data is sent in the stream |streamId|.
+ * The implementation of this function must read at most |length|
+ * bytes of data from |source| (or possibly other places) and store
+ * them in |buf| and return number of data stored in |buf|.  If EOF is
+ * reached, set :enum:`NGHTTP2_DATA_FLAG_EOF` flag in |*dataFlags|.
+ *
+ * If this callback is set by `nghttp2_submit_request()`,
+ * `nghttp2_submit_response()` or `nghttp2_submit_headers()` and
+ * `nghttp2_submit_data()` with flag parameter
+ * :enum:`NGHTTP2_FLAG_END_STREAM` set, and
+ * :enum:`NGHTTP2_DATA_FLAG_EOF` flag is set to |*dataFlags|, DATA
+ * frame will have END_STREAM flag set.  Usually, this is expected
+ * behaviour and all are fine.  One exception is send trailer fields.
+ * You cannot send trailer fields after sending frame with END_STREAM
+ * set.  To avoid this problem, one can set
+ * :enum:`NGHTTP2_DATA_FLAG_NO_END_STREAM` along with
+ * :enum:`NGHTTP2_DATA_FLAG_EOF` to signal the library not to set
+ * END_STREAM in DATA frame.  Then application can use
+ * `nghttp2_submit_trailer()` to send trailer fields.
+ * `nghttp2_submit_trailer()` can be called inside this callback.
+ *
+ * If the application wants to postpone DATA frames (e.g.,
+ * asynchronous I/O, or reading data blocks for long time), it is
+ * achieved by returning :enum:`NGHTTP2_ERR_DEFERRED` without reading
+ * any data in this invocation.  The library removes DATA frame from
+ * the outgoing queue temporarily.  To move back deferred DATA frame
+ * to outgoing queue, call `nghttp2_session_resume_data()`.
+ *
+ * By default, |length| is limited to 16KiB at maximum.  If peer
+ * allows larger frames, application can enlarge transmission buffer
+ * size.  See :type:`nghttp2_data_source_read_length_callback` for
+ * more details.
+ *
+ * If the application just wants to return from
+ * `nghttp2_session_send()` or `nghttp2_session_mem_send()` without
+ * sending anything, return :enum:`NGHTTP2_ERR_PAUSE`.
+ *
+ * In case of error, there are 2 choices. Returning
+ * :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` will close the stream
+ * by issuing RST_STREAM with :enum:`NGHTTP2_INTERNAL_ERROR`.  If a
+ * different error code is desirable, use
+ * `nghttp2_submit_rst_stream()` with a desired error code and then
+ * return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  Returning
+ * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` will signal the entire session
+ * failure.
+ */
+static ssize_t HttpReqOnChunkGet(
+    nghttp2_session *session, int32_t streamId, uint8_t *buf, size_t size,
+    uint32_t *dataFlags, nghttp2_data_source *source, void *userData)
+{
+    HttpReq *self = (HttpReq*)nghttp2_session_get_stream_user_data(session, streamId);
+    bool eof = false;
+    *dataFlags = 0;
+
+    // 不确定是否会出现这种情况，保险处理
+    if (!self || HttpReqClosed(self)) {
+        LOGW("onChunkGet(), but strm closed by lib before%s, ignore\n", (self ? ", self=null" : ""));
+        return 0;
+    }
+
+    // 没有数据待发送，根据rsp是否end而返回不同的值给lib
+    if (list_empty(&self->rspDatas)) {
+        HI_ASSERT(self->rspDataNum == 0);
+        eof = (self->status & HRS_RSP_BODY_END);
+        if (eof) { // 返回EOF，lib将结束该stream
+            *dataFlags |= NGHTTP2_DATA_FLAG_EOF;
+            return 0;
+        } else { // 返回deferred，lib将不再回调此函数get数据，直到resume被调用
+            self->txPaused = true;
+            return NGHTTP2_ERR_DEFERRED;
+        }
+    }
+
+    // 将队列中的数据复制到buf中，尽可能充满buf
+    int prevRspNum = self->rspDataNum;
+    int len = 0;
+    while (len < size && !list_empty(&self->rspDatas)) {
+        MemBlk* blk = list_entry(self->rspDatas.next, MemBlk, lnode);
+        HI_ASSERT(blk->offset < blk->len); // 对象不会存储size为0的blk
+
+        int n = HI_MIN(size - len, blk->len - blk->offset);
+        HI_ASSERT(n > 0);
+        if (memcpy_s(buf + len, size - len, blk->data + blk->offset, n) != EOK) {
+            HI_ASSERT(0);
+        }
+        len += n;
+
+        blk->offset += n;
+        HI_ASSERT(blk->offset <= blk->len);
+
+        if (blk->offset == blk->len) {
+            self->rspDataNum--;
+            list_del(&blk->lnode);
+            MemBlkDelete(blk);
+        }
+    }
+
+    eof = list_empty(&self->rspDatas) && (self->status & HRS_RSP_BODY_END);
+    if (eof) {
+        *dataFlags |= NGHTTP2_DATA_FLAG_EOF;
+    } else if (self->txDataEvt >= 0 &&
+        prevRspNum >= HREQ_TX_QUE_SIZE && self->rspDataNum < HREQ_TX_QUE_SIZE) {
+        EventFdInc(self->txDataEvt); // 唤醒user线程to write
+    }
+    return len;
+}
+
+/**
+    on req hdrs rx end.
+    此函数由HttpSess调用，调用前已经校验了通用状态，这里不需要再校验。
+*/
+static void HttpReqOnHdrsEnd(HttpReq* self)
+{
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->sess->thrdId);
+
+    if (self->status & HRS_REQ_HDRS_END) {
+        LOGW("onHdrsEnd(), but req hdrs end before, discard\n");
+        return;
+    }
+    self->status |= HRS_REQ_HDRS_END;
+}
+
+/**
+    on req body rx end.
+    此函数由HttpSess调用，调用前已经校验了通用状态，这里不需要再校验。
+*/
+static void HttpReqOnBodyEnd(HttpReq* self)
+{
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->sess->thrdId);
+
+    if (self->status & HRS_REQ_BODY_END) {
+        LOGE("onBodyEnd(), but req end before, discard\n");
+        return;
+    }
+
+    self->status |= HRS_REQ_BODY_END;
+
+    if (self->rxDataEvt >= 0) {
+        LOGD("emit req-body-end evt\n");
+        EventFdInc(self->rxDataEvt);
+    }
+
+    if (self->onBodyEndProc) {
+        LOGD("issue onBodyEnd(%p) ...\n", self);
+        self->onBodyEndProc(self->onBodyEndUser, self);
+        LOGD("issue onBodyEnd(%p) done\n", self);
+    }
+}
+
+/**
+    on close by HttpSess.
+*/
+static void HttpReqOnClose(HttpReq* self, int strmId, uint32_t errcode)
+{
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->sess->thrdId);
+    HI_ASSERT(self->ngStrmId == strmId);
+
+    // req被nglib确认已经close
+    // 但nglib后续可能还会回调此req的函数，例如当对端协议实现bug，又发送了frame过来
+    if (!(self->status & HRS_CLOSED)) {
+        LOGD("HTTP: HttpReq emit close evt\n");
+        self->status |= HRS_CLOSED;
+
+        // onClose应该是在锁内执行的，不需要加锁
+        HttpSessLock(self->sess);
+        if (self->closeEvt >= 0) {
+            EventFdInc(self->closeEvt);
+        }
+        if (self->rxDataEvt >= 0) {
+            EventFdInc(self->rxDataEvt);
+        }
+        if (self->txDataEvt >= 0) {
+            EventFdInc(self->txDataEvt);
+        }
+        HttpSessUnlock(self->sess);
+    }
+}
+
+/**
+    on reset by HttpSess.
+*/
+static void HttpReqOnReset(HttpReq* self, int strmId, uint32_t errcode)
+{
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->sess->thrdId);
+    HI_ASSERT(self->ngStrmId == strmId);
+
+    if (!(self->status & HRS_PEER_RESET)) {
+        LOGW("HTTP: HttpReq emit RESET evt\n");
+        self->status |= HRS_PEER_RESET;
+
+        // onReset应该是在锁内执行的，不需要加锁
+        HttpSessLock(self->sess);
+        if (self->closeEvt >= 0) {
+            EventFdInc(self->closeEvt);
+        }
+        if (self->rxDataEvt >= 0) {
+            EventFdInc(self->rxDataEvt);
+        }
+        if (self->txDataEvt >= 0) {
+            EventFdInc(self->txDataEvt);
+        }
+        HttpSessUnlock(self->sess);
+    }
+}
+
+/**
+    获取request header.
+*/
+HttpHdrs* HttpReqReqHdrs(HttpReq* self)
+{
+    HI_ASSERT(self);
+    HI_ASSERT(self->status & HRS_REQ_HDRS_END);
+    return self->reqHdrs;
+}
+
+/**
+    返回请求的method header.
+*/
+const char* HttpReqReqMethod(HttpReq* self)
+{
+    HI_ASSERT(self);
+    return self->reqMethod;
+}
+
+/**
+    返回请求的path header.
+*/
+const char* HttpReqReqPath(HttpReq* self)
+{
+    HI_ASSERT(self);
+    return self->reqPath;
+}
+
+/**
+    获取request中携带的query list.
+*/
+const char* HttpReqQueryList(HttpReq* self)
+{
+    HI_ASSERT(self);
+    const char *path = self->reqPath;
+    const char *queryList = NULL;
+
+    if (!path) {
+        return NULL;
+    }
+
+    // '?'之后的数据为query list
+    queryList = strchr(path, '?');
+    return queryList ? queryList + 1 : NULL;
+}
+
+/**
+    获取request body.
+    获取的body不会从HttpReq的队列中删除.
+*/
+int HttpReqReqBody(HttpReq* self, MemBlk** body)
+{
+    // user只能在body接收完成后调用此函数，此时，驱动线程不会修改reqBodys，
+    // 不需要保护user与驱动线程的冲突。
+    HI_ASSERT(self && body);
+    HI_ASSERT(self->status & HRS_REQ_BODY_END);
+    HI_ASSERT(self->flags & HRF_REQ_BODY_ONE); // 只允许设置该flag时调用此函数
+    MemBlk *blk = NULL;
+
+    *body = NULL;
+    if (list_empty(&self->reqDatas)) {
+        LOGE("get reqBody FAIL, for no reqBody, invalid call\n");
+        return -1;
+    }
+
+    blk = list_entry(self->reqDatas.next, MemBlk, lnode);
+    if (blk->len != self->reqCtLen) {
+        LOGE("body->len=%d, reqCtLen=%jd\n", blk->len, (intmax_t)self->reqCtLen);
+        return -1;
+    }
+    *body = blk;
+    return 0;
+}
+
+/**
+    读取request body.
+*/
+int HttpReqReadBody(HttpReq* self, MemBlk** data, bool async)
+{
+    HI_ASSERT(data);
+    *data = NULL;
+    int ret;
+
+    // 异步请求时，rxDataEvt必然应该被user创建，但这不是必须的，可删除此检查
+
+    HttpReqReadFd(self); // 需要时创建rxDataEvt
+
+    while (true) {
+        HttpSessLock(self->sess);
+
+        // reset/close判断
+        if ((self->status & HRS_PEER_RESET) || (self->status & HRS_CLOSED)) {
+            LOGW("readBody FAIL, for %s\n", (self->status & HRS_PEER_RESET) ? "it reset by peer" : "it closed");
+            ret = -ECONNRESET;
+            break;
+        }
+        if (self->status & HRS_LOC_RESET) {
+            LOGE("readBody FAIL, for it reset by loc\n");
+            ret = -ECONNABORTED;
+            break;
+        }
+
+        // 当REQ_BODY_END时，user可能多次调用此函数，这里做容错处理，提前判断
+        // REQ_BODY_END标志会在数据添加到reqDatas后才设置，因此可以不加锁
+        if ((self->status & HRS_REQ_BODY_END) && list_empty(&self->reqDatas)) {
+            ret = 0;
+            break;
+        }
+
+        // 返回数据，需要线程保护
+        if (!list_empty(&self->reqDatas)) { // 有数据，立即返回
+            *data = list_entry(self->reqDatas.next, MemBlk, lnode);
+            list_del_init(self->reqDatas.next);
+            self->reqDataNum--;
+            if (list_empty(&self->reqDatas)) {
+                EventFdClear(self->rxDataEvt);
+            }
+            ret = 1;
+            break;
+        }
+
+        // 异步请求时，退出，应在锁内执行，因为要clear rxDataEvt
+        if (async) {
+            ret = -EAGAIN;
+            break;
+        }
+
+        HttpSessUnlock(self->sess);
+
+        // 阻塞请求时，等待信号，继续后续循环，应在锁外执行 ...
+        int waitRes = FdWait(self->rxDataEvt, -1);
+        HI_EXP_RET(waitRes < 0, waitRes, "HTTP: FdWait FAIL, res=%d\n", waitRes);
+    }
+
+    if (ret != 1) {
+        EventFdClear(self->rxDataEvt);
+    }
+    HttpSessUnlock(self->sess);
+    return ret;
+}
+
+/**
+    write response header.
+*/
+int HttpReqWriteHdrs(HttpReq* self, const HttpHdrs* hdrs, bool rspEnd)
+{
+    HI_ASSERT(self && hdrs);
+    HI_ASSERT(!(self->status & HRS_RSP_HDRS_END));
+    nghttp2_nv *nva = NULL;
+    int nvc;
+    int res;
+
+    // 在锁外转换hdrs
+    nvc = HdrsToNg2(hdrs, &nva);
+
+    // 要调用nglib函数，需要加sess锁
+    HttpSessLock(self->sess);
+
+    // verify status
+    if (HttpReqClosed(self) || HttpReqReseted(self)) {
+        LOGW("writeHdrs(), but strm %s, err\n", (HttpReqClosed(self) ? "closed" : "reset"));
+        res = -1;
+        goto END;
+    }
+
+    // 直接向nglib submit，submit可能会导致相应回调函数立刻被lib执行，这里先设置status
+    HI_ASSERT(!self->txPaused);
+    self->status |= HRS_RSP_HDRS_END;
+    if (rspEnd) { // no body
+        self->status |= HRS_RSP_BODY_END;
+        HI_ASSERT(self->ngSess);
+        res = nghttp2_submit_response(self->ngSess, self->ngStrmId, nva, nvc, NULL);
+    } else {
+        nghttp2_data_provider dataPrd = { { .ptr = self }, HttpReqOnChunkGet };
+        HI_ASSERT(self->ngSess);
+        res = nghttp2_submit_response(self->ngSess, self->ngStrmId, nva, nvc, &dataPrd);
+    }
+    if (res < 0) {
+        LOGW("writeHdrs() submit rsp FAIL, res='%d, %s'\n", res, nghttp2_strerror(res));
+    } else {
+        EventFdInc(self->sess->userEvt); // 唤醒处理线程
+    }
+
+    END:
+        HttpSessUnlock(self->sess);
+        free(nva);
+        return 0;
+}
+
+/**
+    write response body.
+    本函数涉及的锁操作需要细致处理。
+    不提前创建writeFd，多数应用场景，都是async write，且只有一个chunk，无需writeFd。
+*/
+int HttpReqWriteBody(HttpReq* self, MemBlk* data, bool end, bool async)
+{
+    HI_ASSERT(!(self->status & HRS_RSP_BODY_END));
+    int ret = -1;
+
+    while (true) {
+        HttpSessLock(self->sess);
+
+        // reset/close判断
+        if ((self->status & HRS_PEER_RESET) || (self->status & HRS_CLOSED)) {
+            LOGW("writeBody FAIL, for %s\n", (self->status & HRS_PEER_RESET) ? "it reset by peer" : "it closed");
+            ret = -ECONNRESET;
+            break;
+        }
+        if (self->status & HRS_LOC_RESET) {
+            LOGE("writeBody FAIL, for it reset by loc\n");
+            ret = -ECONNABORTED;
+            break;
+        }
+
+        // 允许无data，但此时end必须被设置为true
+        if (!data) {
+            HI_ASSERT(end);
+            ret = 0;
+            break;
+        }
+        // 队列有空间时，将chunk添加到队列，不等待
+        if (self->rspDataNum < HREQ_TX_QUE_SIZE || (async && self->txDataEvt < 0)) { // 异步，且未创建txDataEvt
+            list_add_tail(&data->lnode, &self->rspDatas);
+            self->rspDataNum++;
+            ret = 1;
+            break;
+        }
+
+        // 异步请求时，不等待直接退出
+        if (async) {
+            HI_ASSERT(self->txDataEvt >= 0);
+            ret = -EAGAIN;
+            break;
+        }
+
+        HttpSessUnlock(self->sess);
+
+        // 阻塞请求时，等待信号，继续后续循环，应在锁外执行 ...
+        HttpReqWriteFd(self); // 需要创建
+        int waitRes = FdWait(self->txDataEvt, -1);
+        HI_EXP_RET(waitRes < 0, waitRes, "wait writeEvt FAIL, res=%d\n", waitRes);
+        EventFdClear(self->txDataEvt); // 对于write，txDataEvt一旦wait得到，就需要clear
+    }
+
+    // 需要时resume底层发送
+    if (ret >= 0) {
+        HttpReqResumeTx(self, end);
+    }
+
+    // 对于write，执行到这里的任何情况都应clear rxDataEvt
+    if (self->txDataEvt >= 0) {
+        EventFdClear(self->txDataEvt);
+    }
+    HttpSessUnlock(self->sess);
+    return ret;
+}
+
+/**
+    write full response.
+*/
+int HttpReqWriteRsp(HttpReq* self, const HttpHdrs* hdrs, MemBlk* body)
+{
+    HI_ASSERT(self && hdrs);
+    int res;
+
+    // 这里不校验状态，writeHdrs, writeBody会校验
+    res = HttpReqWriteHdrs(self, hdrs, (body ? false : true));
+    if (res < 0) {
+        return res;
+    }
+
+    if (body) {
+        return HttpReqWriteBody(self, body, true, true);
+    }
+    return 0;
+}
+
+/**
+    返回HttpReq关联的readFd.
+*/
+int HttpReqReadFd(HttpReq* self)
+{
+    if (self->rxDataEvt >= 0) {
+        return self->rxDataEvt;
+    }
+
+    // 锁内执行
+    HttpSessLock(self->sess);
+
+    // 需要再次判断
+    if (self->rxDataEvt < 0) {
+        self->rxDataEvt = EventFdCreate();
+        HI_ASSERT(self->rxDataEvt >= 0);
+
+        // 补发事件
+        if (!list_empty(&self->reqDatas) || HttpReqClosed(self) || HttpReqReseted(self)) {
+            EventFdInc(self->rxDataEvt);
+        }
+    }
+
+    HttpSessUnlock(self->sess);
+    return self->rxDataEvt;
+}
+
+/**
+    返回HttpReq关联的writeFd.
+*/
+int HttpReqWriteFd(HttpReq* self)
+{
+    if (self->txDataEvt >= 0) {
+        return self->txDataEvt;
+    }
+
+    // 锁内执行
+    HttpSessLock(self->sess);
+
+    // 需要再次判断
+    if (self->txDataEvt < 0) {
+        self->txDataEvt = EventFdCreate();
+        HI_ASSERT(self->txDataEvt >= 0);
+
+        // 补发事件
+        if (self->rspDataNum < HREQ_TX_QUE_SIZE ||
+            HttpReqClosed(self) || HttpReqReseted(self)) {
+            EventFdInc(self->txDataEvt);
+        }
+    }
+
+    HttpSessUnlock(self->sess);
+    return self->txDataEvt;
+}
+
+/**
+    返回HttpReq关联的closeFd.
+*/
+int HttpReqCloseFd(HttpReq* self)
+{
+    if (self->closeEvt >= 0) {
+        return self->closeEvt;
+    }
+
+    // 锁内执行
+    HttpSessLock(self->sess);
+
+    // 需要再次判断
+    if (self->closeEvt < 0) {
+        self->closeEvt = EventFdCreate();
+        HI_ASSERT(self->closeEvt >= 0);
+
+        // 补发事件
+        if (HttpReqClosed(self) || HttpReqReseted(self)) {
+            EventFdInc(self->closeEvt);
+        }
+    }
+
+    HttpSessUnlock(self->sess);
+    return self->closeEvt;
+}
+
+/**
+    释放请求数据.
+*/
+void HttpReqFreeReq(HttpReq* self)
+{
+    HI_ASSERT(self);
+    HI_ASSERT(self->status & HRS_REQ_BODY_END);
+    struct list_head *node = NULL;
+    struct list_head *next = NULL;
+
+    if (self->reqHdrs) {
+        HttpHdrsDelete(self->reqHdrs);
+        self->reqHdrs = NULL;
+        self->reqPath = NULL;
+    }
+
+    list_for_each_safe(node, next, &self->reqDatas) {
+        MemBlk *blk = list_entry(node, MemBlk, lnode);
+        list_del(node);
+        MemBlkDelete(blk);
+        self->reqDataNum--;
+    }
+    HI_ASSERT(self->reqDataNum == 0);
+    int ret = list_empty(&self->reqDatas);
+    HI_ASSERT(ret);
+}
+
+/**
+    获得HttpReq的当前状态.
+*/
+uint32_t HttpReqStatus(HttpReq* self)
+{
+    HI_ASSERT(self);
+    return self->status;
+}
+
+/**
+    user reset.
+    @note: 不从HttpSess中remove此HttpReq。
+*/
+int HttpReqReset(HttpReq* self, int reason)
+{
+    HI_ASSERT(self);
+
+    HttpSessLock(self->sess);
+    HI_ASSERT(!(self->status & HRS_LOC_RESET)); // 不允许本端多次调用reset
+
+    LOGI("HTTP: reset(), '%s', %d, reason=%d ...\n",
+        (HttpReqClosed(self) ? "?:?" : self->sess->cltAddr), self->ngStrmId, reason);
+
+    self->onBodyEndProc = NULL;
+    self->onBodyEndUser = NULL;
+
+    if (HttpReqClosed(self)) {
+        LOGW("reset(), but strm closed, strm=%d, ignore\n", self->ngStrmId);
+    } else if (HttpReqReseted(self)) {
+        LOGW("reset(), but strm reset, strm=%d, ignore\n", self->ngStrmId);
+    } else { // submit RSP frame
+        self->status |= HRS_LOC_RESET;
+
+        uint32_t errcode = ErrnoToH2Code(reason);
+        LOGD("reset(), submit RST, strm=%d, code=%02X\n", self->ngStrmId, errcode);
+        HI_ASSERT(self->ngSess);
+        nghttp2_submit_rst_stream(self->ngSess, 0, self->ngStrmId, errcode);
+        EventFdInc(self->sess->userEvt); // 唤醒驱动线程，以发送RST frame
+    }
+
+    HttpSessUnlock(self->sess);
+    return 0;
+}
+
+/**
+    设置附加对象.
+*/
+void HttpReqSetExt(HttpReq* self, void* obj, void(*destroy)(void* obj))
+{
+    HI_ASSERT(self);
+    self->extObj = obj;
+    self->extFree = destroy;
+}
+
+/**
+    获取附加对象.
+*/
+void* HttpReqGetExt(HttpReq* self)
+{
+    HI_ASSERT(self);
+    return self->extObj;
+}
+
+/**
+    clear flags [protected].
+*/
+uint32_t HttpReqClearFlag(HttpReq* self, uint32_t flags)
+{
+    self->flags &= ~flags;
+    return self->flags;
+}
+
+/**
+    add flags [protected].
+*/
+uint32_t HttpReqAddFlag(HttpReq* self, uint32_t flags)
+{
+    self->flags |= flags;
+    return self->flags;
+}
+
+/**
+    创建HttpReq.
+
+    在此函数中判断请求的相关信息是否符合rapi的约定，不符合的，则返回错误。
+    由调用者负责发送错误响应。
+*/
+static int HttpReqCreate(HttpReq** req, HttpSess* sess, nghttp2_session* ngSess, int32_t strmId)
+{
+    HttpReq *self = (HttpReq*)malloc(sizeof(*self));
+    *req = self;
+    HI_ASSERT(self);
+    if (memset_s(self, sizeof(*self), 0, sizeof(*self)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    HttpSessAddRef(sess);
+    self->sess = sess;
+    self->svr = sess->svr;
+    self->ngSess = ngSess;
+    self->ngStrmId = strmId;
+    INIT_LIST_HEAD(&self->lnode);
+    INIT_LIST_HEAD(&self->reqDatas);
+    INIT_LIST_HEAD(&self->rspDatas);
+    self->txDataEvt = -1; // 需要时才创建
+    self->rxDataEvt = -1; // 需要时才创建
+    self->closeEvt = -1; // 需要时才创建
+
+    HttpReqAddRef(self);
+    return 0;
+}
+
+/**
+    销毁HttpReq.
+
+    执行此函数时，refNum必然为0，此时不会有对此对象的任何引用，因而不需要加锁。
+    另外，目前设计下，执行此函数的必然是驱动线程，对svr的孤儿操作也是安全的。
+*/
+static void HttpReqDestroy(HttpReq* self)
+{
+    HttpSvr *svr = self->svr;
+    struct list_head *node = NULL;
+    struct list_head *next = NULL;
+    MemBlk *blk = NULL;
+
+    if (self->reqHdrs) {
+        HttpHdrsDelete(self->reqHdrs);
+    }
+
+    list_for_each_safe(node, next, &self->reqDatas) {
+        blk = list_entry(node, MemBlk, lnode);
+        MemBlkDelete(blk);
+    }
+    list_for_each_safe(node, next, &self->rspDatas) {
+        blk = list_entry(node, MemBlk, lnode);
+        MemBlkDelete(blk);
+    }
+    if (self->reqFullBody) {
+        MemBlkDelete(self->reqFullBody);
+    }
+
+    if (self->txDataEvt >= 0) {
+        close(self->txDataEvt);
+    }
+    if (self->rxDataEvt >= 0) {
+        close(self->rxDataEvt);
+    }
+    if (self->closeEvt >= 0) {
+        close(self->closeEvt);
+    }
+
+    HttpSessDelRef(self->sess); // NOTE: HttpSess最终可能因此而被destroy
+
+    if (self->extFree) {
+        self->extFree(self->extObj);
+    }
+
+    HttpSvrDelReq(svr, self); // 将self从HttpSvr的孤儿列表中删除
+    free(self);
+}
+
+/**
+    HttpReq引用计数加一.
+*/
+int HttpReqAddRef(HttpReq* self)
+{
+    HI_ASSERT(self);
+    return __sync_add_and_fetch(&self->refNum, 1);
+}
+
+/**
+    为HttpReq引用计数减一.
+*/
+int HttpReqDelRef(HttpReq* self)
+{
+    HI_ASSERT(self);
+
+    int ref = __sync_sub_and_fetch(&self->refNum, 1);
+    if (ref > 0) {
+        return ref;
+    }
+    HI_ASSERT(ref == 0);
+
+    // destroy或emit DestroyMethod事件
+    if (pthread_self() == self->svr->thrdId) { // 在驱动线程中，则直接destroy
+        HttpReqDestroy(self);
+    } else { // 在非驱动线程中，则emit DestroyMethod事件
+        DestroyMethod msg = {
+            .func = (DestroyFunc)HttpReqDestroy,
+            .obj = self
+        };
+        if (FdWriteMsg(self->svr->destroyChn.out, &msg, sizeof(msg)) != sizeof(msg)) {
+            HI_ASSERT(0);
+        }
+    }
+    return ref;
+}
+
+/**
+    查询ReqBody是否已经收齐.
+*/
+bool HttpReqReqBodyEnd(HttpReq* self)
+{
+    return !!(self->status & HRS_REQ_BODY_END);
+}
+
+/**
+    查询ReqBody是否为NULL.
+*/
+bool HttpReqReqBodyEmpty(HttpReq* self)
+{
+    return (self->status & HRS_REQ_BODY_END) && (self->reqDataNum == 0);
+}
+
+/**
+    注册/注销onBodyEnd事件handler.
+*/
+bool HttpReqSetOnBodyEnd(HttpReq* self, HttpReqProc onBodyEnd, void* user)
+{
+    HI_ASSERT(self);
+    self->onBodyEndProc = onBodyEnd;
+    self->onBodyEndUser = user;
+    return true;
+}
+
+/**
+    设置附加处理器.
+*/
+void HttpReqSetAttachProc(HttpReq* self, HttpReqProc proc, void* user, int flags)
+{
+    HI_ASSERT(self);
+    self->attachProc = proc;
+    self->attachUser = user;
+    self->attachFlags = flags;
+}
+
+/**
+    获取附加处理器.
+*/
+void HttpReqGetAttachProc(HttpReq* self, HttpReqProc* proc, void** user, int* flags)
+{
+    HI_ASSERT(self);
+    if (proc) {
+        *proc = self->attachProc;
+    }
+    if (user) {
+        *user = self->attachUser;
+    }
+    if (flags) {
+        *flags = self->attachFlags;
+    }
+}
+
+/**
+    发送简单响应，完成http请求.
+*/
+int HttpReqSimpleRsp(HttpReq* req, const char* status)
+{
+    HttpHdrs *hdrs = HttpHdrsNew(0);
+    HI_ASSERT(hdrs);
+    HttpHdrsAdd(hdrs, HH_STATUS, -1, status, -1);
+    HttpReqWriteHdrs(req, hdrs, true);
+    HttpHdrsDelete(hdrs);
+    return 0;
+}
+
+/**************************************************************************************************
+    HttpSess
+**************************************************************************************************/
+#define SP_HTTP_SESS
+
+/**
+    close sess下的指定HttpReq.
+*/
+static void HttpSessCloseOne(HttpSess* self, HttpReq* req)
+{
+    // HttpReq处理reset事件
+    HttpReqOnClose(req, req->ngStrmId, 0);
+
+    // 从容器中remove, 不需要加锁，user thread不可能执行到这里
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->thrdId);
+    list_del(&req->lnode);
+    self->reqNum--;
+
+    // 添加到HttpSvr的孤儿列表中
+    HttpSvrAddReq(self->svr, req);
+
+    // nglib会自动清空stream关联的user_data，不需要调用
+    HttpReqDelRef(req); // 当req被直接destroy时，可能导致self被destroy，其他情况下不会
+}
+
+/**
+    close sess下的所有HttpReq.
+*/
+static void HttpSessCloseAll(HttpSess* self)
+{
+    struct list_head *node = NULL;
+    struct list_head *next = NULL;
+    HttpReq *req = NULL;
+
+    LOGI("HTTP: close sess '%s', reqNum=%d ...\n", self->cltAddr, self->reqNum);
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->thrdId);
+
+    // 逐一close旗下HttpReq
+    list_for_each_safe(node, next, &self->reqList) { // 必须用safe版
+        req = list_entry(node, HttpReq, lnode);
+        HttpSessCloseOne(self, req); // 该函数会将req从reqList中删除
+    }
+    HI_ASSERT(self->reqNum == 0);
+    int res = list_empty(&self->reqList);
+    HI_ASSERT(res);
+
+    // 直到旗下所有HttpReq destroy后，self才会被destroy
+    // 这里提前释放相关资源，但必须非常小心，避免释放旗下HttpReq还需要使用的资源
+    if (self->ssl) {
+        SSL_free(self->ssl);
+        self->ssl = NULL;
+    }
+    if (self->sock >= 0) {
+        EmDelFd(self->svr->evtm, self->sock);
+        close(self->sock);
+        self->sock = -1;
+    }
+    if (self->ngSess) {
+        nghttp2_session_del(self->ngSess);
+        self->ngSess = NULL;
+    }
+}
+
+/**
+    Callback function invoked when library provides the error code, and
+    message.  This callback is solely for debugging purpose.
+    |libErrorCode| is one of error code defined in
+    :enum:`nghttp2_error`.  The |msg| is typically NULL-terminated
+    string of length |len|, and intended for human consumption.  |len|
+    does not include the sentinel NULL character.
+
+    The format of error message may change between nghttp2 library
+    versions.  The application should not depend on the particular format.
+
+    @type nghttp2_error_callback2().
+    set by nghtt2_session_callbacks_set_error_callback2().
+*/
+int HttpSessOnLibErr(nghttp2_session *session,
+    int libErrorCode, const char *msg, size_t len, void *userData)
+{
+    HI_ASSERT(msg);
+    HttpSess *self = (HttpSess*)userData;
+
+    LOGW("onLibErr(), code=%d, msg='%s'\n", libErrorCode, msg);
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->thrdId);
+    return 0;
+}
+
+/**
+ * Callback function invoked after the frame |frame| is sent.  The
+ * |userData| pointer is the third argument passed in to the call to
+ * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.
+ *
+ * The implementation of this function must return 0 if it succeeds.
+ * If nonzero is returned, it is treated as fatal error and
+ * `nghttp2_session_send()` and `nghttp2_session_mem_send()` functions
+ * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.
+ */
+static int HttpSessOnFrmTx(nghttp2_session *session, const nghttp2_frame *frame, void *userData)
+{
+    HttpSess *self = (HttpSess*)userData;
+    HI_ASSERT(self);
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->thrdId);
+
+    // 确定会出现这种情况，保险处理
+    HttpReq *req = (HttpReq*)nghttp2_session_get_stream_user_data(session, frame->hd.stream_id);
+    if (!req || HttpReqClosed(req)) {
+    }
+    return 0;
+}
+
+/**
+ * Callback function invoked by `nghttp2_session_recv()` and
+ * `nghttp2_session_mem_recv()` when a frame is received.
+ *
+ * For HEADERS, PUSH_PROMISE and DATA frames, this callback may be
+ * called after stream is closed (see
+ * :type:`nghttp2_on_stream_close_callback`).  The application should
+ * check that stream is still alive using its own stream management or
+ * :func:`nghttp2_session_get_stream_user_data()`.
+ *
+ * Only HEADERS and DATA frame can signal the end of incoming data.
+ * If ``frame->hd.flags & NGHTTP2_FLAG_END_STREAM`` is nonzero, the
+ * |frame| is the last frame from the remote peer in this stream.
+ *
+ * This callback won't be called for CONTINUATION frames.
+ * HEADERS/PUSH_PROMISE + CONTINUATIONs are treated as single frame.
+ *
+ * The implementation of this function must return 0 if it succeeds.
+ * If nonzero value is returned, it is treated as fatal error and
+ * `nghttp2_session_recv()` and `nghttp2_session_mem_recv()` functions
+ * immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.
+ *
+ * @note: headers通过单独的回调逐header提供。@see HttpReq_onHdrHdr().
+ * @note: 应在此函数中判断req hdrs, req body是否收齐。
+ */
+static int HttpSessOnFrmRx(nghttp2_session *session, const nghttp2_frame *frame, void *userData)
+{
+    HttpSess *self = (HttpSess*)userData;
+    HI_ASSERT(self);
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->thrdId);
+    int32_t strmId = frame->hd.stream_id;
+    uint8_t frmType = frame->hd.type;
+    HttpReq *req = NULL;
+
+    if (frame->hd.stream_id == 0) {
+        LOGW("onFrmRx(), '%s', %d, %s, plen=%u, ignore strm 0\n", self->cltAddr,
+            (int)frame->hd.stream_id, H2StrmTypeStr(frame->hd.type), (int)frame->hd.length);
+        return 0;
+    }
+
+    // For DATA and HEADERS frame, this callback may be called after on_stream_close_callback
+    req = nghttp2_session_get_stream_user_data(session, strmId);
+    if (!req || HttpReqClosed(req)) {
+        LOGW("onFrmRx(), but strm closed by lib before%s, ignore\n", (req ? ", self=null" : ""));
+        return 0;
+    }
+
+    // nglib收到任意frame均会回调此函数，我们只关心HEADERS和DATA frame
+    if (!(frmType == NGHTTP2_HEADERS || frmType == NGHTTP2_DATA ||
+        frmType == NGHTTP2_RST_STREAM)) {
+        return 0;
+    }
+
+    // 当user已请求reset，或已检测到对端reset时，discard该frame
+    if (HttpReqReseted(req)) {
+        LOGW("onFrmRx(), but req RESET by %s before, discard\n",
+            (req->status | HRS_LOC_RESET) ? "usr" : "peer");
+        return 0;
+    }
+    // 收到RST frame后，HttpSessOnStrmClose()随后会被调用
+    if (frame->hd.type == NGHTTP2_RST_STREAM) {
+        HttpReqOnReset(req, strmId, 0);
+        return 0;
+    }
+
+    // 当收齐headers时, 分发请求
+    if ((frmType == NGHTTP2_HEADERS) && (frame->hd.flags & NGHTTP2_FLAG_END_HEADERS)) {
+        HttpReqOnHdrsEnd(req); // 先提交HttpReq处理
+
+        // 提交，但不会根据返回值报错时close req
+        HI_ASSERT(self->svr->onReqProc);
+        HttpReqAddRef(req);
+        self->svr->onReqProc(self->svr->onReqUser, req);
+        // NOTE: 这里不能return，还要执行后续处理
+    }
+
+    // 当收齐body时，提交事件
+    if ((frame->hd.flags & NGHTTP2_FLAG_END_STREAM) &&
+        (frmType == NGHTTP2_DATA || frmType == NGHTTP2_HEADERS)) {
+        // 提交，但不会根据返回值报错时close req
+        HttpReqOnBodyEnd(req);
+    }
+    return 0;
+}
+
+/**
+ * Callback function invoked when the reception of header block in
+ * HEADERS or PUSH_PROMISE is started.  Each header name/value pair
+ * will be emitted by :type:`nghttp2_on_header_callback`.
+ *
+ * The server applications probably create an object to store
+ * information about new stream if ``frame->hd.type ==
+ * NGHTTP2_HEADERS`` and ``frame->headers.cat ==
+ * NGHTTP2_HCAT_REQUEST``.  If |session| is configured as server side,
+ * ``frame->headers.cat`` is either ``NGHTTP2_HCAT_REQUEST``
+ * containing request headers or ``NGHTTP2_HCAT_HEADERS`` containing
+ * trailer fields and never get PUSH_PROMISE in this callback.
+ *
+ * Returning :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` will close
+ * the stream (promised stream if frame is PUSH_PROMISE) by issuing
+ * RST_STREAM with :enum:`NGHTTP2_INTERNAL_ERROR`.  In this case,
+ * :type:`nghttp2_on_header_callback` and
+ * :type:`nghttp2_on_frame_recv_callback` will not be invoked.  If a
+ * different error code is desirable, use
+ * `nghttp2_submit_rst_stream()` with a desired error code and then
+ * return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE`.  Again, use
+ * ``frame->push_promise.promised_stream_id`` as streamId parameter
+ * in `nghttp2_submit_rst_stream()` if frame is PUSH_PROMISE.
+ *
+ * The implementation of this function must return 0 if it succeeds.
+ * It can return :enum:`NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE` to
+ * reset the stream (promised stream if frame is PUSH_PROMISE).  For
+ * critical errors, it must return
+ * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  If the other value is
+ * returned, it is treated as if :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`
+ * is returned.  If :enum:`NGHTTP2_ERR_CALLBACK_FAILURE` is returned,
+ * `nghttp2_session_mem_recv()` function will immediately return
+ * :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.
+
+    此函数会创建HttpReq，其未提交给user，相关处理可简化。
+ */
+static int HttpSessOnHdrsBeg(
+    nghttp2_session *session, const nghttp2_frame *frame, void *userData)
+{
+    HttpSess *self = (HttpSess*)userData;
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->thrdId);
+    HttpReq *req = NULL;
+    int res;
+
+    // 检验frame，以确认是否开始一次请求
+    if (frame->hd.type != NGHTTP2_HEADERS) { // 严重错误，close stream
+        LOGE("onHdrsBeg(), but type='%s', reset the strm\n", H2StrmTypeStr(frame->hd.type));
+        return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
+    } else if (frame->headers.cat == NGHTTP2_HCAT_HEADERS) {
+        LOGE("onHdrsBeg(), but hdrs.cat=HEADERS, reset the strm\n");
+        return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
+    } else if (frame->headers.cat != NGHTTP2_HCAT_REQUEST) { // 严重错误，close stream
+        LOGE("onHdrsBeg(), but hdrs.cat=%d, reset the strm\n", frame->headers.cat);
+        return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
+    }
+
+    res = HttpReqCreate(&req, self, session, frame->hd.stream_id);
+    if (res < 0) {
+        LOGI("HTTP: create HttpReq FAIL, reset the strm\n");
+        return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;
+    }
+
+    // 添加该HttpReq
+    if (nghttp2_session_set_stream_user_data(session, frame->hd.stream_id, req) < 0) {
+        HI_ASSERT(0);
+    }
+    list_add(&req->lnode, &self->reqList);
+    self->reqNum++;
+    return 0;
+}
+
+/**
+ * Callback function invoked when the stream |stream_id| is closed.
+ * The reason of closure is indicated by the |errorCode|.  The
+ * |errorCode| is usually one of :enum:`nghttp2_error_code`, but that
+ * is not guaranteed.  The stream_user_data, which was specified in
+ * `nghttp2_submit_request()` or `nghttp2_submit_headers()`, is still
+ * available in this function.  The |userData| pointer is the third
+ * argument passed in to the call to `nghttp2_session_client_new()` or
+ * `nghttp2_session_server_new()`.
+ *
+ * This function is also called for a stream in reserved state.
+ *
+ * The implementation of this function must return 0 if it succeeds.
+ * If nonzero is returned, it is treated as fatal error and
+ * `nghttp2_session_recv()`, `nghttp2_session_mem_recv()`,
+ * `nghttp2_session_send()`, and `nghttp2_session_mem_send()`
+ * functions immediately return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.
+
+    无论是接收到RST frame，还是user调用reset，或user完成rsp，此函数均会被执行
+ */
+static int HttpSessOnStrmClose(nghttp2_session *session,
+    int32_t streamId, uint32_t errorCode, void *userData)
+{
+    HttpSess *self = (HttpSess*)userData;
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->thrdId);
+    HttpReq *req = nghttp2_session_get_stream_user_data(session, streamId);
+
+    // 除非onStrmClose()被多次调用，否则应该能取得有效值，测试时确认
+    if (!req || HttpReqClosed(req)) {
+        LOGW("onStrmClose(), but strm closed by lib before%s, ignore\n", (req ? ", self=null" : ""));
+        return 0;
+    }
+    HttpSessCloseOne(self, req);
+    return 0;
+}
+
+/**
+    on SSL连接建立.
+*/
+static int HttpSessOnSslConn(HttpSess* self)
+{
+#   define CIPHER_DESC_BUF 256 // 单点使用buf size
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->thrdId);
+    const uint8_t *alpn = NULL;
+    unsigned int alpnlen = 0;
+
+    // 判断SSL协商结果，是否确认支持HTTP/2
+#   if OPENSSL_VERSION_NUMBER >= 0x10002000L
+    if (alpn == NULL) {
+        SSL_get0_alpn_selected(self->ssl, &alpn, &alpnlen);
+    }
+#   else
+    HI_ASSERT(0); // 只支持ALPN
+#   endif // OPENSSL_VERSION_NUMBER >= 0x10002000L
+    if (alpn == NULL || alpnlen != 2 || memcmp("h2", alpn, 2) != 0) {
+        LOGE("%s h2 SSL ALPN FAIL\n", self->cltAddr);
+        return -1;
+    }
+
+    // dump SSL cipher info
+    const SSL_CIPHER *cipher = SSL_get_current_cipher(self->ssl);
+    HI_ASSERT(cipher);
+    const char *cipherName = SSL_CIPHER_get_name(cipher);
+    const char *cipherVer = SSL_CIPHER_get_version(cipher);
+    char cipherDesc[CIPHER_DESC_BUF] = "";
+    LOGW("SSL: cipher={id:%#x, name: '%s', ver: %s}\n",
+        SSL_CIPHER_get_id(cipher), (cipherName ? cipherName : "?"), (cipherVer ? cipherVer : "?"));
+    LOGW("SSL: cipher='%s'\n", SSL_CIPHER_description(cipher, cipherDesc, sizeof(cipherDesc)));
+
+    // sess建立时，client会发送24字节的magic过来，按协议server应该立刻回复init-setting
+    nghttp2_settings_entry iv[1] = {{ NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS, 100 }};
+    HI_ASSERT(self->ngSess);
+    int res = nghttp2_submit_settings(self->ngSess, NGHTTP2_FLAG_NONE, iv, sizeof(iv) / sizeof(*iv));
+    if (res != 0) {
+        LOGE("submit init-setting FAIL, err='%d, %s'\n", res, nghttp2_strerror(res));
+        return -1;
+    }
+    return 0;
+}
+
+/**
+ * Callback function invoked when |session| wants to send data to the
+ * remote peer.  The implementation of this function must send at most
+ * |length| bytes of data stored in |data|.  The |flags| is currently
+ * not used and always 0. It must return the number of bytes sent if
+ * it succeeds.  If it cannot send any single byte without blocking,
+ * it must return :enum:`NGHTTP2_ERR_WOULDBLOCK`.  For other errors,
+ * it must return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.  The
+ * |userData| pointer is the third argument passed in to the call to
+ * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.
+ *
+ * .. note::
+ *
+ *   The |length| may be very small.  If that is the case, and
+ *   application disables Nagle algorithm (``TCP_NODELAY``), then just
+ *   writing |data| to the network stack leads to very small packet,
+ *   and it is very inefficient.  An application should be responsible
+ *   to buffer up small chunks of data as necessary to avoid this
+ *   situation.
+ */
+static ssize_t HttpSessOnLibSend(nghttp2_session *session,
+    const uint8_t *data, size_t length, int flags, void *userData)
+{
+    HttpSess *self = (HttpSess*)userData;
+    HI_ASSERT(self);
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->thrdId);
+    int res;
+    int err;
+
+    HI_ASSERT(self->ssl);
+    HI_ASSERT(length > 0);
+    ERR_clear_error();
+    res = SSL_write(self->ssl, data, length);
+    if (res > 0) {
+        return res;
+    }
+
+    err = SSL_get_error(self->ssl, res);
+    if (err == SSL_ERROR_WANT_WRITE) {
+        return NGHTTP2_ERR_WOULDBLOCK;
+    } else if (err == SSL_ERROR_WANT_READ) {
+        // This read operation requires a write, and the underlying is full
+        LOGW("onLibSend() detect SSL_ERROR_WANT_READ, regard as EAGAIN\n");
+        return NGHTTP2_ERR_WOULDBLOCK;
+    } else { // 其他错误认为是严重错误，close ssl连接
+        LOGW("onLibSend() detect ERROR, regard as EOF, err={%d, '%s'}\n",
+            err, ERR_error_string(err, NULL));
+        return NGHTTP2_ERR_EOF;
+    }
+}
+
+/**
+ * Callback function invoked when |session| wants to receive data from
+ * the remote peer.  The implementation of this function must read at
+ * most |length| bytes of data and store it in |buf|.  The |flags| is
+ * currently not used and always 0.  It must return the number of
+ * bytes written in |buf| if it succeeds.  If it cannot read any
+ * single byte without blocking, it must return
+ * :enum:`NGHTTP2_ERR_WOULDBLOCK`.  If it gets EOF before it reads any
+ * single byte, it must return :enum:`NGHTTP2_ERR_EOF`.  For other
+ * errors, it must return :enum:`NGHTTP2_ERR_CALLBACK_FAILURE`.
+ * Returning 0 is treated as :enum:`NGHTTP2_ERR_WOULDBLOCK`.  The
+ * |userData| pointer is the third argument passed in to the call to
+ * `nghttp2_session_client_new()` or `nghttp2_session_server_new()`.
+ */
+static ssize_t HttpSessOnLibRecv(nghttp2_session *session,
+    uint8_t *buf, size_t length, int flags, void *userData)
+{
+    HttpSess *self = (HttpSess*)userData;
+    HI_ASSERT(self);
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->thrdId);
+    int res;
+    int err;
+
+    HI_ASSERT(self->ssl);
+    HI_ASSERT(length > 0);
+    ERR_clear_error();
+    res = SSL_read(self->ssl, buf, length);
+    HI_ASSERT(res > -2); // res为-2表示OpenSSL未实现此接口
+    if (res > 0) {
+        // 收到第一块数据表示SSL协商已经完成，认为SSL连接建立
+        if (self->rxBytes == 0 && HttpSessOnSslConn(self) < 0) {
+            return NGHTTP2_ERR_CALLBACK_FAILURE;
+        }
+        self->rxBytes += res;
+        return res;
+    }
+
+    err = SSL_get_error(self->ssl, res);
+    if (err == SSL_ERROR_WANT_READ) {
+        return NGHTTP2_ERR_WOULDBLOCK;
+    } else if (err == SSL_ERROR_WANT_WRITE) {
+        // This read operation requires a write, and the underlying is full
+        LOGW("onLibRecv() detect SSL_ERROR_EANT_WRITE, regard as EAGAIN\n");
+        return NGHTTP2_ERR_WOULDBLOCK;
+    } else if (err == SSL_ERROR_ZERO_RETURN) {
+        LOGW("onLibRecv() detect SSL_ERROR_ZERO_RETURN, regard as EOF\n");
+        return NGHTTP2_ERR_EOF;
+    } else { // 其他错误认为是严重错误，close ssl连接
+        LOGE("onLibRecv() detect ERROR, regard as EOF, err={%d, '%s'}, readRet=%d\n",
+            err, ERR_error_string(err, NULL), res);
+        return NGHTTP2_ERR_EOF;
+    }
+}
+
+/**
+    tcp事件处理.
+    读写数据，与ngthttp2串起来。
+*/
+static void HttpSessOnTcpEvt(void* user, int fd, uint32_t evts)
+{
+    HttpSess *self = (HttpSess*)user;
+    HI_ASSERT(self && self->sock == fd);
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->thrdId);
+    int res;
+
+    // nghttp2_session_send, recv是nglib的入口函数之一，需要锁保护，加大锁即可
+    HttpSessLock(self);
+    HI_ASSERT(self->ngSess);
+
+    // error，可能连接断开
+    if (evts & FDE_ERR) {
+        goto ERR_END;
+    }
+
+    // 数据可读
+    if (evts & FDE_IN) {
+        // 触发lib recv
+        res = nghttp2_session_recv(self->ngSess);
+        if (res != 0) {
+            LOGE("ng sess recv FAIL, res=%d\n", res);
+            goto ERR_END;
+        }
+        // 触发lib send，以发送app操作产生的到对端的数据输出
+        res = nghttp2_session_send(self->ngSess);
+        if (res != 0) {
+            LOGE("ng sess send FAIL, res=%d\n", res);
+            goto ERR_END;
+        }
+    }
+
+    // buf可写
+    if (evts & FDE_OUT) {
+        // 测试需确认
+        // nglib能检测本端和对端的GO_AWAY frame，从而能判断是否应该close session
+        if (nghttp2_session_want_read(self->ngSess) == 0 &&
+            nghttp2_session_want_write(self->ngSess) == 0) {
+            LOGI("HTTP: graceful close ngsess ...\n");
+            goto ERR_END;
+        }
+
+        // 触发lib send，以发送app操作产生的到对端的数据输出
+        res = nghttp2_session_send(self->ngSess);
+        if (res != 0) {
+            LOGE("ngsess send FAIL, res=%d\n", res);
+            goto ERR_END;
+        }
+    }
+
+    // 未知且未处理事件
+    if (evts & ~(FDE_IN | FDE_OUT | FDE_ERR)) {
+        LOGE("onTcpEvt detect un-handle evts %X\n", evts);
+        goto ERR_END;
+    }
+
+    HttpSessUnlock(self);
+    return;
+
+    // 读写产生错误，该sess应该被终止
+    ERR_END:
+        HttpSessCloseAll(self); // 在锁内执行
+        HttpSessUnlock(self);
+        HttpSvrDelSess(self->svr, self);
+}
+
+/**
+    user事件处理.
+*/
+static void HttpSessOnUserEvt(void* user, int fd, uint32_t evts)
+{
+    HttpSess *self = (HttpSess*)user;
+    HI_ASSERT(self && self->userEvt == fd);
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->thrdId);
+    EvtChkRet(evts, FDE_IN, fd);
+    EventFdClear(fd);
+    int res;
+
+    // nghttp2_session_send是nglib的入口函数之一，需要锁保护
+    HttpSessLock(self);
+
+    // 触发lib send，以发送app操作产生的到对端的数据输出
+    HI_ASSERT(self->ngSess);
+    res = nghttp2_session_send(self->ngSess);
+    if (res != 0) {
+        LOGE("nglib send FAIL, res='%d, %s'\n", res, nghttp2_strerror(res));
+        HttpSessCloseAll(self); // 在锁内执行
+        HttpSessUnlock(self);
+        HttpSvrDelSess(self->svr, self);
+    } else {
+        HttpSessUnlock(self);
+    }
+}
+
+/**
+    设置nghttp2回调函数.
+*/
+static void HttpSessSetLibCb(HttpSess* self)
+{
+    LOGI("HTTP: create ngsess ...\n");
+    // create nghttp2 sess, 设置nglib回调
+    nghttp2_session_callbacks *cbs = NULL;
+    nghttp2_session_callbacks_new(&cbs);
+    HI_ASSERT(cbs);
+
+    // 下列接口由HttpSess实现
+    nghttp2_session_callbacks_set_send_callback(cbs, HttpSessOnLibSend);
+    nghttp2_session_callbacks_set_recv_callback(cbs, HttpSessOnLibRecv);
+    nghttp2_session_callbacks_set_on_frame_recv_callback(cbs, HttpSessOnFrmRx);
+    nghttp2_session_callbacks_set_on_frame_send_callback(cbs, HttpSessOnFrmTx);
+    nghttp2_session_callbacks_set_on_stream_close_callback(cbs, HttpSessOnStrmClose);
+    nghttp2_session_callbacks_set_on_begin_headers_callback(cbs, HttpSessOnHdrsBeg);
+
+    // 下列接口由HttpReq直接实现
+    nghttp2_session_callbacks_set_on_header_callback(cbs, HttpReqOnHdrRx);
+    nghttp2_session_callbacks_set_on_data_chunk_recv_callback(cbs, HttpReqOnChunkRx);
+
+    int res = nghttp2_session_server_new(&self->ngSess, cbs, self);
+    HI_ASSERT(res == 0);
+    nghttp2_session_callbacks_del(cbs);
+    LOGI("HTTP: HttpSess create done\n");
+}
+
+/**
+    create HttpSess.
+*/
+static int HttpSessCreate(HttpSess** sess, HttpSvr* svr, int fd, const struct sockaddr_in* peerAddr)
+{
+    HI_ASSERT(svr);
+    int res;
+
+    LOGI("HTTP: HttpSessCreate() ...\n");
+
+    // create ssl sess 并将fd关联到ssl中
+    SSL *ssl = CreateSslSess(svr->sslCtx, fd);
+    HI_EXP_RET(!ssl, -1, "CreateSslSess FAIL\n");
+
+    HttpSess *self = (HttpSess*)malloc(sizeof(*self));
+    HI_ASSERT(self);
+    if (memset_s(self, sizeof(*self), 0, sizeof(*self)) != EOK) {
+        HI_ASSERT(0);
+    }
+    *sess = self;
+
+    // 不应使用NODELAY，nglib会write大量小块协议数据，应在send后调用flush()
+    int oval = 1;
+    res = setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (char*)&oval, sizeof(oval));
+    HI_ASSERT(res == 0);
+
+    char ipStr[IP_STR_BUF_SIZE] = { 0 };
+    inet_ntop(AF_INET, &peerAddr->sin_addr.s_addr, ipStr, sizeof(ipStr));
+    if (snprintf_s(self->cltAddr, sizeof(self->cltAddr), sizeof(self->cltAddr) - 1,
+        "%s:%u", ipStr, ntohs(peerAddr->sin_port)) < 0) {
+        HI_ASSERT(0);
+    }
+
+    self->refNum = 0;
+    INIT_LIST_HEAD(&self->lnode);
+    RecurMutexInit(&self->mutex);
+    self->thrdId = pthread_self();
+    self->svr = svr;
+    self->ssl = ssl;
+    self->sock = fd;
+    self->rxBytes = 0;
+    self->userEvt = EventFdCreate();
+    HI_ASSERT(self->userEvt >= 0);
+    INIT_LIST_HEAD(&self->reqList);
+    self->reqNum = 0;
+
+    LOGI("HTTP: addFd sock=%d, userEvt=%d ...\n", self->sock, self->userEvt);
+    if (EmAddFd(self->svr->evtm, self->sock, FDE_IN | FDE_OUT | FDE_ET, HttpSessOnTcpEvt, self) < 0) {
+        HI_ASSERT(0);
+    }
+    if (EmAddFd(self->svr->evtm, self->userEvt, FDE_IN, HttpSessOnUserEvt, self) < 0) {
+        HI_ASSERT(0);
+    }
+
+    HttpSessSetLibCb(self);
+    HttpSessAddRef(self); // 对应于协议层面检测到sess close时进行delRef
+    return 0;
+}
+
+/**
+    destroy HttpSess.
+    目前设计下，必然是驱动线程执行此函数，因此不需要加锁。
+*/
+static void HttpSessDestroy(HttpSess* self)
+{
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->svr->thrdId);
+    // 只有当所有HttpReq均不再引用HttpSess时，才会destroy this，此时reqList必然为NULL
+    int res = list_empty(&self->reqList);
+    HI_ASSERT(self->reqNum == 0 && res);
+
+    if (self->ssl) {
+        SSL_free(self->ssl);
+    }
+    if (self->sock >= 0) {
+        EmDelFd(self->svr->evtm, self->sock);
+        close(self->sock);
+    }
+    if (self->ngSess) {
+        nghttp2_session_del(self->ngSess);
+    }
+    if (self->userEvt >= 0) {
+        EmDelFd(self->svr->evtm, self->userEvt);
+        close(self->userEvt);
+    }
+    // todo free mutex
+    free(self);
+}
+
+/**
+    HttpSess引用计数加一.
+*/
+int HttpSessAddRef(HttpSess* self)
+{
+    HI_ASSERT(self);
+    return __sync_add_and_fetch(&self->refNum, 1);
+}
+
+/**
+    HttpSess引用计数减一.
+*/
+int HttpSessDelRef(HttpSess* self)
+{
+    HI_ASSERT(self);
+
+    int ref = __sync_sub_and_fetch(&self->refNum, 1);
+    if (ref > 0) {
+        return ref;
+    }
+    HI_ASSERT(ref == 0);
+
+    // destroy或emit DestroyMethod事件
+    if (pthread_self() == self->svr->thrdId) { // 在驱动线程中，则直接destroy
+        HttpSessDestroy(self);
+    } else { // 在user线程中，则emit DestroyMethod事件
+        HI_ASSERT(0); // 目前设计下，不可能执行到这里，因为对此函数的调用总是来自于驱动线程
+        DestroyMethod msg = {
+            .func = (DestroyFunc)HttpSessDestroy,
+            .obj = self
+        };
+        if (FdWriteMsg(self->svr->destroyChn.out, &msg, sizeof(msg)) != sizeof(msg)) {
+            HI_ASSERT(0);
+        }
+    }
+    return ref;
+}
+
+/**************************************************************************************************
+    HttpSvr
+**************************************************************************************************/
+#define SP_HTTP_SVR
+
+/**
+    dump HttpReq孤儿信息.
+*/
+static void HttpSvrDumpReq(HttpSvr* self)
+{
+    struct list_head *node = NULL;
+    int i = 0;
+
+    printf("%d HttpReq leak, user MUST check it\n", self->reqNum);
+    list_for_each(node, &self->reqList) {
+        HttpReq *req = list_entry(node, HttpReq, lnode);
+        printf("    %s, %s, %s\n", req->sess->cltAddr,
+            req->reqPath ? req->reqPath : "?", req->reqMethod);
+        i++;
+    }
+}
+
+/**
+    监听到destroyChn有destroy事件达到.
+    此函数由HttpSvr驱动线程执行。
+*/
+static void HttpSvrOnDestroy(void* user, int fd, uint32_t evts)
+{
+    HttpSvr *self = (HttpSvr*)user;
+    HI_ASSERT(fd == self->destroyChn.in);
+    EvtChkRet(evts, FDE_IN, fd);
+
+    DestroyMethod msg = {0};
+    while (FdReadMsg(fd, &msg, sizeof(msg)) == sizeof(msg)) {
+        HI_ASSERT(msg.func);
+        msg.func(msg.obj);
+    }
+}
+
+/**
+    监听到TCP连接到达.
+*/
+static void HttpSvrOnListen(void* user, int fd, uint32_t evts)
+{
+    HttpSvr *self = (HttpSvr*)user;
+    HI_ASSERT(self && self->listenFd == fd);
+    int res;
+
+    LOGI("HTTP: onListen(), IN=%d, ERR=%d ...\n", (evts & FDE_IN) ? 1 : 0, (evts & FDE_ERR) ? 1 : 0);
+
+    // error
+    if (evts & (FDE_ERR | FDE_HUP)) {
+        LOGE("onListen detect unkn evts %X\n", evts);
+        EmDelFd(self->evtm, fd);
+        HI_ASSERT(0);
+        return;
+    }
+
+    if (evts & ~(FDE_IN | FDE_ERR | FDE_HUP)) {
+        LOGW("onListen detect un-handle evts %X\n", evts);
+        EmDelFd(self->evtm, fd);
+        HI_ASSERT(0);
+        return;
+    }
+
+    // 只处理IN事件
+    if (!(evts & FDE_IN)) {
+        LOGW("onListen detect un-IN evts %X\n", evts);
+        return;
+    }
+
+    // 循环accept
+    struct sockaddr_in addr;
+    socklen_t len = sizeof(addr);
+    int sock;
+    while ((sock = accept(fd, (struct sockaddr*)&addr, &len)) >= 0) {
+        LOGI("HTTP: accept tcp conn, sock=%d\n", sock);
+
+        // 设置非阻塞模式
+        res = FdSetAsync(sock);
+        if (res < 0) {
+            LOGE("set O_NONBLOCK for sess sock FAIL, err=%d\n", res);
+            close(sock);
+            continue; // ignore the error
+        }
+
+        // craete HttpSess
+        HttpSess *sess = NULL;
+        res = HttpSessCreate(&sess, self, sock, &addr);
+        HI_ASSERT(!res);
+        list_add(&sess->lnode, &self->sessList);
+        self->sessNum++;
+    }
+    if (errno != EAGAIN && errno != EWOULDBLOCK) {
+        LOGE("accept for sock FAIL, err='%s'\n", strerror(errno));
+        return;
+    }
+}
+
+/**
+    删除指定的sess.
+*/
+static void HttpSvrDelSess(HttpSvr* self, HttpSess* sess)
+{
+    list_del(&sess->lnode);
+    self->sessNum--;
+    HI_ASSERT(self->sessNum >= 0);
+
+    HttpSessDelRef(sess);
+}
+
+/**
+    启动server.
+*/
+int HttpSvrStart(HttpSvr* self,
+    uint16_t port, const char* ip, HttpReqProc proc, void* user)
+{
+    HI_ASSERT(self);
+    HI_ASSERT(port > 0);
+    HI_ASSERT(proc);
+    int sock;
+    int res;
+
+    LOGI("HTTP: start, port=%u ...\n", (unsigned)port);
+    self->thrdId = pthread_self(); // 以执行start的线程为准
+
+    if (!self->sslCtx) {
+        LOGE("start FAIL, for sslCtx is NULL\n");
+        return -1;
+    }
+
+    // create tcp server socket
+    res = TcpSvrCreate(port, 0, true, 0); // 不listen
+    sock = res;
+    HI_EXP_GOTO(res < 0, ERR_END, "TcpSvrCreate FAIL, err=%d\n", res);
+
+    // add to evtmon
+    self->listenFd = sock;
+    res = EmAddFd(self->evtm, sock, FDE_IN, HttpSvrOnListen, self);
+    HI_ASSERT(!res);
+
+    // listen
+    LOGI("HTTP: listen in sock %d\n", sock);
+    res = listen(sock, HSVR_LISTEN_QUE);
+    HI_ASSERT(res == 0);
+
+    self->onReqProc = proc;
+    self->onReqUser = user;
+    return 0;
+
+    ERR_END:
+        if (sock >= 0) {
+            close(sock);
+        }
+        return res;
+}
+
+/**
+    终止server.
+    执行此函数前，服务EvtMon必然已退出循环，由user确保。
+*/
+int HttpSvrStop(HttpSvr* self)
+{
+    HI_ASSERT(self);
+    pthread_t ret = pthread_self();
+    HI_ASSERT(ret == self->thrdId);
+    struct list_head *node = NULL;
+    struct list_head *next = NULL;
+
+    self->onReqProc = NULL;
+    self->onReqUser = NULL;
+
+    // 这回close所有的sess，每个sess又会close旗下所有req
+    // 但这里不一定会导致立刻destroy这些sess和req，需要其引用计数归零后才会被destroy
+    LOGW("%d sess exist, close ...\n", self->sessNum);
+    list_for_each_safe(node, next, &self->sessList) {
+        HttpSess *sess = list_entry(node, HttpSess, lnode);
+        HttpSessCloseAll(sess);
+        HttpSvrDelSess(self, sess);
+    }
+    HI_ASSERT(self->sessNum == 0);
+    int res = list_empty(&self->sessList);
+    HI_ASSERT(res);
+
+    if (self->listenFd >= 0) {
+        EmDelFd(self->evtm, self->listenFd);
+        close(self->listenFd);
+        self->listenFd = -1;
+    }
+    return 0;
+}
+
+/**
+    create HttpSvr.
+*/
+int HttpSvrCreate(HttpSvr** svr,
+    EvtMon* evtm, const char* certFile, const char* keyFile)
+{
+    HI_ASSERT(svr && evtm);
+    HI_ASSERT(certFile && *certFile);
+    HI_ASSERT(keyFile && *keyFile);
+
+    HttpSvr *self = (HttpSvr*)malloc(sizeof(*self));
+    if (!self) {
+        HI_ASSERT(0);
+    }
+    if (memset_s(self, sizeof(*self), 0, sizeof(*self)) != EOK) {
+        HI_ASSERT(0);
+    }
+    *svr = self;
+
+    // 注意SSL没有对应的free版本，也就是不需要free
+    SSL_load_error_strings();
+    SSL_library_init();
+    self->sslCtx = CreateSslCtx(keyFile, certFile);
+    HI_EXP_LOGE(!self->sslCtx, "create ssl-ctx FAIL\n"); // 失败时仅log
+
+    self->evtm = evtm;
+    self->thrdId = pthread_self();
+    self->listenFd = -1;
+    INIT_LIST_HEAD(&self->sessList);
+    self->sessNum = 0;
+    INIT_LIST_HEAD(&self->reqList);
+    self->reqNum = 0;
+    self->onReqProc = NULL;
+    self->onReqUser = NULL;
+
+    if (SkPairCreate(&self->destroyChn) < 0) {
+        HI_ASSERT(0);
+    }
+    if (EmAddFd(evtm, self->destroyChn.in, FDE_IN, HttpSvrOnDestroy, self) < 0) {
+        HI_ASSERT(0);
+    }
+    return 0;
+}
+
+/**
+    destroy HttpSvr.
+*/
+void HttpSvrDestroy(HttpSvr* self)
+{
+    HI_ASSERT(self);
+    self->thrdId = pthread_self(); // 为绕开代码中的限制，重置thrdId，安全的
+
+    if (self->listenFd >= 0) {
+        HttpSvrStop(self);
+    }
+
+    // clean destroyChn，需要先clean，否则后面代码可能会误报存在HttpReq孤儿
+    if (EmDelFd(self->evtm, self->destroyChn.in) < 0) {
+        HI_ASSERT(0);
+    }
+    HttpSvrOnDestroy(self, self->destroyChn.in, FDE_IN); // 清空postPicChn中未被处理数据
+    SkPairDestroy(&self->destroyChn);
+
+    // 若有HttpReq孤儿存在，trace信息供user检查
+    if (self->reqNum > 0) {
+        // 遇到泄漏，直接trace，不用wait容错。
+        // 因为这是严重错误，user必须确保在此前完成clean
+        // 属于严重错误，这里就不加锁了
+        DOLOGE(HttpSvrDumpReq(self));
+    }
+
+    // free sslCtx暂时组织在这里，见stop中的说明
+    if (self->sslCtx) {
+        SSL_CTX_free(self->sslCtx);
+    }
+    free(self);
+}
diff -urpBN hiopenais/src/lite_http/http_svr.h hiopenais_modify/src/lite_http/http_svr.h
--- hiopenais/src/lite_http/http_svr.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/lite_http/http_svr.h	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HTTP_SVR_H
+#define HTTP_SVR_H
+
+#include <stdint.h>
+#include "evt_mon.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    HttpSvr对象类型声明.
+*/
+typedef struct HttpSvr HttpSvr;
+
+/**
+    create HttpSvr.
+
+    @param certFile: 存储server certFile文件名。
+    @param keyFile: 存储server private key的文件名。
+*/
+int HttpSvrCreate(HttpSvr** svr,
+    EvtMon* evtm, const char* certFile, const char* keyFile);
+
+/**
+    destroy HttpSvr.
+*/
+void HttpSvrDestroy(HttpSvr* self);
+
+/**
+    启动server.
+
+    user通过参数传入接收HttpReq的handler，当HttpSvr收到client的request时，通过
+    该handler通知user。
+
+    分发器可实现HttpReqProc接口以监听HttpReq，并根据HttpReq::path()等信息完成分发。
+
+    分发器收到HttpReq后，可从该对象派生更具体的对象，例如SseReq, RapiReq。
+    派生方法为调用具体对象的init函数，如SseReqInit(), RapiReqInit()。
+
+    @param port: server监听的端口号，host字节序，如443。
+    @param ip: server ip，可置为NULL表示监听本机所有IP。
+    @param proc: HttpReq处理函数。
+    @param user: user对象，可为NULL。将在调用@func proc时，作为user参数传入。
+*/
+int HttpSvrStart(HttpSvr* self,
+    uint16_t port, const char* ip, HttpReqProc proc, void* user);
+
+/**
+    终止server.
+*/
+int HttpSvrStop(HttpSvr* self);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // HTTP_SVR_H
diff -urpBN hiopenais/src/lite_http/http_util.c hiopenais_modify/src/lite_http/http_util.c
--- hiopenais/src/lite_http/http_util.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/lite_http/http_util.c	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,176 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "hi_ext_util.h"
+#include "http_util.h"
+
+/**
+    浠跺content-type 瀵.
+*/
+typedef struct ExtCttPair {
+    const char* ext; // 浠舵╁
+    const char* ctt; // content-type
+}   ExtCttPair;
+
+/**
+    ExtCttPair table.
+*/
+static const ExtCttPair G_EXT_CTT_TAB[] = {
+    { "html",   "text/html" },
+    { "htm",    "text/html" },
+    { "xml",    "text/xml" },
+    { "css",    "text/css" },
+    { "js",     "text/javascript" },
+    { "txt",    "text/plain" },
+    { "text",   "text/plain" },
+
+    { "json",   "application/json" },
+
+    { "jpg",    "image/jpeg" },
+    { "gif",    "image/gif" },
+    { "png",    "image/png" },
+    { "ico",    "image/x-ico" },
+    { "mp4",    "video/mpeg4" },
+};
+
+/**
+    杩浠跺缂杩content-type.
+*/
+const char* FileExtToCtt(const char* filePath)
+{
+    HI_ASSERT(filePath);
+    const char *ext = NULL;
+    int i;
+
+    ext = strrchr(filePath, '.');
+    if (!ext) {
+        return NULL;
+    }
+    ext++;
+
+    for (i = 0; i < HI_ARRAY_SIZE(G_EXT_CTT_TAB); i++) {
+        if (HiStricmp(G_EXT_CTT_TAB[i].ext, ext) == 0) {
+            return G_EXT_CTT_TAB[i].ctt;
+        }
+    }
+    return NULL;
+}
+
+/**
+    errno to http2 error code.
+*/
+uint32_t ErrnoToH2Code(int err)
+{
+    if (err == 0) {
+        return 0; // no error
+    } else if (err == -ECANCELED) {
+        return 0x08; // CANCEL
+    } else {
+        return 0x02; // innernal error
+    }
+}
+
+/**
+    stream type name table.
+*/
+static const char* g_h2StrmTypeTab[] = {
+    "DATA",
+    "HEADERS",
+    "PRIORITY",
+    "RST_STREAM",
+    "SETTINGS",
+    "PUSH_PROMISE",
+    "PING",
+    "GOAWAY",
+    "WINDOW_UPDATE"
+    "CONTINUATION",
+};
+
+/**
+    峰stream type绉.
+*/
+const char* H2StrmTypeStr(uint8_t type)
+{
+    if (type >= HI_ARRAY_SIZE(g_h2StrmTypeTab)) {
+        return "?";
+    } else {
+        return g_h2StrmTypeTab[type];
+    }
+}
+
+/**
+    http method string to code.
+*/
+uint32_t HttpMethodToCode(const char* method)
+{
+    if (HiStricmp(method, "GET") == 0) {
+        return HMC_GET;
+    } else if (HiStricmp(method, "HEAD") == 0) {
+        return HMC_HEAD;
+    } else if (HiStricmp(method, "PUT") == 0) {
+        return HMC_PUT;
+    } else if (HiStricmp(method, "POST") == 0) {
+        return HMC_POST;
+    } else {
+        LOGE("unkn HTTP method '%s'\n", method);
+        return 0;
+    }
+}
+
+/**
+    http method list string to codes.
+*/
+uint32_t HttpMethodsToCodes(const char* methods)
+{
+    uint32_t codes = 0;
+
+    if (HiStristr(methods, "GET")) {
+        codes |= HMC_GET;
+    }
+    if (HiStristr(methods, "HEAD")) {
+        codes |= HMC_HEAD;
+    }
+    if (HiStristr(methods, "PUT")) {
+        codes |= HMC_PUT;
+    }
+    if (HiStristr(methods, "POST")) {
+        codes |= HMC_POST;
+    }
+    return codes;
+}
+
+/**
+    http method code to string.
+*/
+const char* HttpCodeToMethod(uint32_t mcode)
+{
+    if (mcode == HMC_GET) {
+        return "GET";
+    } else if (mcode == HMC_HEAD) {
+        return "HEAD";
+    } else if (mcode == HMC_PUT) {
+        return "PUT";
+    } else if (mcode == HMC_POST) {
+        return "POST";
+    } else {
+        LOGE("unkn HTTP method '%#x'\n", mcode);
+        return "?";
+    }
+}
+
diff -urpBN hiopenais/src/lite_http/http_util.h hiopenais_modify/src/lite_http/http_util.h
--- hiopenais/src/lite_http/http_util.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/lite_http/http_util.h	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HTTP_UTIL_H
+#define HTTP_UTIL_H
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "http_def.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    杩浠跺缂杩content-type.
+*/
+const char* FileExtToCtt(const char* filePath);
+
+/**
+    errno to http2 error code.
+*/
+uint32_t ErrnoToH2Code(int err);
+
+/**
+    峰stream type绉.
+*/
+const char* H2StrmTypeStr(uint8_t type);
+
+/**
+    http method string to code.
+*/
+uint32_t HttpMethodToCode(const char* method);
+
+/**
+    http method list string to codes.
+*/
+uint32_t HttpMethodsToCodes(const char* methods);
+
+/**
+    http method code to string.
+*/
+const char* HttpCodeToMethod(uint32_t mcode);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // HTTP_UTIL_H
diff -urpBN hiopenais/src/lite_http/lite_httpd.c hiopenais_modify/src/lite_http/lite_httpd.c
--- hiopenais/src/lite_http/lite_httpd.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/lite_http/lite_httpd.c	2021-03-29 20:56:25.000000000 -0700
@@ -0,0 +1,921 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <limits.h>
+#include <signal.h>
+#include <pthread.h>
+#include <sys/types.h>
+
+#include "http_req.h"
+#include "http_svr.h"
+#include "http_util.h"
+#include "http_rapi.h"
+#include "http_sse.h"
+#include "lite_httpd.h"
+
+/**
+    http缃.
+*/
+#define SVR_PORT_DEF    8443 // server TCP port
+#define SVR_CRT_FILE    "./key/server.crt"
+#define SVR_KEY_FILE    "./key/server.key" // server priv key浠跺
+#define RSC_TAB_SIZE    64 // rsc table size.
+
+/**
+    http service type.
+*/
+typedef enum HttpSvcType {
+    HST_HTTP = 0,
+    HST_RAPI,
+    HST_SSE,
+    HST_SIZE
+}   HttpSvcType;
+
+/**
+    resource node.
+*/
+typedef struct RscNode {
+    const char* path; // url.path
+    uint32_t methods; // methods codes
+
+    HttpReqProc proc; // req handle
+    void *user; // user proc request
+
+    HttpReqExt ext; // 瀵硅薄╁澶
+    HttpSvcType svcType; // service type
+    uint32_t flags; // HttpReq flags
+
+    int chnFd; // userユ朵浠剁channel
+}   RscNode;
+
+/**
+    httpd datas.
+*/
+static pthread_mutex_t g_rscMutex; // 璁块浜ワ涓昏ㄤ淇ゅrscTab璁块
+static RscNode g_rscTab[RSC_TAB_SIZE]; // 璧婧琛
+static EvtMon *g_evtMon = NULL; // HttpSvr渚璧EvtMon
+static HttpSvr *g_httpSvr = NULL; // LiteHttpd缁存ょHttpSvr瀹渚
+static pthread_t g_svcThrd = 0; // 椹卞HttpSvr绾跨ID
+
+/*
+    inner service 虫
+*/
+static int InnerWwwProc(void* user, HttpReq* req);
+static void InnerSvcInit(void);
+static void InnerSvcExit(void);
+
+/**
+    get file澶宸ュ峰芥.
+*/
+int HttpdGetFile(HttpReq* req, const char* filePath, const char* ctt)
+{
+    char buf[INT_STR_BUF_SIZE];
+    int res = -1;
+    char stFilePath[PATH_MAX] = {0};
+
+    if (!realpath(filePath, stFilePath)) {
+        LOGE("HttpdGetFile filePath (%s) is not exit\n", filePath);
+        HI_ASSERT(0);
+    }
+    LOGI("HttpdGetFile standard file path:%s\n", stFilePath);
+
+    // try to open file
+    FILE *file = fopen(stFilePath, "rb");
+    HI_EXP_CMD_GOTO(!file, HttpReqSimpleRsp(req, "404"), END, "open '%s' FAIL\n", stFilePath);
+
+    // get file size for verify on sending
+    off_t fileSize = FileGetSize(file);
+    HI_EXP_CMD_GOTO(fileSize < 0, HttpReqSimpleRsp(req, "500"), END, "get '%s' size FAIL\n", HttpReqReqPath(req));
+
+    // write headers
+    HttpHdrs *hdrs = HttpHdrsNew(0);
+    HI_ASSERT(hdrs);
+    HttpHdrsAdd(hdrs, HH_STATUS, -1, "200", -1);
+    HttpHdrsAdd(hdrs, HH_CONTENT_TYPE, -1, ctt, -1);
+    if (snprintf_s(buf, sizeof(buf), sizeof(buf) - 1, "%jd", (intmax_t)fileSize) < 0) {
+        HI_ASSERT(0);
+    }
+    HttpHdrsAdd(hdrs, HH_CONTENT_LENGTH, -1, buf, -1);
+    HttpReqWriteHdrs(req, hdrs, false);
+    HttpHdrsDelete(hdrs);
+
+    // read file blocks and send via HttpReq one by one
+    off_t total = 0;
+    bool eof = false;
+    while (!eof) {
+        // read a block data
+        MemBlk *blk = MemBlkNew(HUGE_BUF_SIZE); // ensure by xiao
+        if (!blk) {
+            HI_ASSERT(0);
+        }
+        int len = fread(blk->data, 1, blk->size, file);
+        if (len <= 0) {
+            MemBlkDelete(blk);
+            if (len < 0) {
+                LOGE("fread() FAIL, err='%s'\n", strerror(errno));
+                break;
+            }
+            blk = NULL;
+        } else {
+            blk->len = len;
+        }
+
+        eof = feof(file);
+        HI_ASSERT(len > 0 || eof);
+
+        // write the block, 娉ㄦblk戒负NULL锛杩姝ｇ‘
+        res = HttpReqWriteBody(req, blk, eof, false);
+        if (res < 0) { // 甯歌: 杩ユ寮锛client reset
+			LOGE("writeBody() FAIL, ret=%d\n", res);
+            break;
+        }
+        // ￠total
+        total += len;
+        if (total > fileSize) {
+            LOGE("total(%jd) > fileSize(%jd)\n", (intmax_t)total, (intmax_t)fileSize);
+            HttpReqReset(req, -1);
+            break;
+        }
+    }
+    res = 0;
+
+    END:
+        if (file) {
+            fclose(file);
+        }
+        return res;
+}
+
+/**
+    put file澶宸ュ峰芥.
+*/
+int HttpdPutFile(HttpReq* req, const char* filePath, bool reply)
+{
+    MemBlk *blk = NULL;
+    const char* hval = NULL;
+    FILE *file = NULL;
+    int64_t cttLen;
+    int64_t gotLen;
+    int len;
+    int ret = -1;
+    char stFilePath[PATH_MAX] = {0};
+
+    if (!realpath(filePath, stFilePath)) {
+        LOGE("HttpPutFile filePath (%s) is not exit\n", filePath);
+        HI_ASSERT(0);
+    }
+    LOGI("HttpdPutFile standard file path:%s\n", stFilePath);
+    // try to open file
+    file = fopen(stFilePath, "wb");
+    if (!file) {
+        LOGE("open '%s' FAIL\n", stFilePath);
+        return -1;
+    }
+
+    hval = HttpHdrsFind(HttpReqReqHdrs(req), HH_CONTENT_LENGTH, NULL);
+    cttLen = hval ? atoll(hval) : -1LL;
+
+    // read file blocks and send via HttpReq one by one
+    gotLen = 0;
+    while ((ret = HttpReqReadBody(req, &blk, false)) > 0) {
+        HI_ASSERT(blk);
+        gotLen += blk->len;
+        if (blk->len > 0 && (len = fwrite(blk->data, 1, blk->len, file)) != blk->len) {
+            LOGE("fwrite FAIL, err='%s, %d'\n", strerror(errno), errno);
+            MemBlkDelete(blk);
+            ret = -1;
+            goto END;
+        }
+        if (blk) {
+            MemBlkDelete(blk);
+        }
+    }
+    if (ret < 0) {
+        LOGE("readBody FAIL, ret=%d\n", ret);
+    } else if (cttLen >= 0 && cttLen != gotLen) {
+        LOGE("size mismatch, cttLen=%jd, gotLen=%jd\n", cttLen, gotLen);
+    }
+
+    END:
+        fclose(file);
+        if (ret < 0) {
+            LOGW("remove '%s' for proc FAIL\n", stFilePath);
+            int err = remove(stFilePath);
+            HI_EXP_LOGE(err < 0, "remove '%s' FAIL, err='%s, %d'\n", stFilePath, strerror(errno), errno);
+        }
+        if (reply) {
+            const char *status = ret < 0 ? "500" : "200";
+            HttpReqSimpleRsp(req, status);
+        }
+        return ret;
+}
+
+/**
+    渚user浣跨ㄧhttpd event澶芥.
+*/
+void HttpdEvtProc(void* user, int fd, uint32_t evts)
+{
+    EvtChkRet(evts, FDE_IN, fd);
+
+    // 寰璇诲HttpReq锛骞跺
+    HttpdEvt evt = {0};
+    while (FdReadMsg(fd, &evt, sizeof(evt)) == sizeof(evt)) {
+        HI_ASSERT(evt.proc);
+        evt.proc(evt.user, evt.req);
+    }
+}
+
+/**
+    绮剧‘归path.
+*/
+static RscNode* HttpdFindRsc(const char* path, uint32_t method, int* rscId)
+{
+    *rscId = -1;
+
+    for (int i = 0; i < HI_ARRAY_SIZE(g_rscTab); i++) {
+        RscNode *node = &g_rscTab[i];
+
+        if (!node->path || strcmp(node->path, path) != 0) {
+            continue;
+        }
+
+        if (!(node->methods & method)) {
+            LOGW("path '%s' match, but method '%s' mismatch\n",
+                path, HttpCodeToMethod(method));
+            return NULL;
+        }
+
+        *rscId = i;
+        return node;
+    }
+    return NULL;
+}
+
+/**
+    跺RAPIonBodyClose浜浠.
+*/
+static int HttpdOnRapi(void* user, HttpReq* req)
+{
+    HI_ASSERT(g_httpSvr);
+    const char* path = HttpReqReqPath(req);
+    RscNode *node = NULL;
+    int rscId;
+    int ret;
+
+    // 澶ч
+    MutexLock(&g_rscMutex);
+
+    HttpReqGetAttachProc(req, NULL, NULL, &rscId);
+
+    // ゆrscId瀵瑰item归锛藉跺凡缁琚user娉ㄩ浜
+    if (g_rscTab[rscId].path && strcmp(g_rscTab[rscId].path, path) == 0) {
+        node = &g_rscTab[rscId];
+    } else {
+        uint32_t method = HttpMethodToCode(HttpReqReqMethod(req));
+        if ((node = HttpdFindRsc(path, method, &rscId)) == NULL) {
+            LOGE("req{%s, %s} FAIL, for rsc unreg\n", path, HttpReqReqMethod(req));
+            HttpReqSimpleRsp(req, "404");
+            ret = 0;
+            goto END;
+        }
+    }
+
+    // 
+    HttpReqAddRef(req);
+    if (node->chnFd < 0) { // 存ュ
+        HI_ASSERT(node->proc);
+        ret = node->proc(node->proc, req);
+    } else { // 浜浠剁chnFd
+        HttpdEvt evt = {
+            .req = req,
+            .proc = node->proc,
+            .user = node->user
+        };
+        if (FdWriteMsg(node->chnFd, &evt, sizeof(evt)) != sizeof(evt)) {
+            LOGE("post evt to user FAIL\n");
+            HttpReqDelRef(req);
+        }
+        ret = 0;
+    }
+
+    END:
+        MutexUnlock(&g_rscMutex);
+        return ret;
+}
+
+/**
+    HttpReq.
+    瑕caller锛姝ゅ芥颁璐璐ｅ
+*/
+static int HttpdDispatch(HttpReq* req, const RscNode *node, int rscId)
+{
+    // 规澶rapi
+    if (node->svcType == HST_RAPI) {
+        HttpReqSetAttachProc(req, NULL, NULL, rscId);
+        HttpReqSetOnBodyEnd(req, HttpdOnRapi, NULL);
+        HttpReqDelRef(req);
+        return 0;
+    }
+
+    // 璇锋
+    HI_ASSERT(node->proc);
+    if (node->chnFd < 0) { // 存ュ璋
+        node->proc(node->user, req);
+    } else { // 浜浠剁chnFd
+        HttpdEvt evt = {
+            .req = req,
+            .proc = node->proc,
+            .user = node->user
+        };
+        if (FdWriteMsg(node->chnFd, &evt, sizeof(evt)) != sizeof(evt)) {
+            LOGE("post evt to user FAIL\n");
+            HttpReqDelRef(req);
+        }
+    }
+    return 0;
+}
+
+/**
+    HttpReq澶ㄥhandler.
+*/
+static int HttpdMux(void* user, HttpReq* req)
+{
+    const char* path = HttpReqReqPath(req);
+    uint32_t method = HttpMethodToCode(HttpReqReqMethod(req));
+    int rscId = -1;
+    int ret;
+
+    // 澶ч
+    MutexLock(&g_rscMutex);
+
+    if (!path || !*path) {
+        LOGE("HttpReq has no PATH, ERR\n");
+        HttpReqSimpleRsp(req, "400");
+        goto FAIL;
+    }
+
+    // 绮剧‘归path
+    const RscNode *node = HttpdFindRsc(path, method, &rscId);
+    // ユ惧け璐ユ讹ゆ瀛涓web GET璇锋
+    if (!node) {
+        if (method == HMC_GET) {
+            InnerWwwProc(NULL, req);
+            ret = 0;
+            goto END;
+        } else {
+            LOGE("unkn req{%s, %s}\n", path, HttpReqReqMethod(req));
+            HttpReqSimpleRsp(req, "404");
+            goto FAIL;
+        }
+    }
+
+    // 涓涓虹簿纭归澶 ...
+    // 规user娉ㄥsvcTypeHttpReq╁澶
+    if (node->ext && node->ext(req) < 0) {
+        LOGE("HttpReq ext FAIL, path='%s'\n", path);
+        HttpReqSimpleRsp(req, "500");
+        goto FAIL;
+    }
+
+    // 璁剧疆flags
+    if (node->flags) {
+        HttpReqAddFlag(req, node->flags);
+    }
+
+    // 璇锋锛朵delRef req
+    ret = HttpdDispatch(req, node, rscId);
+    goto END;
+
+    FAIL:
+        HttpReqDelRef(req);
+        ret = -1;
+
+    END:
+        MutexUnlock(&g_rscMutex);
+        return ret;
+}
+
+/**
+    server thread.
+*/
+static void* HttpdThrd(void *user)
+{
+    uint16_t port = (uint16_t)(uintptr_t)user;
+    int ret;
+
+    HI_ASSERT(g_httpSvr);
+    ret = HttpSvrStart(g_httpSvr, port, NULL, HttpdMux, NULL);
+    if (ret < 0) {
+        LOGE("start server FAIL, ret=%d\n", ret);
+        return NULL;
+    }
+
+    EmRun(g_evtMon);
+
+    HI_ASSERT(g_httpSvr);
+    HttpSvrStop(g_httpSvr);
+    return NULL;
+}
+
+/**
+    娉ㄥ澶.
+*/
+static int HttpdReqAny(const char* path, const char* methods, const RscNode* nodeInfo)
+{
+    HI_ASSERT(g_httpSvr);
+    int idleId = -1;
+    int i;
+    int ret;
+
+    MutexLock(&g_rscMutex);
+
+    // ゆpath宸茬娉ㄥ锛骞跺绘剧┖茬node
+    for (i = 0; i < sizeof(g_rscTab) / sizeof(*g_rscTab); i++) {
+        if (idleId < 0 && !g_rscTab[i].path) {
+            idleId = i;
+        }
+        if (g_rscTab[i].path && strcmp(g_rscTab[i].path, path) == 0) {
+            LOGE("reg FAIL, for '%s' exist\n", path);
+            ret = -1;
+            goto END;
+        }
+    }
+
+    // 瀵绘剧┖茬node
+    for (; idleId < 0 && i < sizeof(g_rscTab) / sizeof(*g_rscTab); i++) {
+        if (!g_rscTab[i].path) {
+            idleId = i;
+        }
+    }
+    if (idleId < 0) {
+        LOGE("reg FAIL, for tab full\n");
+        ret = -1;
+        goto END;
+    }
+
+    // 娉ㄥ
+    HI_ASSERT(!g_rscTab[idleId].proc);
+    g_rscTab[idleId] = *nodeInfo;
+    g_rscTab[idleId].path = path; // 涓存惰や负浼ョ甯搁
+    g_rscTab[idleId].methods = methods ? HttpMethodsToCodes(methods) : HMC_ALL;
+    if (!g_rscTab[idleId].methods) {
+        if (methods && strcmp(methods, "*") != 0) {
+            LOGW("HTTPD: reg '%s' with unkn methods '%s', regard '*'\n", path, methods);
+        }
+        g_rscTab[idleId].methods = HMC_ALL;
+    }
+    ret = 0;
+
+    END:
+        MutexUnlock(&g_rscMutex);
+        return ret;
+}
+
+/**
+    娉ㄥhttp澶.
+*/
+int HttpdRegHttp(const char* path, const char* methods,
+    HttpReqProc proc, void* user, SkPair evtChn, uint32_t flags)
+{
+    RscNode info = {
+        .proc = proc,
+        .user = user,
+        .ext = NULL,
+        .svcType = HST_HTTP,
+        .chnFd = evtChn.out,
+        .flags = flags
+    };
+    return HttpdReqAny(path, methods, &info);
+}
+
+/**
+    娉ㄥrapi澶.
+*/
+int HttpdRegRapi(const char* path,
+    HttpReqProc proc, void* user, SkPair evtChn)
+{
+    RscNode info = {
+        .proc = proc,
+        .user = user,
+        .ext = RapiReqInit,
+        .svcType = HST_RAPI,
+        .chnFd = evtChn.out,
+        .flags = 0
+    };
+    return HttpdReqAny(path, "POST", &info);
+}
+
+/*
+    娉ㄥsse澶
+*/
+int HttpdRegSse(const char* path,
+    HttpReqProc proc, void* user, SkPair evtChn)
+{
+    RscNode info = {
+        .proc = proc,
+        .user = user,
+        .ext = SseReqInit,
+        .svcType = HST_SSE,
+        .chnFd = evtChn.out,
+        .flags = 0
+    };
+    return HttpdReqAny(path, "GET", &info);
+}
+
+/**
+    娉ㄩ浠绘澶.
+*/
+int HttpdUnreg(const char* path)
+{
+    HI_ASSERT(g_httpSvr);
+    int i;
+
+    MutexLock(&g_rscMutex);
+
+    // ゆpath宸茬娉ㄥ锛骞跺绘剧┖茬node
+    for (i = 0; i < HI_ARRAY_SIZE(g_rscTab); i++) {
+        if (!g_rscTab[i].path) {
+            continue;
+        }
+
+        if (strcmp(g_rscTab[i].path, path) == 0) {
+            if (memset_s(&g_rscTab[i], sizeof(g_rscTab[i]), 0, sizeof(g_rscTab[i])) != EOK) {
+                HI_ASSERT(0);
+            }
+            break;
+        }
+    }
+
+    MutexUnlock(&g_rscMutex);
+    return i < HI_ARRAY_SIZE(g_rscTab) ? 0 : -1;
+}
+
+/**
+    httpd service init.
+*/
+int HttpdInit(uint16_t port)
+{
+    LOGI("HTTPD: init ...\n");
+    HI_ASSERT(!g_evtMon && !g_svcThrd && !g_httpSvr);
+
+    if (EmCreate(&g_evtMon) < 0) {
+        HI_ASSERT(0);
+    }
+    if (HttpSvrCreate(&g_httpSvr, g_evtMon, SVR_CRT_FILE, SVR_KEY_FILE) < 0) {
+        HI_ASSERT(0);
+    }
+
+    RecurMutexInit(&g_rscMutex);
+    if (memset_s(&g_rscTab, sizeof(g_rscTab), 0, sizeof(g_rscTab)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    if (port == 0 || port == 0xFFFF) {
+        port = GetCfgInt("lite_httpd:svr_port", SVR_PORT_DEF);
+    }
+    if (pthread_create(&g_svcThrd, NULL, HttpdThrd, (void*)(uintptr_t)port) < 0) {
+        HI_ASSERT(0);
+    }
+
+    InnerSvcInit();
+
+    LOGI("HTTPD: init done\n");
+    return 0;
+}
+
+/**
+    httpd service exit.
+*/
+int HttpdExit(void)
+{
+    LOGI("HTTPD: exit ...\n");
+    HI_ASSERT(g_httpSvr);
+
+    InnerSvcExit();
+
+    HI_ASSERT(g_evtMon && g_svcThrd);
+    EmQuit(g_evtMon);
+    pthread_join(g_svcThrd, NULL);
+    g_svcThrd = 0;
+
+    HI_ASSERT(g_httpSvr);
+    HttpSvrDestroy(g_httpSvr);
+    g_httpSvr = NULL;
+
+    HI_ASSERT(g_evtMon);
+    EmDestroy(g_evtMon);
+    g_evtMon = NULL;
+
+    MutexLock(&g_rscMutex);
+    if (memset_s(&g_rscTab, sizeof(g_rscTab), 0, sizeof(g_rscTab)) != EOK) {
+        HI_ASSERT(0);
+    }
+    MutexUnlock(&g_rscMutex);
+
+    MutexDestroy(&g_rscMutex);
+    if (memset_s(&g_rscMutex, sizeof(g_rscMutex), 0, sizeof(g_rscMutex)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    LOGI("HTTPD: exit done\n");
+    return 0;
+}
+
+/*************************************************************************************************
+    inner/demo service
+    httpdㄧ缃★www″rapi/sse/post demo.
+*************************************************************************************************/
+#define SP_INNER_SVC
+
+/**
+    inner/demo service const.
+*/
+#define URL_RAPI_DEMO       "/rapi/demo"
+#define URL_SSE_DEMO        "/sse/demo"
+#define URL_POST_DEMO       "/post/demo"
+#define URL_SPEED_TEST      "/post/speed_test"
+
+#define WWW_ROOT_DIR        "/www"
+
+/**
+    inner/demo servcie var.
+*/
+static int g_svcThrdNum = 0; // 姝ｅㄨ琛版＄嚎绋扮
+
+/**
+    sse澶绾跨锛浜х浜浠跺苟push.
+*/
+static void* SseDemoThrd(void *user)
+{
+    static const int evtNum = 5; // 浜浠舵扮
+    static const long waitIntval = 3; // 3s
+
+    HttpReq *req = (HttpReq*)user;
+    char data[TINY_BUF_SIZE];
+    int id;
+    int len;
+    int res;
+
+    for (id = 0, res = 0; res >= 0 && id < evtNum; id++) {
+        sleep(waitIntval);
+        len = snprintf_s(data, sizeof(data), sizeof(data) - 1, "evt#%d", id);
+        res = SseReqPush(req, id, NULL, data, len);
+    }
+
+    SseReqClose(req, 0);
+    HttpReqDelRef(req);
+    if (__sync_sub_and_fetch(&g_svcThrdNum, 1) < 0) {
+        HI_ASSERT(0);
+    }
+    return NULL;
+}
+
+/**
+    sse handle demo.
+*/
+static int SseDemoProc(void* user, SseReq* req)
+{
+    pthread_t thrdId;
+    int res;
+
+    res = SseReqReply(req, 0);
+    if (res < 0) {
+        return res;
+    }
+
+    __sync_add_and_fetch(&g_svcThrdNum, 1);
+    res = DetachThreadCreate(&thrdId, SseDemoThrd, req);
+    HI_ASSERT(res >= 0);
+    HI_ASSERT(thrdId);
+    return 0;
+}
+
+/**
+    褰RapiReq堕req body.
+*/
+static int RapiDemoProc(void* user, RapiReq* req)
+{
+    const char *inData;
+    int inLen;
+
+    inData = RapiReqInData(req, &inLen);
+    // client芥病request body锛浣跺RapiReqInit()宸插
+    HI_ASSERT(inData);
+    LOGI("HTTPD: on rapi, inLen=%d, inData=\n", inLen);
+    DOLOGI(HiDumpTxt(inData, inLen));
+
+    static const char outData[] = "{ \"hello\": \"rapi\" }";
+
+    // echo back request body to client
+    RapiReqReply(req, outData, sizeof(outData) - 1);
+    HttpReqDelRef(req);
+    return 0;
+}
+
+/**
+    浠跺澶绾跨锛澶涓浠.
+*/
+static void* PostDemoThrd(void *user)
+{
+    HttpReq *req = (HttpReq*)user;
+    MemBlk *blk = NULL;
+    HttpHdrs *hdrs = NULL;
+    const char* hval = NULL;
+    int64_t total = 0;
+    int len;
+    int res;
+
+    hval = HttpHdrsFind(HttpReqReqHdrs(req), HH_CONTENT_LENGTH, NULL);
+    len = hval ? atoi(hval) : -1;
+
+    LOGI("HTTPD: on POST, len=%d(KB)\n", len / HI_KB);
+    int64_t begTime = HiClockMs();
+    // read file blocks and send via HttpReq one by one
+    while ((res = HttpReqReadBody(req, &blk, false)) > 0) {
+        HI_ASSERT(blk);
+        total += blk->len;
+        MemBlkDelete(blk);
+    }
+
+    int64_t cost = HiClockMs() - begTime;
+    int64_t speed = total / cost * HI_MS_OF_SEC / HI_KB;
+    LOGI("HTTPD: on POST done, len=%jd(KB), speed=%jd(KB/s), cost=%jd\n", total / HI_KB, speed, cost);
+
+    // write headers
+    hdrs = HttpHdrsNew(0);
+    HI_ASSERT(hdrs);
+    HttpHdrsAdd(hdrs, HH_STATUS, -1, "200", -1);
+    HttpReqWriteHdrs(req, hdrs, true);
+    HttpHdrsDelete(hdrs);
+
+    HttpReqDelRef(req);
+    if (__sync_sub_and_fetch(&g_svcThrdNum, 1) < 0) {
+        HI_ASSERT(0);
+    }
+    return NULL;
+}
+
+/**
+    post file proc.
+*/
+static int PostDemoProc(void* user, HttpReq* req)
+{
+    pthread_t thrdId;
+    int ret;
+
+    __sync_add_and_fetch(&g_svcThrdNum, 1);
+    ret = DetachThreadCreate(&thrdId, PostDemoThrd, req);
+    HI_ASSERT(ret == 0);
+    return 0;
+}
+
+/**
+    www get one file thread.
+*/
+static void* InnerWwwThrd(void *user)
+{
+    HttpReq *req = (HttpReq*)user;
+    const char *ctt;
+    char buf[PATH_MAX];
+
+    // get file content-type by file ext name
+    ctt = FileExtToCtt(HttpReqReqPath(req));
+    if (!ctt) {
+        ctt = "*/*";
+    }
+    LOGD("HTTPD: FileGet rsp ctt='%s'\n", ctt);
+
+    if (snprintf_s(buf, sizeof(buf), sizeof(buf) - 1, "%s%s", WWW_ROOT_DIR, HttpReqReqPath(req)) < 0) {
+        HI_ASSERT(0);
+    }
+    HttpdGetFile(req, buf, ctt);
+
+    // sleep(10); // 澧澶讹for test only
+    HttpReqDelRef(req);
+    if (__sync_sub_and_fetch(&g_svcThrdNum, 1) < 0) {
+        HI_ASSERT(0);
+    }
+    return NULL;
+}
+
+/**
+    www get file proc.
+*/
+static int InnerWwwProc(void* user, HttpReq* req)
+{
+    pthread_t thrdId;
+    int ret;
+
+    __sync_add_and_fetch(&g_svcThrdNum, 1);
+    ret = DetachThreadCreate(&thrdId, InnerWwwThrd, req);
+    HI_ASSERT(ret == 0);
+    return 0;
+}
+
+/**
+    绛寰缃″.
+*/
+static void InnerSvcWait(long timeout)
+{
+    static const long timeoutDef = 15000; // 榛璁ょ寰s
+    static const long waitPerLoop = 100; // 寰涓姣娆＄寰ms
+
+    if (g_svcThrdNum == 0) {
+        return;
+    }
+    HI_ASSERT(g_svcThrdNum >= 0);
+
+    timeout = timeout < 0 ? timeoutDef : timeout;
+    LOGI("HTTPD: %d inner svc exist, wait %ldms ...\n", g_svcThrdNum, timeout);
+
+    int64_t begTime = HiClockMs();
+    while (g_svcThrdNum > 0 && HiClockMs() - begTime < timeout) {
+        usleep(waitPerLoop * HI_USLEEP_MS); // 姣娆＄寰100ms
+    }
+
+    if (g_svcThrdNum > 0) {
+        LOGE("HTTPD: wait inner svc end TIMEOUT, left=%d\n", g_svcThrdNum);
+    } else {
+        LOGI("HTTPD: wait inner svc end done, cost=%lldms ...\n", (HiClockMs() - begTime));
+    }
+}
+
+/**
+    inner service init.
+*/
+static void InnerSvcInit(void)
+{
+    const SkPair nullSkPair = {
+        .in = -1,
+        .out = -1
+    };
+    HttpdRegRapi(URL_RAPI_DEMO, RapiDemoProc, NULL, nullSkPair);
+    HttpdRegSse(URL_SSE_DEMO, SseDemoProc, NULL, nullSkPair);
+    HttpdRegHttp(URL_POST_DEMO, "POST", PostDemoProc, NULL, nullSkPair, 0);
+    HttpdRegHttp(URL_SPEED_TEST, "POST", PostDemoProc, NULL, nullSkPair, 0);
+}
+
+/**
+    inner service exit.
+*/
+static void InnerSvcExit(void)
+{
+    HttpdUnreg(URL_RAPI_DEMO);
+    HttpdUnreg(URL_SSE_DEMO);
+    HttpdUnreg(URL_POST_DEMO);
+    HttpdUnreg(URL_SPEED_TEST);
+    InnerSvcWait(-1);
+}
+
+/**
+    debug main.
+*/
+int HttpdDemoMain(int argc, const char* argv[])
+{
+    uint16_t port = argc > 1 ? (uint16_t)atoi(argv[1]) : 0;
+    char line[NORM_BUF_SIZE];
+
+    AppBaseInit(NULL);
+    if (HttpdInit(port) < 0) {
+        HI_ASSERT(0);
+    }
+
+    // 寰ユstdin戒护
+    while (true) {
+        if (!fgets(line, sizeof(line), stdin)) {
+            HI_ASSERT(0);
+            continue;
+        }
+        if (strcmp(line, "quit") == 0 || strcmp(line, "exit") == 0) {
+            break;
+        }
+        // 澶戒护 ...
+    }
+
+    if (HttpdExit() < 0) {
+        HI_ASSERT(0);
+    }
+    AppBaseExit();
+    return 0;
+}
+
diff -urpBN hiopenais/src/lite_http/lite_httpd.h hiopenais_modify/src/lite_http/lite_httpd.h
--- hiopenais/src/lite_http/lite_httpd.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/lite_http/lite_httpd.h	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,210 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef LITE_HTTPD_H
+#define LITE_HTTPD_H
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "http_req.h"
+#include "http_rapi.h"
+#include "http_sse.h"
+
+/**
+    @mainpage
+
+    httpd的核心为HttpReq分发，目前采用下述机制
+    A.  httpd收到client的http请求后，会创建HttpdEvt并发送给user注册的EvtChn。
+        HttpdEvt中会携带HttpReq对象，以及user注册的处理函数。
+    B.  user从EvtChn中读取到HttpdEvt后，调用HttpdEvt::proc执行实际处理。
+
+    该机制下，HttpReq实际处理函数的执行线程由user确定，避免了由httpd直接回调
+    user处理函数带来的各种问题。通常user选择主线程来执行HttpReq处理函数。
+
+    显然B对于所有user代码都是相同的，因此httpd提供了EvtChn事件处理器httpd_evt_proc。
+    httpd_evt_proc会读取EvtChn中的消息，实现B操作。
+
+    httpd还提供了httpd_mon_chn, HttpdUnmonChn, httpd_clear_chn工具函数，
+    用于更进一步简化user代码的书写。
+
+    在上述支持下，在没有事件系统的简易环境下，user代码只需要增加额外很少代码，
+    即可实现类似于事件系统的支持。
+
+    Usage DEMO
+        SkPair evtChn;
+        SkPairCreate(&evtChn); // 创建httpd EvtChn
+
+        // enable服务
+        HttpdMonChn(evtChn, NULL); // 监听EvtChn，由主线程来执行HttpReq处理函数
+        HttpdRegRapi("/aic/demo", "POST", on_rapi_demo, NULL, evtChn); // 注册http请求
+
+        ......
+
+        // disable服务
+        HttpdUnreg("/aic/demo"); // 注销http请求
+        HttpdUnmonChn(evtChn, NULL); // 取消监听EvtChn
+
+        // 退出处理
+        HttpdClearChn(evtChn);
+        SkPairDestroy(&evtChn);
+
+        // http请求处理函数，此demo中，其由主线程执行
+        int on_rapi_demo(void* user, HttpReq* req) {
+            ......
+        }
+
+    user在向分发模块注册handler时，可通过reg函数的flags参数HRF_REQ_BODY_ONE，
+    要求HttpReq将req body存储为一块数据。此时，HttpReq会在完成req body的接收后
+    才会emit事件，user也才能获得req body。
+*/
+#ifndef API_DESC_PAD
+#define API_DESC_PAD
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    httpd发送给user的事件类型.
+    httpd在分发HttpReq时，会向user注册的chn发送该类型的事件。
+*/
+typedef struct HttpdEvt {
+    HttpReq *req;
+    HttpReqProc proc;
+    void *user;
+}   HttpdEvt;
+
+/**
+    httpd service init.
+*/
+int HttpdInit(uint16_t port);
+
+/**
+    httpd service exit.
+*/
+int HttpdExit(void);
+
+/**
+    注册http/rapi/sse处理器.
+
+    同一个@param path，只能注册一次，多次注册会失败。
+
+    @param methods 指示支持的方法列表，以分号分割的字符串，例如"PUT;POST"，
+    置为NULL表示无限制，只要path匹配，则认为是监听的请求。
+
+    rapi只支持"POST", sse只支持"GET"，对应注册函数无@param methods。
+
+    关于分发机制@see @mainpage。
+
+    user应确保在监听期间，@param path均有效，即httpd不会复制其内容，而只会保存
+    其指针。因此，user通常应该使用常量来标识@param path。
+*/
+int HttpdRegHttp(const char* path, const char* methods,
+    HttpReqProc proc, void* user, SkPair evtChn, uint32_t flags);
+int HttpdRegRapi(const char* path,
+    HttpReqProc proc, void* user, SkPair evtChn);
+int HttpdRegSse(const char* path,
+    HttpReqProc proc, void* user, SkPair evtChn);
+
+/**
+    注销任意处理器.
+*/
+int HttpdUnreg(const char* path);
+
+/**
+    供user使用的httpd event处理函数.
+
+    httpd通过向EvtChn发送HttpdEvt事件来分发HttpReq。
+    user监听EvtChn时，可用此函数作为事件处理器。事件产生后，此函数将调用
+    user通过http_reg_xxx()注册的事件处理函数，实现对HttpReq的最终分发。
+
+    user通常可调用@function httpd_mon_evt()来简化书写。
+*/
+void HttpdEvtProc(void* user, int fd, uint32_t evts);
+
+/**
+    监听EvtChn with HttpdEvtProc.
+    使用@function HttpdEvtProc 作为事件处理器来监听EvtChn。user用其简化书写。
+*/
+static inline void HttpdMonChn(const SkPair chn, EvtMon* emon)
+{
+    if (EmAddFd(emon ? emon : MainEvtMon(), chn.in, FDE_IN, HttpdEvtProc, NULL) < 0) {
+        HI_ASSERT(0);
+    }
+}
+
+/**
+    取消对EvtChn的监听.
+*/
+static inline void HttpdUnmonChn(SkPair chn, EvtMon* emon)
+{
+    if (EmDelFd(emon ? emon : MainEvtMon(), chn.in) < 0) {
+        HI_ASSERT(0);
+    }
+}
+
+/**
+    清空httpd EvtChn中未被处理的消息.
+
+    user在退出时，可调用此函数清空EvtChn中未被处理的事件。
+
+    NOTE: user应调用@function httpd_unreg注销HttpReq处理器，取消对EvtChn的监听，
+    最后再调用此函数clear。否则，clear后EvtChn中可能还会收到事件。
+*/
+static inline void HttpdClearChn(SkPair chn)
+{
+    HttpdEvt evt = {0};
+    while (FdReadMsg(chn.in, &evt, sizeof(evt)) == sizeof(evt)) {
+        HI_ASSERT(evt.req);
+        HttpReqReset(evt.req, 0);
+        HttpReqDelRef(evt.req);
+    }
+}
+
+/**
+    HTTP GET file server侧处理工具函数.
+
+    user可调用该函数来处理client的file get请求。此函数会打开file Path指定的本地文件，
+    通过HttpReq发送给client。
+
+    无论操作是否成功，此函数均会向client发送响应，完成HttpReq。
+
+    注意此函数以阻塞方式执行，user应注意其执行线程是否允许阻塞。
+*/
+int HttpdGetFile(HttpReq* req, const char* filePath, const char* ctt);
+
+/**
+    HTTP PUT file server侧处理工具函数.
+
+    user可调用该函数来处理client的file put请求。此函数会打开file Path指定的本地文件，
+    将client通过HttpReq发送的数据写入到本地文件中。
+
+    注意此函数以阻塞方式执行，user应注意其执行线程是否允许阻塞。
+
+    @param reply 指示是否在此函数中向client发送响应，完成HttpReq。
+*/
+int HttpdPutFile(HttpReq* req, const char* filePath, bool reply);
+
+/**
+    demo main.
+*/
+int HttpdDemoMain(int argc, const char* argv[]);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // LITE_HTTPD_H
diff -urpBN hiopenais/src/mpp_help/ive_img.c hiopenais_modify/src/mpp_help/ive_img.c
--- hiopenais/src/mpp_help/ive_img.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/mpp_help/ive_img.c	2021-07-01 19:43:32.000000000 -0700
@@ -0,0 +1,827 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include "hi_comm_vb.h"
+#include "mpi_sys.h"
+#include "hi_osd.h"
+#include "sample_comm.h"
+
+#include "hi_ext_util.h"
+#include "ive_img.h"
+
+/**
+    consts
+*/
+#define IMG_FULL_CHN    3 // 全通道/三通道, for YUV444, RGB888
+#define IMG_HALF_CHN    2 // 半通道，for YUV420/422
+#define THREE_TIMES     3
+#define TWO_TIMES       2
+
+/**
+    对齐类型.
+*/
+typedef enum AlignType {
+    ALIGN_TYPE_2 = 2, // 按2byte对齐
+    ALIGN_TYPE_16 = 16, // 按16byte对齐
+    ALIGN_TYPE_32 = 32, // 按32byte对齐
+}   AlignType;
+
+/**
+    为ive resize ctrl等结构分配内存.
+*/
+static int IveCtrlAlloc(IVE_MEM_INFO_S *memInfo, uint32_t size, bool cached)
+{
+    HI_ASSERT(memInfo && size > 0);
+    int ret;
+
+    if (cached) {
+        ret = HI_MPI_SYS_MmzAlloc_Cached(&memInfo->u64PhyAddr,
+            (void**)&memInfo->u64VirAddr, NULL, NULL, size);
+    } else {
+        ret = HI_MPI_SYS_MmzAlloc(&memInfo->u64PhyAddr,
+            (void**)&memInfo->u64VirAddr, NULL, NULL, size);
+    }
+    HI_ASSERT(!ret);
+
+    memInfo->u32Size = size;
+    return ret;
+}
+
+/**
+    释放为ive resize ctrl等分配的内存.
+*/
+static void IveCtrlFree(IVE_MEM_INFO_S *memInfo)
+{
+    if (HI_MPI_SYS_MmzFree(memInfo->u64PhyAddr, (void*)((uintptr_t)memInfo->u64VirAddr)) < 0) {
+        HI_ASSERT(0);
+    }
+
+    memInfo->u64PhyAddr = 0;
+    memInfo->u64VirAddr = 0;
+}
+
+/**
+    ive image copy via CPU.
+*/
+static HI_S32 IveCpuCopy(IVE_DATA_S *src, IVE_DATA_S *dst)
+{
+    HI_U8 *srcBuf = (HI_U8*)((uintptr_t)src->u64VirAddr);
+    HI_U8 *dstBuf = (HI_U8*)((uintptr_t)dst->u64VirAddr);
+
+    for (uint32_t i = 0; i < src->u32Height; i++) {
+        for (uint32_t j = 0; j < src->u32Width; j++) {
+            dstBuf[i * dst->u32Stride + j] = srcBuf[i * src->u32Stride + j];
+        }
+    }
+    return HI_SUCCESS;
+}
+
+/**
+    ive image DMA copy.
+*/
+HI_S32 IveDmaCopy(IVE_HANDLE *iveHnd, IVE_DATA_S *src,
+    IVE_DST_DATA_S *dst, IVE_DMA_CTRL_S *dmaCtrl, HI_BOOL instant)
+{
+    static const uint32_t widthLow = 32;
+    static const uint32_t heightLow = 32;
+    static const int intvalNs = 100;
+    HI_S32 ret;
+    HI_BOOL finish = HI_FALSE;
+    struct timespec reqIntval;
+
+    reqIntval.tv_sec = 0;
+    reqIntval.tv_nsec = ((long)intvalNs) * HI_NS_OF_MS;
+
+    if ((src->u32Height < heightLow) || (src->u32Width < widthLow)) {
+        return IveCpuCopy(src, dst);
+    } else {
+        ret = HI_MPI_IVE_DMA(iveHnd, src, dst, dmaCtrl, instant);
+        if (instant && (ret == HI_SUCCESS)) {
+            ret = HI_MPI_IVE_Query(*iveHnd, &finish, HI_TRUE);
+            while (ret == HI_ERR_IVE_QUERY_TIMEOUT) {
+                nanosleep(&reqIntval, NULL);
+                LOGW("HI_MPI_IVE_Query timeout, wait 100us\n");
+                ret = HI_MPI_IVE_Query(*iveHnd, &finish, HI_TRUE);
+            }
+        }
+        return ret;
+    }
+}
+
+/**
+    计算一个通道的stride.
+*/
+static uint32_t IveCalStride(IVE_IMAGE_TYPE_E enType, uint32_t width, AlignType align)
+{
+    uint32_t size = 1;
+
+    switch (enType) {
+        case IVE_IMAGE_TYPE_U8C1:
+        case IVE_IMAGE_TYPE_S8C1:
+        case IVE_IMAGE_TYPE_S8C2_PACKAGE:
+        case IVE_IMAGE_TYPE_S8C2_PLANAR:
+        case IVE_IMAGE_TYPE_U8C3_PACKAGE:
+        case IVE_IMAGE_TYPE_U8C3_PLANAR:
+            size = sizeof(HI_U8);
+            break;
+        case IVE_IMAGE_TYPE_S16C1:
+        case IVE_IMAGE_TYPE_U16C1:
+            size = sizeof(HI_U16);
+            break;
+        case IVE_IMAGE_TYPE_S32C1:
+        case IVE_IMAGE_TYPE_U32C1:
+            size = sizeof(uint32_t);
+            break;
+        case IVE_IMAGE_TYPE_S64C1:
+        case IVE_IMAGE_TYPE_U64C1:
+            size = sizeof(uint64_t);
+            break;
+        default:
+            break;
+    }
+
+    if (align == ALIGN_TYPE_16) {
+        return HI_ALIGN16(width * size);
+    } else if (align == ALIGN_TYPE_32) {
+        return HI_ALIGN32(width * size);
+    } else {
+        HI_ASSERT(0);
+        return 0;
+    }
+}
+
+/**
+    为image各通道赋初值.
+*/
+void IveImgSet(IVE_IMAGE_S* img, HI_U8 c1, HI_U8 c2, HI_U8 c3)
+{
+    uint32_t oneChnSize = img->au32Stride[0] * img->u32Height;
+
+    int chnId = 0;
+    if (memset_s((HI_U8*)((uintptr_t)img->au64VirAddr[chnId]), oneChnSize, (int)c1, oneChnSize) != EOK) {
+        HI_ASSERT(0);
+    }
+    chnId++;
+    if (memset_s((HI_U8*)((uintptr_t)img->au64VirAddr[chnId]), oneChnSize, (int)c2, oneChnSize) != EOK) {
+        HI_ASSERT(0);
+    }
+    chnId++;
+    if (memset_s((HI_U8*)((uintptr_t)img->au64VirAddr[chnId]), oneChnSize, (int)c3, oneChnSize) != EOK) {
+        HI_ASSERT(0);
+    }
+}
+
+/**
+    根据type和size创建ive image buffer.
+*/
+int IveImgCreate(IVE_IMAGE_S* img,
+    IVE_IMAGE_TYPE_E enType, uint32_t width, uint32_t height)
+{
+    HI_ASSERT(img);
+    uint32_t oneChnSize;
+    uint32_t size;
+    int ret;
+
+    if (memset_s(img, sizeof(*img), 0, sizeof(*img)) != EOK) {
+        HI_ASSERT(0);
+    }
+    img->enType = enType;
+    img->u32Width = width;
+    img->u32Height = height;
+    img->au32Stride[0] = IveCalStride(img->enType, img->u32Width, ALIGN_TYPE_16);
+
+    switch (enType) {
+        case IVE_IMAGE_TYPE_U8C1:
+        case IVE_IMAGE_TYPE_S8C1: // 只有1个通道
+            size = img->au32Stride[0] * img->u32Height;
+            ret = HI_MPI_SYS_MmzAlloc(&img->au64PhyAddr[0], (void**)&img->au64VirAddr[0], NULL, NULL, size);
+            HI_CHK_RET(ret, "Mmz Alloc FAIL, err=%#x\n", ret);
+            break;
+
+        case IVE_IMAGE_TYPE_YUV420SP: // size相当于像素的1.5倍(3/2)，相当于2通道
+        case IVE_IMAGE_TYPE_YUV422SP: // size相当于像素的2倍，相当于2通道
+            if (enType == IVE_IMAGE_TYPE_YUV420SP) {
+                size = img->au32Stride[0] * img->u32Height * THREE_TIMES / TWO_TIMES;
+            } else {
+                size = img->au32Stride[0] * img->u32Height * TWO_TIMES;
+            }
+            ret = HI_MPI_SYS_MmzAlloc(&img->au64PhyAddr[0], (void**)&img->au64VirAddr[0], NULL, NULL, size);
+            HI_CHK_RET(ret, "Mmz Alloc FAIL, ret=%#x\n", ret);
+
+            // 设置通道1的地址的stride，二者都需要通道1
+            img->au32Stride[1] = img->au32Stride[0];
+            img->au64PhyAddr[1] = img->au64PhyAddr[0] + img->au32Stride[0] * (uint64_t)img->u32Height;
+            img->au64VirAddr[1] = img->au64VirAddr[0] + img->au32Stride[0] * (uint64_t)img->u32Height;
+            break;
+
+        case IVE_IMAGE_TYPE_U8C3_PLANAR: // 3通道,常用于RGB
+            oneChnSize = img->au32Stride[0] * img->u32Height;
+            size = oneChnSize * 3; // 3个通道size相同
+            ret = HI_MPI_SYS_MmzAlloc(&img->au64PhyAddr[0], (void**)&img->au64VirAddr[0], NULL, NULL, size);
+            HI_CHK_RET(ret, "Mmz Alloc FAIL, ret=%#x\n", ret);
+
+            // 设置通道1，通道2的地址与stride
+            img->au64VirAddr[1] = img->au64VirAddr[0] + oneChnSize;
+            img->au64PhyAddr[1] = img->au64PhyAddr[0] + oneChnSize;
+            img->au32Stride[1] = img->au32Stride[0];
+            img->au64VirAddr[2] = img->au64VirAddr[1] + oneChnSize; // 2: au64VirAddr数组下标,不越界
+            img->au64PhyAddr[2] = img->au64PhyAddr[1] + oneChnSize; // 2: au64VirAddr数组下标,不越界
+            img->au32Stride[2] = img->au32Stride[0]; // 2: au64VirAddr数组下标,不越界
+            break;
+
+        // 暂不支持的type: YVC420P, YUV422P, S8C2_PACKAGE, S8C2_PLANAR,
+        // S32C1, U32C1, S64C1, U64C1, S16C1, U16C1, U8C3_PACKAGE,etc.
+        default:
+            HI_ASSERT(0);
+            break;
+    }
+    return HI_SUCCESS;
+}
+
+/**
+    销毁ive Image.
+*/
+void IveImgDestroy(IVE_IMAGE_S* img)
+{
+    for (int i = 0; i < IMG_FULL_CHN; i++) {
+        if (img->au64PhyAddr[0] && img->au64VirAddr[0]) {
+            HI_MPI_SYS_MmzFree(img->au64PhyAddr[i], (void*)((uintptr_t)img->au64VirAddr[i]));
+            img->au64PhyAddr[i] = 0;
+            img->au64VirAddr[i] = 0;
+        }
+    }
+    if (memset_s(img, sizeof(*img), 0, sizeof(*img)) != EOK) {
+        HI_ASSERT(0);
+    }
+}
+
+/**
+    用IVE执行一次图像缩放.
+    只支持U8C3/U8C1 planer，即RGB, BGR等，不支持YUV。
+*/
+static int IveResizeOnce(const IVE_IMAGE_S *src, IVE_IMAGE_S *dst, uint32_t dstWidth, uint32_t dstHeight)
+{
+    static const uint32_t resizeCtrlNum = 49;
+    IVE_RESIZE_CTRL_S resizeCtrl = { 0 };
+    IVE_HANDLE iveHnd;
+    HI_BOOL finish = HI_FALSE;
+    int ret;
+
+    HI_ASSERT((src->u32Height % HI_OVEN_BASE) == 0 && (src->u32Width % HI_OVEN_BASE) == 0);
+
+    // 准备resizeCtrl
+    resizeCtrl.enMode = IVE_RESIZE_MODE_LINEAR;
+    resizeCtrl.u16Num = 1;
+    // pstResizeCtrl.stMem内存至少需要25*U8C1_NUM + 49 * (pstResizeCtrl->u16Num - U8C1_NUM)字节，
+    // 其中U8C1_NUM为混合图像数组中U8C1图像的数目。
+    ret = IveCtrlAlloc(&resizeCtrl.stMem, resizeCtrlNum * resizeCtrl.u16Num, false);
+    HI_ASSERT(!ret);
+
+    // 创建空的dst img
+    ret = IveImgCreate(dst, src->enType, dstWidth, dstHeight);
+    HI_ASSERT(!ret);
+
+    // resize request
+    ret = HI_MPI_IVE_Resize(&iveHnd, (IVE_IMAGE_S*)src, dst, &resizeCtrl, HI_TRUE);
+    HI_CHK_GOTO(ret, FAIL, "HI_MPI_IVE_Resize fail:%#x\n", ret);
+
+    // waiting resize result, blocking
+    ret = HI_MPI_IVE_Query(iveHnd, &finish, HI_TRUE);
+    HI_CHK_GOTO(ret, FAIL, "Error(%#x), HI_MPI_IVE_Query failed!\n", ret);
+    goto END;
+
+    FAIL:
+        IveImgDestroy(dst);
+        if (memset_s(dst, sizeof(*dst), 0, sizeof(*dst)) != EOK) {
+            HI_ASSERT(0);
+        }
+
+    END:
+        if (resizeCtrl.stMem.u64VirAddr) {
+            IveCtrlFree(&resizeCtrl.stMem);
+        }
+        return ret;
+}
+
+/**
+    resize ive image.
+
+    多次调用ive_resize以实现任意比例的缩放。
+    为简化实现，约定每次缩放最大14倍，此时宽、高仅需2像素对齐。
+
+    当两个方向缩放方向不同时，例如一向(如X)放大，另一向缩小倍，无需特别处理。
+    此时某个方向或两个方向缩放比例均超标，也不需要特别处理。
+*/
+int IveImgResize(
+    const IVE_IMAGE_S *src, IVE_IMAGE_S *dst,
+    uint32_t dstWidth, uint32_t dstHeight)
+{
+    static const double rateMax = 14.0; // 放大的最大倍数
+    static const double rateMin = 1.0 / rateMax; // 放大的最小倍数，也即缩小的最大比例
+
+    uint32_t srcWidth = src->u32Width;
+    uint32_t srcHeight = src->u32Height;
+    HI_ASSERT(srcWidth > 0 && srcHeight > 0);
+    HI_ASSERT(!(srcWidth % HI_OVEN_BASE) && !(srcHeight % HI_OVEN_BASE));
+    HI_ASSERT(dstWidth > 0 && dstHeight > 0);
+    HI_ASSERT(!(dstWidth % HI_OVEN_BASE) && !(dstHeight % HI_OVEN_BASE));
+    int ret;
+
+    // 放大倍数
+    double widthRate = ((double)dstWidth) / (double)srcWidth; // >1表示放大，<1表示缩小
+    double heightRate = ((double)dstHeight) / (double)srcHeight; // >1表示放大，<1表示缩小
+
+    // 根据缩放倍数分别处理
+    if (widthRate > rateMax || widthRate < rateMin ||
+        heightRate > rateMax || heightRate < rateMin) {
+        // 缩放倍数超过一次IVE resize的最大值时，递归处理 ...
+        uint32_t midWidth = (uint32_t)IntZoomTo((int)srcWidth, widthRate, rateMin, rateMax);
+        uint32_t midHeight = (uint32_t)IntZoomTo((int)srcHeight, heightRate, rateMin, rateMax);
+        // 确保为偶数。为奇数时，放大则减一，否则加一
+        if (midWidth % HI_OVEN_BASE) {
+            midWidth += widthRate > 1 ? -1 : 1;
+        }
+        if (midHeight % HI_OVEN_BASE) {
+            midHeight += heightRate > 1 ? -1 : 1;
+        }
+
+        LOGD("@@@ multi-lev ive resize, src={%u, %u}, mid={%u, %u}, dst={%u, %u}, rate={%.4f, %.4f}\n",
+            srcWidth, srcHeight, midWidth, midHeight, dstWidth, dstHeight, widthRate, heightRate);
+
+        // 缩放一次
+        IVE_IMAGE_S midImg;
+        ret = IveResizeOnce(src, &midImg, midWidth, midHeight);
+        HI_CHK_RET(ret, "IveResizeOnce(dw=%u, dh=%u) FAIL\n", midWidth, midHeight);
+
+        // 以midImg为srcImg递归调用
+        ret = IveImgResize(&midImg, dst, dstWidth, dstHeight);
+        IveImgDestroy(&midImg);
+        HI_CHK_RET(ret, "sub call IveImgResize(dw=%u, dh=%u) FAIL\n", dstWidth, dstHeight);
+    } else { // 缩放倍数未超过一次IVE resize的最大值，直接完成
+        ret = IveResizeOnce(src, dst, dstWidth, dstHeight);
+        HI_CHK_RET(ret, "IveResizeOnce(dw=%u, dh=%u) FAIL\n", dstWidth, dstHeight);
+    }
+    return ret;
+}
+
+/**
+    ive image RGB to YUV.
+*/
+int ImgRgbToYuv(IVE_IMAGE_S *src, IVE_IMAGE_S *dst, IVE_IMAGE_TYPE_E dstType)
+{
+    IVE_HANDLE iveHnd;
+    HI_BOOL finish;
+    HI_S32 ret;
+
+    if (memset_s(dst, sizeof(*dst), 0, sizeof(*dst)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    ret = IveImgCreate(dst, dstType, src->u32Width, src->u32Height);
+    HI_CHK_RET(ret, "IveImgCreate FAIL, ret=%#x\n", ret);
+
+    IVE_CSC_CTRL_S stCSCCtrl = { IVE_CSC_MODE_VIDEO_BT601_RGB2YUV};
+    ret = HI_MPI_IVE_CSC(&iveHnd, src, dst, &stCSCCtrl, HI_TRUE);
+    HI_CHK_RET(ret, "HI_MPI_IVE_CSC FAIL, ret=%#x\n", ret);
+
+    ret = HI_MPI_IVE_Query(iveHnd, &finish, HI_TRUE);
+    HI_CHK_RET(ret, "HI_MPI_IVE_Query FAIL, ret=%#x\n", ret);
+    return ret;
+}
+
+/**
+    ive image RGB to BGR.
+*/
+int ImgRgbToBgr(IVE_IMAGE_S *img)
+{
+    uint8_t *rp = NULL;
+    uint8_t *bp = NULL;
+    uint8_t c;
+    int i, j;
+
+    // 用IVE DMA替代，以提升性能
+    HI_ASSERT(img->enType == IVE_IMAGE_TYPE_U8C3_PLANAR);
+    HI_ASSERT(img->au32Stride[0] >= img->u32Width);
+    HI_ASSERT(img->au32Stride[1] >= img->u32Width);
+    HI_ASSERT(img->au32Stride[2] >= img->u32Width); // 2: au32Stride数组下标,不越界
+
+    rp = (uint8_t*)(uintptr_t)img->au64VirAddr[0];
+    bp = (uint8_t*)(uintptr_t)img->au64VirAddr[2]; // 2: VirAddr数组下标,不越界
+    HI_ASSERT(rp && bp);
+    for (i = 0; i < img->u32Height; i++) {
+        for (j = 0; j < img->u32Width; j++) {
+            c = rp[j];
+            rp[j] = bp[j];
+            bp[j] = c;
+        }
+        rp += img->au32Stride[0];
+        bp += img->au32Stride[2]; // 2: au32Stride数组下标,不越界
+    }
+    return 0;
+}
+
+/**
+    cut YUV P/SP image to U8C1 image (灰度图像).
+*/
+int ImgYuvCropU8c1(
+    const IVE_IMAGE_S *src, IVE_IMAGE_S *dst,
+    const RectBox* origBox, int dstWidth, int dstHeight)
+{
+    RectBox box = *origBox;
+    int boxWidth = box.xmax - box.xmin + 1;
+    int boxHeight = box.ymax - box.ymin + 1;
+    int ret;
+
+    HI_ASSERT(boxWidth > 0 && boxWidth <= src->u32Width);
+    HI_ASSERT(boxHeight > 0 && boxHeight <= src->u32Height);
+    HI_ASSERT(src->au64VirAddr[0]);
+    HI_ASSERT(src->au32Stride[0] >= src->u32Width);
+
+    // box的width/height调整为2的倍数
+    if (boxWidth == 1 || boxHeight == 1) {
+        LOGE("box dstWidth=1 && dstHeight=1\n");
+        return -1;
+    }
+    if (boxWidth % HI_OVEN_BASE) {
+        box.xmax--;
+        boxWidth--;
+    }
+    if (boxHeight % HI_OVEN_BASE) {
+        box.ymax--;
+        boxHeight--;
+    }
+
+    // 创建空的dst img
+    ret = IveImgCreate(dst, IVE_IMAGE_TYPE_U8C1, boxWidth, boxHeight);
+    HI_ASSERT(!ret);
+
+    // 用IVE DMA来复制，以提升性能
+    // copy box from src to dst
+    int srcStride = src->au32Stride[0];
+    int dstStride = dst->au32Stride[0];
+    uint8_t *srcBuf = (uint8_t*)((uintptr_t)src->au64VirAddr[0]);
+    uint8_t *dstBuf = (uint8_t*)((uintptr_t)dst->au64VirAddr[0]);
+    uint8_t *srcPtr = &srcBuf[box.ymin * srcStride];
+    uint8_t *dstPtr = dstBuf;
+    for (int h = 0; h < boxHeight; h++, srcPtr += srcStride, dstPtr += dstStride) {
+        if (memcpy_s(dstPtr, boxWidth, srcPtr + box.xmin, boxWidth) != EOK) {
+            HI_ASSERT(0);
+        }
+    }
+    HI_ASSERT(dstPtr - dstBuf == boxHeight * dstStride);
+
+    // 当user未指定dstWidth/dstHeight，或指定的值与box相同时，无需resize
+    if (dstWidth <= 0 || dstHeight <= 0 ||
+        (dstWidth == boxWidth && dstHeight == boxHeight)) {
+        return 0;
+    }
+
+    // resize
+    IVE_IMAGE_S realDst;
+    ret = IveImgResize(dst, &realDst, dstWidth, dstHeight);
+    IveImgDestroy(dst);
+    HI_CHK_RET(ret, "yuv_cut_to_u8c1 FAIL, ret=%X\n", ret);
+    *dst = realDst;
+    return ret;
+}
+
+/**
+    video YUV frame to ive image (U8C1).
+*/
+int FrmToU8c1Img(const VIDEO_FRAME_INFO_S* frm, IVE_IMAGE_S *img)
+{
+    PIXEL_FORMAT_E pixelFormat = frm->stVFrame.enPixelFormat;
+
+    if (memset_s(img, sizeof(*img), 0, sizeof(*img)) != EOK) {
+        HI_ASSERT(0);
+    }
+    if (pixelFormat != PIXEL_FORMAT_YVU_SEMIPLANAR_420 &&
+        pixelFormat == PIXEL_FORMAT_YVU_SEMIPLANAR_422) {
+        LOGE("FrmToU8c1Img() only supp yuv420sp/yuv422sp\n");
+        HI_ASSERT(0);
+        return -1;
+    }
+
+    img->enType = IVE_IMAGE_TYPE_U8C1;
+    img->u32Width = frm->stVFrame.u32Width;
+    img->u32Height = frm->stVFrame.u32Height;
+
+    img->au64PhyAddr[0] = frm->stVFrame.u64PhyAddr[0];
+    img->au64VirAddr[0] = frm->stVFrame.u64VirAddr[0];
+    img->au32Stride[0] = frm->stVFrame.u32Stride[0];
+    return 0;
+}
+
+/**
+    YUV video frame to RGB ive image.
+*/
+int FrmToRgbImg(VIDEO_FRAME_INFO_S* srcFrm, IVE_DST_IMAGE_S *dstImg)
+{
+    HI_ASSERT(srcFrm && dstImg);
+    const static int chnNum = 3;
+    IVE_HANDLE iveHnd;
+    IVE_SRC_IMAGE_S srcImg;
+    HI_BOOL finish;
+    int ret;
+
+    if (memset_s(&srcImg, sizeof(srcImg), 0, sizeof(srcImg)) != EOK) {
+        HI_ASSERT(0);
+    }
+    srcImg.u32Width = srcFrm->stVFrame.u32Width;
+    srcImg.u32Height = srcFrm->stVFrame.u32Height;
+
+    PIXEL_FORMAT_E enPixelFormat = srcFrm->stVFrame.enPixelFormat;
+    if (enPixelFormat == PIXEL_FORMAT_YVU_SEMIPLANAR_420) {
+        srcImg.enType = IVE_IMAGE_TYPE_YUV420SP;
+    } else if (enPixelFormat == PIXEL_FORMAT_YVU_SEMIPLANAR_422) {
+        srcImg.enType = IVE_IMAGE_TYPE_YUV422SP;
+    } else {
+        HI_ASSERT(0);
+        return -1;
+    }
+
+    // 分别复制3个通道的地址
+    for (int i = 0; i < chnNum; i++) {
+        srcImg.au64PhyAddr[i] = srcFrm->stVFrame.u64PhyAddr[i];
+        srcImg.au64VirAddr[i] = srcFrm->stVFrame.u64VirAddr[i];
+        srcImg.au32Stride[i] = srcFrm->stVFrame.u32Stride[i];
+    }
+
+    ret = IveImgCreate(dstImg, IVE_IMAGE_TYPE_U8C3_PLANAR, srcImg.u32Width, srcImg.u32Height);
+    HI_CHK_RET(ret, "IveImgCreate FAIL, ret=%#x\n", ret);
+
+    IVE_CSC_CTRL_S stCSCCtrl = { IVE_CSC_MODE_PIC_BT601_YUV2RGB};
+    ret = HI_MPI_IVE_CSC(&iveHnd, &srcImg, dstImg, &stCSCCtrl, HI_TRUE);
+    HI_CHK_GOTO(ret, FAIL, "HI_MPI_IVE_CSC failed!\n");
+
+    ret = HI_MPI_IVE_Query(iveHnd, &finish, HI_TRUE);
+    HI_CHK_GOTO(ret, FAIL, "HI_MPI_IVE_Query failed!\n");
+    return ret;
+
+    FAIL:
+        IveImgDestroy(dstImg);
+        return ret;
+}
+
+/**
+    video frame to ive image.
+    复制数据指针，不复制数据。
+*/
+int FrmToOrigImg(const VIDEO_FRAME_INFO_S* frm, IVE_IMAGE_S *img)
+{
+    static const int chnNum = 2; // 目前只支持YUV420/422，因此只复制2个通道的地址
+    PIXEL_FORMAT_E pixelFormat = frm->stVFrame.enPixelFormat;
+
+    if (memset_s(img, sizeof(*img), 0, sizeof(*img)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    img->u32Width = frm->stVFrame.u32Width;
+    img->u32Height = frm->stVFrame.u32Height;
+
+    if (pixelFormat == PIXEL_FORMAT_YVU_SEMIPLANAR_420) {
+        img->enType = IVE_IMAGE_TYPE_YUV420SP;
+    } else if (pixelFormat == PIXEL_FORMAT_YVU_SEMIPLANAR_422) {
+        img->enType = IVE_IMAGE_TYPE_YUV422SP;
+    } else {
+        HI_ASSERT(0);
+        return -1;
+    }
+
+    for (int i = 0; i < chnNum; i++) {
+        img->au64PhyAddr[i] = frm->stVFrame.u64PhyAddr[i];
+        img->au64VirAddr[i] = frm->stVFrame.u64VirAddr[i];
+        img->au32Stride[i] = frm->stVFrame.u32Stride[i];
+    }
+    return 0;
+}
+
+int OrigImgToFrm(const IVE_IMAGE_S *img, VIDEO_FRAME_INFO_S* frm)
+{
+	static const int chnNum = 2;
+	IVE_IMAGE_TYPE_E enType = img->enType;
+	if (memset_s(frm, sizeof(*frm), 0, sizeof(*frm)) != EOK) {
+       	 HI_ASSERT(0);
+    }
+
+	frm->stVFrame.u32Width = img->u32Width;
+   	frm->stVFrame.u32Height = img->u32Height;
+
+	if (enType == IVE_IMAGE_TYPE_YUV420SP) {
+        frm->stVFrame.enPixelFormat = PIXEL_FORMAT_YVU_SEMIPLANAR_420;
+    } else if (enType == IVE_IMAGE_TYPE_YUV422SP) {
+        frm->stVFrame.enPixelFormat = PIXEL_FORMAT_YVU_SEMIPLANAR_422;
+    } else {
+        HI_ASSERT(0);
+        return -1;
+    }
+	
+	for (int i = 0; i < chnNum; i++) {
+        frm->stVFrame.u64PhyAddr[i] = img->au64PhyAddr[i];
+        frm->stVFrame.u64VirAddr[i] = img->au64VirAddr[i];
+        frm->stVFrame.u32Stride[i] = img->au32Stride[i];
+    }
+	return 0;
+}
+
+int ImgYuvCrop(const IVE_IMAGE_S *src, IVE_IMAGE_S *dst, const RectBox* origBox)
+{
+	RectBox box = *origBox;
+    int boxWidth = box.xmax - box.xmin;
+    int boxHeight = box.ymax - box.ymin;
+    int ret;
+    
+    HI_ASSERT(boxWidth > 0 && boxWidth <= src->u32Width);
+    HI_ASSERT(boxHeight > 0 && boxHeight <= src->u32Height);
+    HI_ASSERT(src->au64VirAddr[0]);
+    HI_ASSERT(src->au32Stride[0] >= src->u32Width);
+
+    // box的width/height调整为2的倍数
+    if (boxWidth == 1 || boxHeight == 1) {
+        LOGE("box dstWidth=1 && dstHeight=1\n");
+        return -1;
+    }
+    if (boxWidth % HI_OVEN_BASE) {
+        box.xmax--;
+        boxWidth--;
+    }
+    if (boxHeight % HI_OVEN_BASE) {
+        box.ymax--;
+        boxHeight--;
+    }
+    // 创建空的dst img
+    ret = IveImgCreate(dst, src->enType, boxWidth, boxHeight);
+    HI_ASSERT(!ret); 
+    // 用IVE DMA来复制，以提升性能
+    // copy box from src to dst
+	// Y
+	int srcStrideY = src->au32Stride[0];
+    int dstStrideY = dst->au32Stride[0];
+    uint8_t *srcBufY = (uint8_t*)((uintptr_t)src->au64VirAddr[0]);
+    uint8_t *dstBufY = (uint8_t*)((uintptr_t)dst->au64VirAddr[0]);
+    uint8_t *srcPtrY = &srcBufY[box.ymin * srcStrideY];
+    uint8_t *dstPtrY = dstBufY;
+    for (int h = 0; h < boxHeight; h++, srcPtrY += srcStrideY, dstPtrY += dstStrideY) {
+        if (memcpy_s(dstPtrY, boxWidth, srcPtrY + box.xmin, boxWidth) != EOK) {
+            HI_ASSERT(0);
+        }
+    }
+    HI_ASSERT(dstPtrY - dstBufY == boxHeight * dstStrideY);
+	
+	// UV
+	int srcStrideUV = src->au32Stride[1];
+    int dstStrideUV = dst->au32Stride[1];
+    uint8_t *srcBufUV = (uint8_t*)((uintptr_t)src->au64VirAddr[1]);
+    uint8_t *dstBufUV= (uint8_t*)((uintptr_t)dst->au64VirAddr[1]);
+    uint8_t *srcPtrUV = &srcBufUV[(box.ymin / 2) * srcStrideUV];
+    uint8_t *dstPtrUV= dstBufUV;
+    for (int h = 0; h < (boxHeight / 2); h++, srcPtrUV += srcStrideUV, dstPtrUV += dstStrideUV) {
+        if (memcpy_s(dstPtrUV, boxWidth, srcPtrUV + box.xmin, boxWidth) != EOK) {
+            HI_ASSERT(0);
+        }
+    }
+    HI_ASSERT(dstPtrUV - dstBufUV == (boxHeight / 2 ) * dstStrideUV);
+	
+    return ret;
+}
+
+int IveWriteFile(IVE_IMAGE_S* pstImg, FILE* pFp)
+{
+    HI_U16 y;
+    HI_U8* pU8;
+    HI_U16 height;
+    HI_U16 width;
+
+    height = pstImg->u32Height;
+    width = pstImg->u32Width;
+	printf("wgm %s, %d pstImg->enType = %d \r\n", __FUNCTION__, __LINE__, pstImg->enType);
+    switch (pstImg->enType)
+    {
+        case  IVE_IMAGE_TYPE_U8C1:
+        case  IVE_IMAGE_TYPE_S8C1:
+        {
+            pU8 = (HI_U8 *)(HI_UL)pstImg->au64VirAddr[0];
+            for (y = 0; y < height; y++)
+            {
+                if ( 1 != fwrite(pU8, width, 1, pFp))
+                {
+                    LOGE("Write file fail\n");
+                    return -1;
+                }
+
+                pU8 += pstImg->au32Stride[0];
+            }
+        }
+        break;
+        case  IVE_IMAGE_TYPE_YUV420SP:
+        {
+            pU8 = (HI_U8 *)(HI_UL)pstImg->au64VirAddr[0];
+            for (y = 0; y < height; y++)
+            {
+                if ( width != fwrite(pU8, 1, width, pFp))
+                {
+                    LOGE("Write file fail\n");
+                    return -1;
+                }
+
+                pU8 += pstImg->au32Stride[0];
+            }
+
+            pU8 = (HI_U8 *)(HI_UL)pstImg->au64VirAddr[1];
+            for (y = 0; y < height / 2; y++)
+            {
+                if ( width != fwrite(pU8, 1, width, pFp))
+                {
+                    LOGE("Write file fail\n");
+                    return -1;
+                }
+
+                pU8 += pstImg->au32Stride[1];
+            }
+        }
+        break;
+        case IVE_IMAGE_TYPE_YUV422SP:
+        {
+            pU8 = (HI_U8 *)(HI_UL)pstImg->au64VirAddr[0];
+            for (y = 0; y < height; y++)
+            {
+                if ( width != fwrite(pU8, 1, width, pFp))
+                {
+                    LOGE("Write file fail\n");
+                    return -1;
+                }
+
+                pU8 += pstImg->au32Stride[0];
+            }
+
+            pU8 = (HI_U8 *)(HI_UL)pstImg->au64VirAddr[1];
+            for (y = 0; y < height; y++)
+            {
+                if ( width != fwrite(pU8, 1, width, pFp))
+                {
+                    LOGE("Write file fail\n");
+                    return -1;
+                }
+
+                pU8 += pstImg->au32Stride[1];
+            }
+        }
+        break;
+        case IVE_IMAGE_TYPE_S16C1:
+        case  IVE_IMAGE_TYPE_U16C1:
+        {
+            pU8 = (HI_U8 *)(HI_UL)pstImg->au64VirAddr[0];
+            for ( y = 0; y < height; y++ )
+            {
+                if ( sizeof(HI_U16) != fwrite(pU8, width, sizeof(HI_U16), pFp) )
+                {
+                    LOGE("Write file fail\n");
+                    return -1;
+                }
+
+                pU8 += pstImg->au32Stride[0] * 2;
+            }
+        }
+        break;
+        case IVE_IMAGE_TYPE_U32C1:
+        {
+
+            pU8 = (HI_U8 *)(HI_UL)pstImg->au64VirAddr[0];
+            for ( y = 0; y < height; y++ )
+            {
+                if ( width != fwrite(pU8, sizeof(HI_U32), width, pFp) )
+                {
+                    LOGE("Write file fail\n");
+                    return -1;
+                }
+
+                pU8 += pstImg->au32Stride[0] * 4;
+            }
+            break;
+        }
+
+        default:
+            break;
+    }
+
+    return 0;
+}
\ 浠跺熬娌℃㈣绗
diff -urpBN hiopenais/src/mpp_help/ive_img.h hiopenais_modify/src/mpp_help/ive_img.h
--- hiopenais/src/mpp_help/ive_img.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/mpp_help/ive_img.h	2021-07-01 19:42:25.000000000 -0700
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef IVE_HELP_H
+#define IVE_HELP_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "hi_common.h"
+#include "hi_comm_ive.h"
+#include "hi_comm_video.h"
+#include "hi_comm_venc.h"
+#include "hi_ive.h"
+#include "mpi_ive.h"
+#include "hi_ext_util.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    姣ive Image.
+*/
+void IveImgDestroy(IVE_IMAGE_S* img);
+
+/**
+    缂╂ive image.
+
+    浠绘扮缂╂.
+    姝ゅ芥颁涓dst绌洪存ュㄧ缉惧惧.
+    user璐璐ｈIveImgDestroy()姣@param dst杩image.
+
+    @param src[in]: 寰缂╂剧濮image.
+    @param dst[out]: 淇瀛缂╂惧image.
+    @param dstWidth[in]: 瑕缂╂width.
+    @param dstHeight[in]: 瑕缂╂height.
+*/
+int IveImgResize(
+    const IVE_IMAGE_S *src, IVE_IMAGE_S *dst,
+    uint32_t dstWidth, uint32_t dstHeight);
+
+/**
+    ive image RGB to BGR.
+*/
+int ImgRgbToBgr(IVE_IMAGE_S *img);
+
+/**
+    ive image RGB to YUV.
+*/
+int ImgRgbToYuv(IVE_IMAGE_S *src, IVE_IMAGE_S *dst, IVE_IMAGE_TYPE_E dstType);
+
+/**
+    cut YUV P/SP image to U8C1 image (板害惧).
+*/
+int ImgYuvCropU8c1(
+    const IVE_IMAGE_S *src, IVE_IMAGE_S *dst,
+    const RectBox* box, int dstWidth, int dstHeight);
+
+/**
+    YUV video frame to RGB ive image.
+*/
+int FrmToRgbImg(VIDEO_FRAME_INFO_S* frm, IVE_DST_IMAGE_S *img);
+
+/**
+    video YUV frame to ive image (U8C1).
+*/
+int FrmToU8c1Img(const VIDEO_FRAME_INFO_S* frm, IVE_IMAGE_S *img);
+
+/**
+    video frame to ive image.
+    澶舵版锛涓澶舵版
+*/
+int FrmToOrigImg(const VIDEO_FRAME_INFO_S* frm, IVE_IMAGE_S *img);
+
+/**
+    ive image to video frame .
+    澶舵版锛涓澶舵版
+*/
+int OrigImgToFrm(const IVE_IMAGE_S *img, VIDEO_FRAME_INFO_S* frm);
+
+int ImgYuvCrop(const IVE_IMAGE_S *src, IVE_IMAGE_S *dst, const RectBox* origBox);
+
+int IveWriteFile(IVE_IMAGE_S* pstImg, FILE* pFp);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // IVE_HELP_H
diff -urpBN hiopenais/src/mpp_help/mpp_help.h hiopenais_modify/src/mpp_help/mpp_help.h
--- hiopenais/src/mpp_help/mpp_help.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/mpp_help/mpp_help.h	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MPP_HELP_H
+#define MPP_HELP_H
+
+#include "mpp_sess.h"
+#include "mpp_img.h"
+
+#endif // MPP_HELP_H
diff -urpBN hiopenais/src/mpp_help/mpp_img.h hiopenais_modify/src/mpp_help/mpp_img.h
--- hiopenais/src/mpp_help/mpp_img.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/mpp_help/mpp_img.h	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MPP_IMG_HELP_H
+#define MPP_IMG_HELP_H
+
+#include "ive_img.h"
+#include "vgs_img.h"
+#include "osd_img.h"
+
+#endif // MPP_IMG_HELP_H
diff -urpBN hiopenais/src/mpp_help/mpp_sess.c hiopenais_modify/src/mpp_help/mpp_sess.c
--- hiopenais/src/mpp_help/mpp_sess.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/mpp_help/mpp_sess.c	2021-03-29 20:31:17.000000000 -0700
@@ -0,0 +1,1356 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include "hi_scene.h"
+#include "hi_scene_loadparam.h"
+
+#include "hi_ext_util.h"
+#include "mpp_sess.h"
+
+/**
+    VDEC VB buf info.
+    用于创建VDEC VB buf.
+*/
+typedef struct VdecBufInfo {
+    HI_U32 u32PicBufSize;
+    HI_U32 u32TmvBufSize;
+    HI_BOOL bPicBufAlloc;
+    HI_BOOL bTmvBufAlloc;
+}   VdecBufInfo;
+
+/*************************************************************************************************
+    MPP组件配置对象
+*************************************************************************************************/
+#define SP_MPP_CFG
+#define APIPE0    0
+#define APIPE1    1
+#define APIPE2    2
+#define APIPE3    3
+
+/**
+    初始化VbCfg
+*/
+void VbCfgInit(VbCfg* self)
+{
+    HI_ASSERT(self);
+    if (memset_s(self, sizeof(*self), 0, sizeof(*self)) != EOK) {
+        HI_ASSERT(0);
+    }
+}
+
+/**
+    添加一种size的一个pool.
+*/
+void VbCfgAddPool(VbCfg* self, int bufNum, int width, int height)
+{
+    VbCfgAddPoolx(self, bufNum, width, height, -1, -1, -1);
+}
+
+/**
+    添加一种size的一个pool.
+*/
+void VbCfgAddPoolx(VbCfg* self,
+    int bufNum, int width, int height,
+    PIXEL_FORMAT_E pixelFormat,
+    DATA_BITWIDTH_E bitWidth,
+    COMPRESS_MODE_E compressMode)
+{
+    if ((int)pixelFormat < 0) {
+        pixelFormat = PIXEL_FORMAT_YUV_SEMIPLANAR_422;
+    }
+    if ((int)bitWidth < 0) {
+        bitWidth = DATA_BITWIDTH_8;
+    }
+    if ((int)compressMode < 0) {
+        compressMode = COMPRESS_MODE_NONE; // sample默认是COMPRESS_MODE_SEG
+    }
+
+    HI_ASSERT(bufNum > 0);
+    HI_ASSERT(self->u32MaxPoolCnt < sizeof(self->astCommPool) / sizeof(self->astCommPool[0]));
+
+    HI_U32 blkSize = COMMON_GetPicBufferSize(width, height,
+        pixelFormat, bitWidth, compressMode, DEFAULT_ALIGN);
+    int id;
+    id = self->u32MaxPoolCnt;
+
+    self->astCommPool[id].u64BlkSize = blkSize;
+    self->astCommPool[id].u32BlkCnt = bufNum;
+    self->u32MaxPoolCnt++;
+}
+
+/**
+    添加针对特定sensor类型的一个pool.
+*/
+void VbCfgAddForSns(VbCfg* self, int bufNum, SAMPLE_SNS_TYPE_E snsType)
+{
+    static const int bufNumDef = 15; // default buf num
+    SIZE_S size = CurSnsMaxSize(snsType);
+    HI_ASSERT(size.u32Width > 0 && size.u32Height > 0);
+    bufNum = bufNum < 0 ? bufNumDef : bufNum;
+
+    // 默认15个buf (参考sample)
+    VbCfgAddPoolx(self, bufNum, size.u32Width, size.u32Height, -1, -1, -1);
+}
+
+/**
+    init ViCfg.
+*/
+void ViCfgInit(ViCfg* self)
+{
+    HI_ASSERT(self);
+    if (memset_s(self, sizeof(*self), 0, sizeof(*self)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    SAMPLE_COMM_VI_GetSensorInfo(self);
+    self->s32WorkingViNum = 1;
+    self->as32WorkingViId[0] = 0;
+
+    self->astViInfo[0].stSnsInfo.MipiDev =
+        SAMPLE_COMM_VI_GetComboDevBySensor(self->astViInfo[0].stSnsInfo.enSnsType, 0);
+    self->astViInfo[0].stSnsInfo.s32BusId = 0;
+}
+
+/**
+    设置VI的DEV信息.
+*/
+void ViCfgSetDev(ViCfg* self, int devId, WDR_MODE_E wdrMode)
+{
+    HI_ASSERT(self);
+    HI_ASSERT((int)wdrMode < WDR_MODE_BUTT);
+
+    self->astViInfo[0].stDevInfo.ViDev = devId;
+    self->astViInfo[0].stDevInfo.enWDRMode = (int)wdrMode < 0 ? WDR_MODE_NONE : wdrMode;
+}
+
+/**
+    设置VI的PIPE信息.
+*/
+void ViCfgSetPipe(ViCfg* self,
+    int pipe0Id, int pipe1Id, int pipe2Id, int pipe3Id,
+    VI_VPSS_MODE_E mastPipeMode)
+{
+    HI_ASSERT(self);
+    HI_ASSERT((int)mastPipeMode < VI_VPSS_MODE_BUTT);
+
+    self->astViInfo[0].stPipeInfo.enMastPipeMode =
+        (int)mastPipeMode < 0 ? VI_OFFLINE_VPSS_OFFLINE : mastPipeMode;
+    self->astViInfo[0].stPipeInfo.aPipe[APIPE0] = pipe0Id;
+    self->astViInfo[0].stPipeInfo.aPipe[APIPE1] = pipe1Id;
+    self->astViInfo[0].stPipeInfo.aPipe[APIPE2] = pipe2Id;
+    self->astViInfo[0].stPipeInfo.aPipe[APIPE3] = pipe3Id;
+}
+
+/**
+    设置VI通道.
+*/
+void ViCfgSetChn(ViCfg* self, int chnId,
+    PIXEL_FORMAT_E pixFormat, VIDEO_FORMAT_E videoFormat,
+    DYNAMIC_RANGE_E dynamicRange, COMPRESS_MODE_E compressMode)
+{
+    HI_ASSERT(self);
+    HI_ASSERT((int)pixFormat < PIXEL_FORMAT_BUTT);
+    HI_ASSERT((int)videoFormat < VIDEO_FORMAT_BUTT);
+    HI_ASSERT((int)dynamicRange < DYNAMIC_RANGE_BUTT);
+    HI_ASSERT((int)compressMode < COMPRESS_MODE_BUTT);
+
+    self->astViInfo[0].stChnInfo.ViChn = chnId;
+    self->astViInfo[0].stChnInfo.enPixFormat =
+        (int)pixFormat < 0 ? PIXEL_FORMAT_YVU_SEMIPLANAR_420 : pixFormat;
+    self->astViInfo[0].stChnInfo.enVideoFormat =
+        (int)videoFormat < 0 ? VIDEO_FORMAT_LINEAR : videoFormat;
+    self->astViInfo[0].stChnInfo.enDynamicRange =
+        (int)dynamicRange < 0 ? DYNAMIC_RANGE_SDR8 : dynamicRange;
+    self->astViInfo[0].stChnInfo.enCompressMode =
+        (int)compressMode < 0 ? COMPRESS_MODE_NONE : compressMode;
+}
+
+/**
+    获取sensor type.
+*/
+SAMPLE_SNS_TYPE_E ViCfgSnsType(const ViCfg* self)
+{
+    HI_ASSERT(self && self->s32WorkingViNum == 1);
+
+    SAMPLE_SNS_TYPE_E snsType = self->astViInfo[0].stSnsInfo.enSnsType;
+    HI_ASSERT(snsType >= 0 && (int)snsType < SAMPLE_SNS_TYPE_BUTT);
+    return snsType;
+}
+
+/**
+    设置VdecCfg.
+*/
+void VdecCfgInit(VdecCfg* self, int chnId,
+    PAYLOAD_TYPE_E codecType, VIDEO_MODE_E videoMode, VB_SOURCE_E vbSrcType,
+    const SIZE_S* maxSize)
+{
+    // 暂时直接使用Hi3516DV300最大性能: H264/H265: 2688x1536@30fps
+    static const uint32_t maxWidth = 2688;
+    static const uint32_t maxHeight = 1536;
+    static const uint32_t alphaDef = 255;
+    static const uint32_t displayFrmNumDef = 2;
+    static const uint32_t refFrmNumDef = 2;
+
+    HI_ASSERT(self);
+    if (memset_s(self, sizeof(*self), 0, sizeof(*self)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    self->chnId = chnId;
+    self->codecType = codecType;
+    if (maxSize) {
+        self->maxWidth = maxSize->u32Width > maxWidth ? maxWidth : maxSize->u32Width;
+        self->maxHeight = maxSize->u32Height > maxHeight ? maxHeight : maxSize->u32Height;
+    } else {
+        self->maxWidth = maxWidth;
+        self->maxHeight = maxHeight;
+    }
+    self->videoMode = (int)videoMode < 0 ? VIDEO_MODE_FRAME : VIDEO_MODE_STREAM;
+    self->vbSrcType = (int)vbSrcType < 0 ? VB_SOURCE_MODULE : vbSrcType;
+
+    // 为图像属性设置默认值
+    if (self->codecType == PT_JPEG || self->codecType == PT_MJPEG) {
+        self->picCfg.enPixelFormat = PIXEL_FORMAT_YVU_SEMIPLANAR_420;
+        self->picCfg.u32Alpha = alphaDef;
+        self->displayFrmNum = displayFrmNumDef;
+        self->frmBufNum = self->displayFrmNum + 1;
+    } else if (self->codecType == PT_H264 || self->codecType == PT_H265) {
+        self->videoCfg.enDecMode = VIDEO_DEC_MODE_IP;
+        self->videoCfg.enBitWidth = DATA_BITWIDTH_8;
+        self->videoCfg.u32RefFrameNum = refFrmNumDef;
+        self->displayFrmNum = displayFrmNumDef;
+        self->frmBufNum = self->videoCfg.u32RefFrameNum + self->displayFrmNum + 1;
+    } else {
+        HI_ASSERT(0);
+    }
+}
+
+/**
+    将配置输出到VDEC ChnAttr中.
+*/
+void VdecCfgToAttr(const VdecCfg *vdecCfg, VDEC_CHN_ATTR_S *chnAttr)
+{
+    chnAttr->enType = vdecCfg->codecType;
+    chnAttr->enMode = vdecCfg->videoMode;
+    chnAttr->u32PicWidth = vdecCfg->maxWidth;
+    chnAttr->u32PicHeight = vdecCfg->maxHeight;
+    chnAttr->u32StreamBufSize = vdecCfg->maxWidth * vdecCfg->maxHeight;
+    chnAttr->u32FrameBufCnt = vdecCfg->frmBufNum;
+
+    if (vdecCfg->codecType == PT_H264 || vdecCfg->codecType == PT_H265) {
+        chnAttr->stVdecVideoAttr.u32RefFrameNum = vdecCfg->videoCfg.u32RefFrameNum;
+        chnAttr->stVdecVideoAttr.bTemporalMvpEnable = 1;
+        if (vdecCfg->codecType == PT_H264) {
+            chnAttr->stVdecVideoAttr.bTemporalMvpEnable = 0;
+        }
+        // 按YUV444SP来计算buf，不过目前的VDEC_GetPicBufferSize()并未使用该信息
+        chnAttr->u32FrameBufSize = VDEC_GetPicBufferSize(
+            chnAttr->enType, vdecCfg->maxWidth, vdecCfg->maxHeight,
+            PIXEL_FORMAT_YVU_SEMIPLANAR_444, vdecCfg->videoCfg.enBitWidth, 0);
+    } else if (vdecCfg->codecType == PT_JPEG || vdecCfg->codecType == PT_MJPEG) {
+        chnAttr->enMode = VIDEO_MODE_FRAME;
+        // 按YUV444SP来计算buf，不过目前的VDEC_GetPicBufferSize()并未使用该信息
+        chnAttr->u32FrameBufSize = VDEC_GetPicBufferSize(
+            chnAttr->enType, vdecCfg->maxWidth, vdecCfg->maxHeight,
+            PIXEL_FORMAT_YVU_SEMIPLANAR_444, DATA_BITWIDTH_8, 0);
+    }
+}
+
+/**
+    计算VDEC需要的一个VB buf的size.
+*/
+static void VdecCfgCalVb(const VdecCfg *vdecCfg, VdecBufInfo *bufInfo)
+{
+    if (vdecCfg->codecType == PT_H265) {
+        bufInfo->u32PicBufSize = VDEC_GetPicBufferSize(
+            vdecCfg->codecType, vdecCfg->maxWidth, vdecCfg->maxHeight,
+            PIXEL_FORMAT_YVU_SEMIPLANAR_420, vdecCfg->videoCfg.enBitWidth, 0);
+        bufInfo->u32TmvBufSize = VDEC_GetTmvBufferSize(
+            vdecCfg->codecType, vdecCfg->maxWidth, vdecCfg->maxHeight);
+    } else if (vdecCfg->codecType == PT_H264) {
+        bufInfo->u32PicBufSize = VDEC_GetPicBufferSize(
+            vdecCfg->codecType, vdecCfg->maxWidth, vdecCfg->maxHeight,
+            PIXEL_FORMAT_YVU_SEMIPLANAR_420, vdecCfg->videoCfg.enBitWidth, 0);
+        if (vdecCfg->videoCfg.enDecMode == VIDEO_DEC_MODE_IPB) {
+            bufInfo->u32TmvBufSize = VDEC_GetTmvBufferSize(
+                vdecCfg->codecType, vdecCfg->maxWidth, vdecCfg->maxHeight);
+        }
+    } else {
+        bufInfo->u32PicBufSize = VDEC_GetPicBufferSize(
+            vdecCfg->codecType, vdecCfg->maxWidth, vdecCfg->maxHeight,
+            vdecCfg->picCfg.enPixelFormat, DATA_BITWIDTH_8, 0);
+    }
+}
+
+/**
+    初始化VpssCfg.
+*/
+void VpssCfgInit(VpssCfg* self)
+{
+    HI_ASSERT(self);
+    if (memset_s(self, sizeof(*self), 0, sizeof(*self)) != EOK) {
+        HI_ASSERT(0);
+    }
+    self->grpId = -1;
+    self->chnNum = 0;
+}
+
+/**
+    设置VPSS Group.
+*/
+void VpssCfgSetGrp(VpssCfg* self,
+    int grpId, const VPSS_GRP_ATTR_S* grpAttr, int maxWidth, int maxHeight)
+{
+    HI_ASSERT(self);
+    HI_ASSERT(grpId >= 0);
+
+    self->grpId = grpId;
+
+    if (grpAttr) {
+        self->grpAttr = *grpAttr;
+    } else { // 设置为默认值
+        self->grpAttr.u32MaxW = maxWidth < 0 ? 0 : maxWidth;
+        self->grpAttr.u32MaxH = maxHeight < 0 ? 0 : maxHeight;
+        self->grpAttr.enPixelFormat = PIXEL_FORMAT_YVU_SEMIPLANAR_420;
+        self->grpAttr.enDynamicRange = DYNAMIC_RANGE_SDR8;
+        self->grpAttr.stFrameRate.s32SrcFrameRate = -1;
+        self->grpAttr.stFrameRate.s32DstFrameRate = -1;
+        self->grpAttr.bNrEn = HI_TRUE;
+    }
+}
+
+/**
+    添加一个VPSS channel.
+*/
+VPSS_CHN_ATTR_S* VpssCfgAddChn(VpssCfg* self,
+    int chnId, const VPSS_CHN_ATTR_S* chnAttr, int width, int height)
+{
+    HI_ASSERT(self);
+    HI_ASSERT(self->chnNum < HI_ARRAY_SIZE(self->chnCfgs));
+    static const uint32_t depthDef = 2;
+    VpssChnCfg *chnCfg = &self->chnCfgs[self->chnNum];
+
+    if (chnAttr) {
+        chnCfg->attr = *chnAttr;
+    } else { // 设置默认值
+        chnCfg->attr.u32Width = width < 0 ? 0 : width;
+        chnCfg->attr.u32Height = height < 0 ? 0 : height;
+        chnCfg->attr.enChnMode = VPSS_CHN_MODE_USER;
+        chnCfg->attr.enVideoFormat = VIDEO_FORMAT_LINEAR;
+        chnCfg->attr.enPixelFormat = PIXEL_FORMAT_YVU_SEMIPLANAR_420;
+        chnCfg->attr.enDynamicRange = DYNAMIC_RANGE_SDR8;
+        chnCfg->attr.enCompressMode = COMPRESS_MODE_NONE;
+        chnCfg->attr.stFrameRate.s32SrcFrameRate = -1;
+        chnCfg->attr.stFrameRate.s32DstFrameRate = -1;
+        chnCfg->attr.u32Depth = depthDef;
+        chnCfg->attr.bMirror = HI_FALSE;
+        chnCfg->attr.bFlip = HI_FALSE;
+        chnCfg->attr.stAspectRatio.enMode = ASPECT_RATIO_NONE;
+    }
+    chnCfg->id = chnId;
+
+    self->chnNum++;
+    return &chnCfg->attr;
+}
+
+/**
+    设置VencCfg.
+*/
+void VencCfgInit(VencCfg* self, int chnId,
+    PIC_SIZE_E sizeType, PAYLOAD_TYPE_E codecType,
+    VENC_GOP_MODE_E gopMode, SAMPLE_RC_E rcMode)
+{
+    HI_ASSERT(self);
+    HI_ASSERT(chnId >= 0);
+    HI_ASSERT((int)sizeType < PIC_BUTT);
+    HI_ASSERT((int)codecType < PT_BUTT);
+    HI_ASSERT((int)gopMode < VENC_GOPMODE_BUTT);
+
+    if (memset_s(self, sizeof(*self), 0, sizeof(*self)) != EOK) {
+        HI_ASSERT(0);
+    }
+    self->chnId = chnId;
+    self->sizeType = sizeType;
+    self->codecType = codecType;
+    self->gopMode = (int)gopMode < 0 ? VENC_GOPMODE_NORMALP : gopMode;
+    self->rcMode = (int)rcMode < 0 ? SAMPLE_RC_VBR : rcMode;
+    self->profile = 0;
+    self->rcnRefShareBuf = true;
+}
+
+/*************************************************************************************************
+    MPP Session
+*************************************************************************************************/
+#define SP_MPP_SESS
+
+/**
+    new MppSess
+*/
+static MppSess* MppSessNew(void)
+{
+    MppSess *sess = (MppSess*)malloc(sizeof(*sess));
+    HI_ASSERT(sess);
+    if (memset_s(sess, sizeof(*sess), 0, sizeof(*sess)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    sess->vpssGrp = -1;
+    sess->vpssChn0 = -1;
+    sess->vpssChn1 = -1;
+    sess->vdecChn = -1;
+    sess->vencChn = -1;
+    return sess;
+}
+
+/**
+    destroy MppSess.
+*/
+void MppSessDestroy(MppSess* self)
+{
+    HI_ASSERT(self);
+
+    if ((self->used & MPP_VPSS) && (self->used & MPP_VI)) {
+        VI_PIPE pipeId = self->viCfg.astViInfo[0].stPipeInfo.aPipe[0];
+        VI_CHN chnId = self->viCfg.astViInfo[0].stChnInfo.ViChn;
+        ViUnbindVpss(pipeId, chnId, self->vpssCfg.grpId);
+    }
+    if ((self->used & MPP_VPSS) && (self->used & MPP_VDEC) &&
+        VdecVpssBinded(self->vdecCfg.chnId, self->vpssCfg.grpId)) {
+        VdecUnbindVpss(self->vdecCfg.chnId, self->vpssCfg.grpId);
+    }
+
+    if (self->used & MPP_VPSS) {
+        VpssStop(&self->vpssCfg);
+    }
+    if (self->used & MPP_VI) {
+        ViStop(&self->viCfg);
+    }
+    if (self->used & MPP_VDEC) {
+        VdecStop(&self->vdecCfg);
+    }
+    if (self->used & MPP_VENC) {
+        VecnStop(&self->vencCfg);
+    }
+
+    free(self);
+}
+
+/**
+    创建并启动仅含VDEC的MppSess.
+*/
+int VdecCreate(MppSess** sess, const VdecCfg* vdecCfg)
+{
+    HI_ASSERT(sess && vdecCfg);
+    *sess = NULL;
+    int ret;
+
+    ret = VdecStart(vdecCfg);
+    if (ret != 0) {
+        goto FAIL;
+    }
+
+    MppSess *self = MppSessNew();
+    *sess = self;
+    self->vdecCfg = *vdecCfg;
+    self->used |= MPP_VDEC;
+    self->vdecChn = vdecCfg->chnId;
+    return 0;
+
+    FAIL:
+        return ret;
+}
+
+/**
+    创建并启动仅含VPSS的MppSess.
+*/
+int VpssCreate(MppSess** sess, const VpssCfg* vpssCfg)
+{
+    HI_ASSERT(sess && vpssCfg);
+    *sess = NULL;
+    int ret;
+
+    ret = VpssStart(vpssCfg);
+    if (ret != 0) {
+        goto FAIL;
+    }
+
+    MppSess *self = MppSessNew();
+    *sess = self;
+    self->vpssCfg = *vpssCfg;
+    self->used |= MPP_VPSS;
+    self->vpssGrp = vpssCfg->grpId;
+    self->vpssChn0 = vpssCfg->chnCfgs[0].id;
+    self->vpssChn1 = vpssCfg->chnNum > 1 ? vpssCfg->chnCfgs[1].id : -1;
+    return 0;
+
+    FAIL:
+        return ret;
+}
+
+/**
+    创建并启动仅含VENC的MppSess.
+*/
+int VencCreate(MppSess** sess, const VencCfg* vencCfg)
+{
+    HI_ASSERT(sess && vencCfg);
+    *sess = NULL;
+    int ret;
+
+    ret = VencStart(vencCfg);
+    if (ret != 0) {
+        goto FAIL;
+    }
+
+    MppSess *self = MppSessNew();
+    *sess = self;
+    self->vencCfg = *vencCfg;
+    self->used |= MPP_VENC;
+    self->vencChn = vencCfg->chnId;
+    return 0;
+
+    FAIL:
+        return ret;
+}
+
+/**
+    创建并启动{VI->VPSS}MppSess.
+*/
+int ViVpssCreate(MppSess** sess, const ViCfg* viCfg, const VpssCfg* vpssCfg)
+{
+    HI_ASSERT(sess && viCfg && vpssCfg);
+    *sess = NULL;
+    int res;
+    int ret;
+
+    ret = ViStart(viCfg);
+    if (ret != 0) {
+        goto FAIL1;
+    }
+    ret = VpssStart(vpssCfg);
+    if (ret != 0) {
+        goto FAIL2;
+    }
+
+    VI_PIPE pipeId = viCfg->astViInfo[0].stPipeInfo.aPipe[0];
+    VI_CHN chnId = viCfg->astViInfo[0].stChnInfo.ViChn;
+    ret = ViBindVpss(pipeId, chnId, vpssCfg->grpId);
+    if (ret != 0) {
+        goto FAIL3;
+    }
+
+    MppSess *self = MppSessNew();
+    *sess = self;
+    self->viCfg = *viCfg;
+    self->vpssCfg = *vpssCfg;
+    self->used |= MPP_VI;
+    self->used |= MPP_VPSS;
+    self->vpssGrp = vpssCfg->grpId;
+    self->vpssChn0 = vpssCfg->chnCfgs[0].id;
+    self->vpssChn1 = vpssCfg->chnNum > 1 ? vpssCfg->chnCfgs[1].id : -1;
+    return 0;
+
+    FAIL3:
+        res = VpssStop(vpssCfg);
+        HI_EXP_LOGW(res, "VpssStop FAIL, ret=%#x\n", res);
+    FAIL2:
+        ViStop(viCfg);
+    FAIL1:
+        return ret;
+}
+
+/**
+    创建并启动{VDEC->VPSS}MppSess.
+*/
+int VdecVpssCreate(MppSess** sess, const VdecCfg* vdecCfg, const VpssCfg* vpssCfg, bool bind)
+{
+    HI_ASSERT(sess && vdecCfg && vpssCfg);
+    *sess = NULL;
+    int res;
+    int ret;
+
+    ret = VdecStart(vdecCfg);
+    if (ret != 0) {
+        goto FAIL1;
+    }
+    ret = VpssStart(vpssCfg);
+    if (ret != 0) {
+        goto FAIL2;
+    }
+
+    if (bind) {
+        ret = VdecBindVpss(vdecCfg->chnId, vpssCfg->grpId);
+        if (ret != 0) {
+            goto FAIL3;
+        }
+    }
+
+    MppSess *self = MppSessNew();
+    *sess = self;
+    self->vdecCfg = *vdecCfg;
+    self->vpssCfg = *vpssCfg;
+    self->used |= MPP_VDEC;
+    self->used |= MPP_VPSS;
+    self->vpssGrp = vpssCfg->grpId;
+    self->vpssChn0 = vpssCfg->chnCfgs[0].id;
+    self->vpssChn1 = vpssCfg->chnNum > 1 ? vpssCfg->chnCfgs[1].id : -1;
+    self->vdecChn = vdecCfg->chnId;
+    return 0;
+
+    FAIL3:
+        res = VpssStop(vpssCfg);
+        HI_EXP_LOGW(res, "VpssStop FAIL, ret=%#x\n", res);
+    FAIL2:
+        VdecStop(vdecCfg);
+    FAIL1:
+        return ret;
+}
+
+/*************************************************************************************************
+    MPP helper util
+*************************************************************************************************/
+#define SP_MPP_UTIL
+
+/**
+    根据vdecCfg创建VDEC VB.
+    VDEC使用了非全局的VB，需要单独创建.
+    根据SAMPLE_COMM_VDEC_InitVBPool修改.
+*/
+static int VdecVbInit(const VdecCfg *vdecCfg)
+{
+    VB_CONFIG_S vbCfg = { 0 };
+    VdecBufInfo bufInfo = { 0 };
+    HI_S32 pos = 0;
+    HI_S32 ret;
+
+    // calculate pic buf size need
+    VdecCfgCalVb(vdecCfg, &bufInfo);
+
+    // PicBuffer
+    for (int j = 0; j < VB_MAX_COMM_POOLS; j++) {
+        if (bufInfo.u32PicBufSize && !bufInfo.bPicBufAlloc) {
+            vbCfg.astCommPool[j].u64BlkSize = bufInfo.u32PicBufSize;
+            vbCfg.astCommPool[j].u32BlkCnt = vdecCfg->frmBufNum;
+            bufInfo.bPicBufAlloc = HI_TRUE;
+            pos = j;
+
+            if ((!bufInfo.bPicBufAlloc) && (vbCfg.astCommPool[j].u64BlkSize == bufInfo.u32PicBufSize)) {
+                vbCfg.astCommPool[j].u32BlkCnt += vdecCfg->frmBufNum;
+                bufInfo.bPicBufAlloc = HI_TRUE;
+            }
+        }
+    }
+
+    // TmvBuffer
+    for (int j = pos + 1; j < VB_MAX_COMM_POOLS; j++) {
+        if (bufInfo.u32TmvBufSize && !bufInfo.bTmvBufAlloc) {
+            vbCfg.astCommPool[j].u64BlkSize = bufInfo.u32TmvBufSize;
+            vbCfg.astCommPool[j].u32BlkCnt = vdecCfg->videoCfg.u32RefFrameNum + 1;
+            bufInfo.bTmvBufAlloc = HI_TRUE;
+            pos = j;
+
+            if ((!bufInfo.bTmvBufAlloc) && (vbCfg.astCommPool[j].u64BlkSize == bufInfo.u32TmvBufSize)) {
+                vbCfg.astCommPool[j].u32BlkCnt += vdecCfg->videoCfg.u32RefFrameNum + 1;
+                bufInfo.bTmvBufAlloc = HI_TRUE;
+            }
+        }
+    }
+    vbCfg.u32MaxPoolCnt = pos + 1;
+
+    if (vdecCfg->vbSrcType == VB_SOURCE_MODULE) {
+        HI_MPI_VB_ExitModCommPool(VB_UID_VDEC);
+        ret = HI_MPI_VB_SetModPoolConfig(VB_UID_VDEC, &vbCfg);
+        HI_CHK_RET(ret, "HI_MPI_VB_SetModPoolConfig FAIL, ret=%#x\n", ret);
+        ret = HI_MPI_VB_InitModCommPool(VB_UID_VDEC);
+        HI_CHK_RET(ret, "HI_MPI_VB_InitModCommPool FAIL, ret=%#x\n", ret);
+    } else {
+        HI_ASSERT(0);
+    }
+    return HI_SUCCESS;
+}
+
+/**
+    销毁用vdecCfg创建的VDEC VB.
+    根据SAMPLE_COMM_VDEC_ExitVBPool修改.
+*/
+static int VdecVbExit(const VdecCfg* vdecCfg)
+{
+    if (vdecCfg->vbSrcType == VB_SOURCE_MODULE) {
+        int ret = HI_MPI_VB_ExitModCommPool(VB_UID_VDEC);
+        HI_CHK_RET(ret, "HI_MPI_VB_ExitModCommPool FAIL, ret=%#x\n", ret);
+        return 0;
+    } else {
+        HI_ASSERT(0);
+        return -1;
+    }
+}
+
+/**
+    初始化MPP，并创建VB.
+    copied from SAMPLE_COMM_SYS_Init().
+*/
+int MppSysInit(const VB_CONFIG_S* vbCfg)
+{
+    HI_ASSERT(vbCfg);
+    HI_S32 ret;
+
+    HI_MPI_SYS_Exit();
+    HI_MPI_VB_Exit();
+
+    for (int i = 0; i < vbCfg->u32MaxPoolCnt; i++) {
+        LOGI("MPP: vbp[%d]: %u x %ju\n", i,
+            vbCfg->astCommPool[i].u32BlkCnt, (uintmax_t)vbCfg->astCommPool[i].u64BlkSize);
+    }
+
+    ret = HI_MPI_VB_SetConfig(vbCfg);
+    HI_CHK_RET(ret, "HI_MPI_VB_SetConf failed, ret=%#x\n", ret);
+
+    ret = HI_MPI_VB_Init();
+    HI_CHK_RET(ret, "HI_MPI_VB_Init failed, ret=%#x\n", ret);
+
+    ret = HI_MPI_SYS_Init();
+    if (ret != HI_SUCCESS) {
+        LOGE("HI_MPI_SYS_Init FAIL, ret=%#x\n", ret);
+        HI_MPI_VB_Exit();
+        return HI_FAILURE;
+    }
+    return HI_SUCCESS;
+}
+
+/**
+    销毁VB并去初始化MPP
+*/
+void MppSysExit(void)
+{
+    HI_MPI_SYS_Exit();
+    HI_MPI_VB_ExitModCommPool(VB_UID_VDEC);
+    HI_MPI_VB_Exit();
+    return;
+}
+
+/**
+    Sensor scene init.
+*/
+int SceneInit(const char* sensorParamPath)
+{
+#   ifndef __HuaweiLite__
+    HI_ASSERT(sensorParamPath && *sensorParamPath);
+    HI_S32 choice = 2;
+    HI_SCENE_PARAM_S sceneParam;
+    HI_SCENE_VIDEO_MODE_S videoMode;
+    HI_U32 ret;
+
+    LOGI("MPP: init sceneauto ...\n");
+
+    ret = HI_SCENE_CreateParam((char*)sensorParamPath, &sceneParam, &videoMode);
+    HI_CHK_RET(ret, "SCENETOOL_CreateParam FAIL, ret=%#x\n", ret);
+    ret = HI_SCENE_Init(&sceneParam);
+    HI_CHK_RET(ret, "HI_SCENE_Init FAIL, ret=%#x\n", ret);
+    ret = HI_SCENE_SetSceneMode(&(videoMode.astVideoMode[choice]));
+    HI_CHK_RET(ret, "HI_SCENE_SetSceneMode FAIL, ret=%#x\n", ret);
+
+    LOGI("MPP: init sceneauto done\n");
+#   endif
+    return HI_SUCCESS;
+}
+
+/**
+    Sensor scene exit.
+*/
+void SceneExit(void)
+{
+#   ifndef __HuaweiLite__
+    HI_U32 ret;
+
+    ret = HI_SCENE_Deinit();
+    if (ret != HI_SUCCESS) {
+        LOGE("HI_SCENE_Deinit FAIL, ret=%#x\n", ret);
+    }
+#   endif
+}
+
+/**
+    根据ViCfg启动VI.
+*/
+int ViStart(const ViCfg* viCfg)
+{
+    static const uint32_t frmRateDef = 30;
+    SAMPLE_SNS_TYPE_E snsType = viCfg->astViInfo[0].stSnsInfo.enSnsType;
+    ISP_CTRL_PARAM_S ispCtrlParam;
+    HI_U32 frmRate;
+    HI_S32 ret;
+
+    ret = SAMPLE_COMM_VI_SetParam((ViCfg*)viCfg);
+    HI_CHK_RET(ret, "SAMPLE_COMM_VI_SetParam FAIL, ret=%#x\n", ret);
+
+    // 设置ISP统计间隔, from histm.sample_enc
+    SAMPLE_COMM_VI_GetFrameRateBySensor(snsType, &frmRate);
+    ret = HI_MPI_ISP_GetCtrlParam(viCfg->astViInfo[0].stPipeInfo.aPipe[0], &ispCtrlParam);
+    HI_CHK_RET(ret, "HI_MPI_ISP_GetCtrlParam FAIL, ret=%#x\n", ret);
+
+    ispCtrlParam.u32StatIntvl = frmRate / frmRateDef;
+    ret = HI_MPI_ISP_SetCtrlParam(viCfg->astViInfo[0].stPipeInfo.aPipe[0], &ispCtrlParam);
+    HI_CHK_RET(ret, "HI_MPI_ISP_SetCtrlParam FAIL, ret=%#x\n", ret);
+
+    ret = SAMPLE_COMM_VI_StartVi((ViCfg*)viCfg);
+    HI_CHK_RET(ret, "SAMPLE_COMM_VI_StartVi FAIL, ret=%#x\n", ret);
+
+    return HI_SUCCESS;
+}
+
+
+/*
+    终止用ViCfg启动的VI.
+*/
+int ViStop(const ViCfg* viCfg)
+{
+    return SAMPLE_COMM_VI_StopVi((ViCfg*)viCfg);
+}
+
+/**
+    根据ViCfg启动VI.
+    基于SAMPLE_COMM_VDEC_Start()修改。
+*/
+int VdecStart(const VdecCfg *vdecCfg)
+{
+    VDEC_CHN_ATTR_S chnAttr = { 0 };
+    VDEC_CHN_PARAM_S chnParam;
+    VDEC_MOD_PARAM_S modParam;
+    bool chnCreated = false;
+    int ret;
+
+    ret = VdecVbInit(vdecCfg);
+    HI_CHK_RET(ret, "init mod common vb FAIL, err=%#x!\n", ret);
+
+    ret = HI_MPI_VDEC_GetModParam(&modParam);
+    HI_CHK_GOTO(ret, FAIL, "HI_MPI_VDEC_GetModParam FAIL, ret=%#x\n", ret);
+
+    modParam.enVdecVBSource = vdecCfg->vbSrcType;
+    // 有chn已创建时，set会返回HI_ERR_VDEC_NOT_PERM，暂时这样处理
+    ret = HI_MPI_VDEC_SetModParam(&modParam);
+    if (ret == HI_ERR_VDEC_NOT_PERM) {
+        LOGW("HI_MPI_VDEC_GetModParam FAIL, for vb exist, ignore, err=%#x\n", ret);
+    }
+    HI_CHK_GOTO(ret, FAIL, "HI_MPI_VDEC_GetModParam FAIL, ret=%#x\n", ret);
+
+    VdecCfgToAttr(vdecCfg, &chnAttr);
+    ret = HI_MPI_VDEC_CreateChn(vdecCfg->chnId, &chnAttr);
+    HI_CHK_GOTO(ret, FAIL, "HI_MPI_VDEC_CreateChn(%d) FAIL, ret=%#x\n", vdecCfg->chnId, ret);
+    chnCreated = true;
+
+    ret = HI_MPI_VDEC_GetChnParam(vdecCfg->chnId, &chnParam);
+    HI_CHK_GOTO(ret, FAIL, "HI_MPI_VDEC_GetChnParam(%d) FAIL, ret=%#x\n", vdecCfg->chnId, ret);
+
+    // 修改部分chnParam
+    if (vdecCfg->codecType == PT_H264 || vdecCfg->codecType == PT_H265) {
+        chnParam.stVdecVideoParam.enDecMode = vdecCfg->videoCfg.enDecMode;
+        chnParam.stVdecVideoParam.enCompressMode = COMPRESS_MODE_NONE;
+        chnParam.stVdecVideoParam.enVideoFormat = VIDEO_FORMAT_TILE_64x16;
+        if (chnParam.stVdecVideoParam.enDecMode == VIDEO_DEC_MODE_IPB) {
+            chnParam.stVdecVideoParam.enOutputOrder = VIDEO_OUTPUT_ORDER_DISP;
+        } else {
+            chnParam.stVdecVideoParam.enOutputOrder = VIDEO_OUTPUT_ORDER_DEC;
+        }
+    } else {
+        chnParam.stVdecPictureParam.enPixelFormat = vdecCfg->picCfg.enPixelFormat;
+        chnParam.stVdecPictureParam.u32Alpha = vdecCfg->picCfg.u32Alpha;
+    }
+    chnParam.u32DisplayFrameNum = vdecCfg->displayFrmNum;
+
+    ret = HI_MPI_VDEC_SetChnParam(vdecCfg->chnId, &chnParam);
+    HI_CHK_GOTO(ret, FAIL, "HI_MPI_VDEC_SetChnParam(%d) FAIL, ret=%#x\n", vdecCfg->chnId, ret);
+
+    ret = HI_MPI_VDEC_StartRecvStream(vdecCfg->chnId);
+    HI_CHK_GOTO(ret, FAIL, "HI_MPI_VDEC_StartRecvStream(%d) FAIL, ret=%#x\n", vdecCfg->chnId, ret);
+    return HI_SUCCESS;
+
+    FAIL:
+        if (chnCreated && HI_MPI_VDEC_DestroyChn(vdecCfg->chnId) != HI_SUCCESS) {
+            LOGE("HI_MPI_VDEC_DestroyChn FAIL, ret=%#x\n", ret);
+        }
+        VdecVbExit(vdecCfg);
+        return ret ? ret : -1;
+}
+
+/**
+    终止用VdecCfg启动的VDEC.
+*/
+int VdecStop(const VdecCfg* vdecCfg)
+{
+    int ret;
+
+    ret = HI_MPI_VDEC_StopRecvStream(vdecCfg->chnId);
+    if (ret) {
+        LOGE("HI_MPI_VDEC_StopRecvStream FAIL, ret=%#x\n", ret);
+    }
+
+    ret = HI_MPI_VDEC_DestroyChn(vdecCfg->chnId);
+    if (ret) {
+        LOGE("HI_MPI_VDEC_DestroyChn FAIL, ret=%#x\n", ret);
+    }
+
+    VdecVbExit(vdecCfg);
+    return ret;
+}
+
+/**
+    根据VpssCfg启动VPSS.
+*/
+int VpssStart(const VpssCfg* cfg)
+{
+    HI_ASSERT(cfg);
+    VPSS_GRP grpId = cfg->grpId;
+    HI_S32 ret;
+
+    ret = HI_MPI_VPSS_CreateGrp(grpId, &cfg->grpAttr);
+    HI_CHK_RET(ret, "HI_MPI_VPSS_CreateGrp(%d) FAIL, ret=%#x\n", grpId, ret);
+
+    for (int i = 0; i < cfg->chnNum; i++) {
+        ret = HI_MPI_VPSS_SetChnAttr(grpId, cfg->chnCfgs[i].id, &cfg->chnCfgs[i].attr);
+        HI_CHK_RET(ret, "HI_MPI_VPSS_SetChnAttr(%d) FAIL, ret=%#x\n", cfg->chnCfgs[i].id, ret);
+
+        ret = HI_MPI_VPSS_EnableChn(grpId, cfg->chnCfgs[i].id);
+        HI_CHK_RET(ret, "HI_MPI_VPSS_EnableChn(%d) FAIL, ret=%#x\n", cfg->chnCfgs[i].id, ret);
+    }
+
+    ret = HI_MPI_VPSS_StartGrp(grpId);
+    HI_CHK_RET(ret, "HI_MPI_VPSS_StartGrp(%d) FAIL, ret=%#x\n", grpId, ret);
+    return HI_SUCCESS;
+}
+
+/**
+    终止用VpssCfg启动的VPSS.
+*/
+int VpssStop(const VpssCfg* cfg)
+{
+    HI_ASSERT(cfg);
+    VPSS_GRP grpId = cfg->grpId;
+    HI_S32 ret;
+
+    for (int i = 0; i < cfg->chnNum; i++) {
+        ret = HI_MPI_VPSS_DisableChn(grpId, cfg->chnCfgs[i].id);
+        HI_CHK_RET(ret, "HI_MPI_VPSS_DisableChn(%d, %d) FAIL, ret=%#x\n", grpId, cfg->chnCfgs[i].id, ret);
+    }
+
+    ret = HI_MPI_VPSS_StopGrp(grpId);
+    HI_CHK_RET(ret, "HI_MPI_VPSS_StopGrp(%d) FAIL, ret=%#x\n", grpId, ret);
+
+    ret = HI_MPI_VPSS_DestroyGrp(grpId);
+    HI_CHK_RET(ret, "HI_MPI_VPSS_DestroyGrp(%d) FAIL, ret=%#x\n", grpId, ret);
+    return HI_SUCCESS;
+}
+
+/**
+    根据VencCfg启动VENC.
+*/
+int VencStart(const VencCfg* cfg)
+{
+    VENC_GOP_ATTR_S gopAttr;
+    int ret;
+
+    if (cfg->gopMode == VENC_GOPMODE_BIPREDB) {
+        LOGW("VENC 'BIPREDB' and 'ADVSMARTP' not support lowdelay\n");
+    }
+
+    ret = SAMPLE_COMM_VENC_GetGopAttr(cfg->gopMode, &gopAttr);
+    HI_CHK_RET(ret, "SAMPLE_COMM_VENC_GetGopAttr FAIL, ret=%#x\n", ret);
+
+    ret = SAMPLE_COMM_VENC_Start(cfg->chnId,
+        cfg->codecType, cfg->sizeType, cfg->rcMode, cfg->profile, cfg->rcnRefShareBuf, &gopAttr);
+    HI_CHK_RET(ret, "SAMPLE_COMM_VENC_Start FAIL, ret=%#x\n", ret);
+    return 0;
+}
+
+/**
+    终止用VencCfg启动的VENC.
+*/
+int VecnStop(const VencCfg* cfg)
+{
+    HI_ASSERT(cfg && cfg->chnId >= 0);
+    int ret;
+
+    // step 1: Stop Recv Pictures
+    ret = HI_MPI_VENC_StopRecvFrame(cfg->chnId);
+    HI_CHK_RET(ret, "HI_MPI_VENC_StopRecvFrame(%d) FAIL, ret=%#x\n", cfg->chnId, ret);
+
+    // step 2: Distroy Venc Channel
+    ret = HI_MPI_VENC_DestroyChn(cfg->chnId);
+    HI_CHK_RET(ret, "HI_MPI_VENC_DestroyChn(%d) FAIL, ret=%#x\n", cfg->chnId, ret);
+    return 0;
+}
+
+/**
+    bind VI to VPSS.
+*/
+int ViBindVpss(VI_PIPE viPipe, VI_CHN viChn, VPSS_GRP vpssGrp)
+{
+    MPP_CHN_S srcChn;
+    MPP_CHN_S dstChn;
+
+    srcChn.enModId = HI_ID_VI;
+    srcChn.s32DevId = viPipe;
+    srcChn.s32ChnId = viChn;
+
+    dstChn.enModId = HI_ID_VPSS;
+    dstChn.s32DevId = vpssGrp;
+    dstChn.s32ChnId = 0;
+
+    int ret = HI_MPI_SYS_Bind(&srcChn, &dstChn);
+    HI_CHK_RET(ret, "HI_MPI_SYS_Bind(VI:%d, VPSS:%d) FAIL, ret=%#x\n", viChn, vpssGrp, ret);
+    return ret;
+}
+
+/**
+    unbind VI from VPSS.
+*/
+int ViUnbindVpss(VI_PIPE viPipe, VI_CHN viChn, VPSS_GRP vpssGrp)
+{
+    MPP_CHN_S srcChn;
+    MPP_CHN_S dstChn;
+
+    srcChn.enModId = HI_ID_VI;
+    srcChn.s32DevId = viPipe;
+    srcChn.s32ChnId = viChn;
+
+    dstChn.enModId = HI_ID_VPSS;
+    dstChn.s32DevId = vpssGrp;
+    dstChn.s32ChnId = 0;
+
+    int ret = HI_MPI_SYS_UnBind(&srcChn, &dstChn);
+    HI_CHK_RET(ret, "HI_MPI_SYS_UnBind(VI:%d, VPSS:%d) FAIL, ret=%#x\n", viChn, vpssGrp, ret);
+    return ret;
+}
+
+/**
+    bind VDEC to VPSS.
+*/
+int VdecBindVpss(VDEC_CHN vdecChn, VPSS_GRP vpssGrp)
+{
+    MPP_CHN_S srcChn;
+    MPP_CHN_S dstChn;
+
+    srcChn.enModId = HI_ID_VDEC;
+    srcChn.s32DevId = 0;
+    srcChn.s32ChnId = vdecChn;
+
+    dstChn.enModId = HI_ID_VPSS;
+    dstChn.s32DevId = vpssGrp;
+    dstChn.s32ChnId = 0;
+
+    int ret = HI_MPI_SYS_Bind(&srcChn, &dstChn);
+    HI_CHK_RET(ret, "HI_MPI_SYS_Bind(VDEC:%d, VPSS:%d) FAIL, ret=%#x\n", vdecChn, vpssGrp, ret);
+    return ret;
+}
+
+/**
+    unbind VDEC from VPSS.
+*/
+int VdecUnbindVpss(VDEC_CHN vdecChn, VPSS_GRP vpssGrp)
+{
+    MPP_CHN_S srcChn;
+    MPP_CHN_S dstChn;
+
+    srcChn.enModId = HI_ID_VDEC;
+    srcChn.s32DevId = 0;
+    srcChn.s32ChnId = vdecChn;
+
+    dstChn.enModId = HI_ID_VPSS;
+    dstChn.s32DevId = vpssGrp;
+    dstChn.s32ChnId = 0;
+
+    int ret = HI_MPI_SYS_UnBind(&srcChn, &dstChn);
+    HI_CHK_RET(ret, "HI_MPI_SYS_UnBind(VDEC:%d, VPSS:%d) FAIL, ret=%#x\n", vdecChn, vpssGrp, ret);
+    return ret;
+}
+
+/**
+    检测VDEC与VPSS是否绑定.
+*/
+bool VdecVpssBinded(VDEC_CHN vdecChn, VPSS_GRP vpssGrp)
+{
+    MPP_CHN_S srcChn;
+    MPP_CHN_S dstChn;
+
+    dstChn.enModId = HI_ID_VPSS;
+    dstChn.s32DevId = vpssGrp;
+    dstChn.s32ChnId = 0;
+
+    int ret = HI_MPI_SYS_GetBindbyDest(&dstChn, &srcChn);
+    HI_EXP_RET(ret, false, "HI_MPI_SYS_GetBindbyDest(VPSS:%d) FAIL, ret=%#x\n", vpssGrp, ret);
+    return srcChn.enModId == HI_ID_VDEC && srcChn.s32ChnId == vdecChn;
+}
+
+/**
+    获取sensor name.
+    sensor type在<sample_comm.h>中定义为enum SAMPLE_SNS_TYPE_E.
+*/
+const char* CurSnsType(int id, int* type)
+{
+    HI_ASSERT(id >= 0 && id < 2);
+    SAMPLE_SNS_TYPE_E snsType = (id == 0 ? SENSOR0_TYPE : SENSOR1_TYPE);
+
+    if (type)
+        *type = (int)snsType;
+
+    if (snsType == SONY_IMX458_MIPI_2M_90FPS_10BIT) {
+        return "IMX458";
+    } else if (snsType == SONY_IMX335_MIPI_4M_30FPS_12BIT) {
+        return "IMX335";
+    } else {
+        return "NONE";
+    }
+}
+
+/**
+    获取sensor的最大size.
+*/
+SIZE_S CurSnsMaxSize(SAMPLE_SNS_TYPE_E snsType)
+{
+    static const SIZE_S unknownSize = { 0, 0 };
+    PIC_SIZE_E sizeType;
+    SIZE_S maxSize;
+    HI_S32 ret;
+
+    ret = SAMPLE_COMM_VI_GetSizeBySensor(snsType, &sizeType);
+    if (ret != HI_SUCCESS) {
+        LOGE("SAMPLE_COMM_VI_GetSizeBySensor(%d) FAIL\n", (int)snsType);
+        return unknownSize;
+    }
+
+    ret = SAMPLE_COMM_SYS_GetPicSize(sizeType, &maxSize);
+    if (ret != HI_SUCCESS) {
+        LOGE("SAMPLE_COMM_SYS_GetPicSize(%d) FAIL\n", (int)sizeType);
+        return unknownSize;
+    }
+    return maxSize;
+}
+
+/**
+    MPP size type to size.
+*/
+SIZE_S MppSizetToSize(PIC_SIZE_E sizeType)
+{
+    SIZE_S size;
+
+    if (SAMPLE_COMM_SYS_GetPicSize(sizeType, &size) == 0) {
+        return size;
+    } else {
+        size.u32Width = 0;
+        size.u32Height = 0;
+        return size;
+    }
+}
+
+/**
+    新建VencStrm.
+*/
+VencFrm* VencFrmNew(size_t packsSize, VENC_CHN chn)
+{
+    VencFrm *vstrm = (VencFrm*)malloc(sizeof(*vstrm) + packsSize);
+    HI_EXP_RET(!vstrm, NULL, "alloc VencFrm FAIL\n");
+
+    vstrm->chn = chn;
+    INIT_LIST_HEAD(&vstrm->lnode);
+    vstrm->refNum = 1;
+
+    if (memset_s(&vstrm->strm, sizeof(vstrm->strm), 0, sizeof(vstrm->strm)) != EOK) {
+        HI_ASSERT(0);
+    }
+    vstrm->strm.pstPack = (VENC_PACK_S*)vstrm->packs;
+    return vstrm;
+}
+
+/**
+    增加引用.
+*/
+void VencFrmAddRef(VencFrm* vstrm)
+{
+    HI_ASSERT(vstrm);
+
+    if (__sync_add_and_fetch(&vstrm->refNum, 1) < 1) {
+        HI_ASSERT(0);
+    }
+}
+
+/**
+    释放引用.
+*/
+void VencFrmDelRef(VencFrm* vstrm)
+{
+    HI_ASSERT(vstrm);
+
+    int ref = __sync_sub_and_fetch(&vstrm->refNum, 1);
+    HI_ASSERT(ref >= 0);
+    if (ref < 1) {
+        int ret = HI_MPI_VENC_ReleaseStream(vstrm->chn, &vstrm->strm);
+        HI_EXP_LOGE(ret, "HI_MPI_VENC_ReleaseStream FAIL, ret=%#x\n", ret);
+        int res = list_empty(&vstrm->lnode);
+        HI_ASSERT(res); // 防止在断言中调用函数
+        free(vstrm);
+    }
+}
+
+/**
+    从VENC读取一帧.
+*/
+int VencGetFrm(VENC_STREAM_S *strm, VENC_CHN vencChn)
+{
+    HI_ASSERT(strm);
+    VENC_CHN_STATUS_S stat;
+    int ret;
+
+    if (memset_s(strm, sizeof(*strm), 0, sizeof(*strm)) != EOK ||
+        memset_s(&stat, sizeof(stat), 0, sizeof(stat)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    // 查询VENC输出状态，以获得frame size
+    stat.u32CurPacks = 0;
+    ret = HI_MPI_VENC_QueryStatus(vencChn, &stat);
+    HI_EXP_RET(ret, ret, "HI_MPI_VENC_QueryStatus FAIL, ret=%#x, chn=%d\n", ret, vencChn);
+    HI_EXP_RET(stat.u32CurPacks == 0, -1, "HI_MPI_VENC_QueryStatus OK, but packs=0\n");
+
+    // 分配用于保存frame的内存
+    strm->pstPack = (VENC_PACK_S*)malloc(stat.u32CurPacks * sizeof(VENC_PACK_S));
+    HI_EXP_RET(!strm->pstPack, -1, "alloc venc frm buf FAIL, size=%u\n", stat.u32CurPacks * sizeof(VENC_PACK_S));
+
+    // 从VENC get frame
+    strm->u32PackCount = stat.u32CurPacks;
+    ret = HI_MPI_VENC_GetStream(vencChn, strm, 0);
+    HI_EXP_GOTO(ret, FAIL, "HI_MPI_VENC_GetStream FAIL, ret=%#x\n", ret);
+    return 0;
+
+    FAIL:
+        if (strm->pstPack) {
+            free(strm->pstPack);
+        }
+        if (memset_s(strm, sizeof(*strm), 0, sizeof(*strm)) != EOK) {
+            HI_ASSERT(0);
+        }
+        return ret;
+}
+
+/**
+    从VENC读取一帧.
+*/
+int VencGetFrmx(VencFrm **self, VENC_CHN vencChn)
+{
+    HI_ASSERT(self);
+    *self = NULL;
+    VENC_CHN_STATUS_S stat = { 0 };
+    VencFrm *vstrm = NULL;
+    int ret;
+
+    // 查询VENC输出状态，以获得frame size
+    stat.u32CurPacks = 0;
+    ret = HI_MPI_VENC_QueryStatus(vencChn, &stat);
+    HI_EXP_RET(ret, ret, "HI_MPI_VENC_QueryStatus FAIL, ret=%#x, chn=%d\n", ret, vencChn);
+    HI_EXP_RET(stat.u32CurPacks == 0, -1, "HI_MPI_VENC_QueryStatus OK, but packs=0\n");
+
+    // 分配用于保存frame的内存
+    vstrm = VencFrmNew(stat.u32CurPacks * sizeof(VENC_PACK_S), vencChn);
+    HI_EXP_RET(!vstrm, -1, "alloc VencFrm FAIL, size=%u\n", stat.u32CurPacks * sizeof(VENC_PACK_S));
+
+    // 从VENC get frame
+    vstrm->strm.u32PackCount = stat.u32CurPacks;
+    ret = HI_MPI_VENC_GetStream(vencChn, &vstrm->strm, 0);
+    HI_EXP_GOTO(ret, FAIL, "HI_MPI_VENC_GetStream FAIL, ret=%#x\n", ret);
+    *self = vstrm;
+    return 0;
+
+    FAIL:
+        if (vstrm) {
+            VencFrmDelRef(vstrm);
+        }
+        return ret;
+}
+
+/**
+    将VENC输出的frame输出到MemBlk.
+*/
+MemBlk* VencFrmToMblk(const VENC_STREAM_S *frm, MemBlk* mblk, int pfxRsvSize)
+{
+    VENC_PACK_S *pack = NULL;
+    uint8_t *s = NULL;
+    int len;
+    int size;
+
+    // 未给出@param mblk时，分配之
+    if (!mblk) {
+        // 计算size
+        size = pfxRsvSize;
+        for (int i = 0; i < frm->u32PackCount; i++) {
+            pack = &frm->pstPack[i];
+            size += pack->u32Len - pack->u32Offset;
+        }
+        // 分配
+        HI_EXP_RET(!size, NULL, "frmSize=0\n");
+        mblk = MemBlkNew(size);
+        HI_EXP_RET(!mblk, NULL, "MemBlkNew FAIL\n");
+    }
+
+    mblk->offset = pfxRsvSize;
+    mblk->len = pfxRsvSize;
+
+    // copy
+    int lostLen = 0;
+    for (int i = 0; i < frm->u32PackCount; i++) {
+        pack = &frm->pstPack[i];
+        s = pack->pu8Addr + pack->u32Offset;
+
+        len = pack->u32Len - pack->u32Offset;
+        if (len > mblk->size - mblk->len) {
+            lostLen += (len - mblk->size - mblk->len);
+            len = mblk->size - mblk->len;
+        }
+
+        if (len > 0) {
+            if (memcpy_s(mblk->data + mblk->len, mblk->size - mblk->len, s, len) != EOK) {
+                HI_ASSERT(0);
+            }
+            mblk->len += len;
+            HI_ASSERT(mblk->len <= mblk->size);
+        }
+    }
+    HI_ASSERT(mblk->len <= mblk->size);
+
+    if (lostLen > 0) { // LOG warnning only
+        LOGE("venc frm to mblk buf overflow, lostLen=%d\n", lostLen);
+    }
+    return mblk;
+}
+
+/**
+    save venc out stream frame to file.
+*/
+int VencFrmToFile(const VENC_STREAM_S* strm, FILE* file)
+{
+    HI_ASSERT(strm && file);
+    int ret;
+
+    for (int i = 0; i < strm->u32PackCount; i++) {
+        ret = fwrite(strm->pstPack[i].pu8Addr + strm->pstPack[i].u32Offset,
+            strm->pstPack[i].u32Len - strm->pstPack[i].u32Offset, 1, file);
+        HI_EXP_RET(ret < 0, -errno, "SaveStrm FAIL, for fwrite FAIL, err='%s, %d'\n", strerror(errno), errno);
+    }
+    return 0;
+}
+
diff -urpBN hiopenais/src/mpp_help/mpp_sess.h hiopenais_modify/src/mpp_help/mpp_sess.h
--- hiopenais/src/mpp_help/mpp_sess.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/mpp_help/mpp_sess.h	2021-03-29 20:33:07.000000000 -0700
@@ -0,0 +1,611 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MPP_SESS_HELP_H
+#define MPP_SESS_HELP_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "hi_common.h"
+#include "hi_buffer.h"
+#include "hi_comm_sys.h"
+#include "hi_comm_vb.h"
+#include "hi_comm_isp.h"
+#include "hi_comm_vi.h"
+#include "hi_comm_vo.h"
+#include "hi_comm_venc.h"
+#include "hi_comm_vdec.h"
+#include "hi_comm_vpss.h"
+#include "hi_comm_region.h"
+#include "hi_comm_adec.h"
+#include "hi_comm_aenc.h"
+#include "hi_comm_ai.h"
+#include "hi_comm_ao.h"
+#include "hi_comm_aio.h"
+#include "hi_defines.h"
+#include "hi_comm_hdmi.h"
+#include "hi_mipi.h"
+#include "hi_comm_vgs.h"
+#include "hi_comm_ive.h"
+
+#include "mpi_sys.h"
+#include "mpi_vb.h"
+#include "mpi_vi.h"
+#include "mpi_vo.h"
+#include "mpi_venc.h"
+#include "mpi_vdec.h"
+#include "mpi_vpss.h"
+#include "mpi_region.h"
+#include "mpi_audio.h"
+#include "mpi_isp.h"
+#include "mpi_ae.h"
+#include "mpi_awb.h"
+#include "hi_math.h"
+#include "hi_sns_ctrl.h"
+#include "mpi_hdmi.h"
+#include "mpi_vgs.h"
+
+#include "sample_comm.h"
+
+#include "hi_ext_util.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*************************************************************************************************
+    VB config
+    设置好VbCfg后，可使用它初始化(创建)VB.
+*************************************************************************************************/
+/**
+    VB config
+*/
+typedef VB_CONFIG_S VbCfg;
+
+/**
+    初始化VbCfg
+*/
+void VbCfgInit(VbCfg* self);
+
+/**
+    添加一种size的一个pool.
+
+    根据参数的指示，计算出pool中每个buf的size，并添加到VbCfg中，在创建VB时使用.
+    VbCfgAddPool()等价于VbCfg_addPoolx(self1, bufNum, width, height, -1, -1, -1).
+
+    @param bufNum[in]: pool中buf的数量.
+    @param width[in]: frame的分辨率width.
+    @param height[in]: frame的分辨率height.
+    @param pixelFormat[in]: 置为-1表示使用默认值PIXEL_FORMAT_YUV_SEMIPLANAR_422.
+    @param bitWidth[in]: 置为-1表示使用默认值DATA_BITWIDTH_8.
+    @param compressMode[in]: 置为-1表示使用默认值COMPRESS_MODE_NONE.
+*/
+void VbCfgAddPool(VbCfg* self, int bufNum, int width, int height);
+void VbCfgAddPoolx(VbCfg* self,
+    int bufNum, int width, int height,
+    PIXEL_FORMAT_E pixelFormat,
+    DATA_BITWIDTH_E bitWidth,
+    COMPRESS_MODE_E compressMode);
+
+/**
+    添加针对特定sensor类型的一个pool.
+
+    即根据sensor的最大能力计算出需要的buf size，再调用VbCfg_addPool()添加.
+
+    @param bufNum[in]: pool中buf的数量.
+    @param snsType[in]: sensor type. 常用取值为SENSOR0_TYPE, SENSOR1_TYPE.
+*/
+void VbCfgAddForSns(VbCfg* self, int bufNum, SAMPLE_SNS_TYPE_E snsType);
+
+/*************************************************************************************************
+    VI config.
+
+    VI及其config直接使用mpp/sample，仅做简单封装，以简化使用。
+    设置好ViCfg后，可用它创建VI。
+*************************************************************************************************/
+/**
+    SAMPLE_VI_CONFIG_S别名.
+    提供的API VICfg_xxx()仅针对astViInfo[0]，及ViCfg仅代表一个VI。
+*/
+typedef SAMPLE_VI_CONFIG_S ViCfg;
+
+/**
+    init ViCfg.
+
+    它会获得编译配置确定的sensor type，并填充self->astViInfo[0].stSnsInfo。
+*/
+void ViCfgInit(ViCfg* self);
+
+/**
+    设置VI的DEV信息.
+
+    @param devId[in]: 设备ID，>=0.
+    @param wdrMode[in]: -1表示使用默认值WDR_MODE_NONE.
+*/
+void ViCfgSetDev(ViCfg* self, int devId, WDR_MODE_E wdrMode);
+
+/**
+    设置VI的PIPE信息.
+
+    @param pipe0Id[in]: pipe[0] id，>=0，-1表示禁用.
+    @param pipe1Id[in]: pipe[1] id，>=0，-1表示禁用.
+    @param pipe2Id[in]: pipe[2] id，>=0，-1表示禁用.
+    @param pipe3Id[in]: pipe[3] id，>=0，-1表示禁用.
+    @param mastPipeMode[in]: -1表示使用默认值VI_OFFLINE_VPSS_OFFLINE.
+*/
+void ViCfgSetPipe(ViCfg* self,
+    int pipe0Id, int pipe1Id, int pipe2Id, int pipe3Id,
+    VI_VPSS_MODE_E mastPipeMode);
+
+/**
+    设置VI通道.
+
+    @param chnId[in]: 使用的通道ID.
+    @param pixFormat[in]: -1表示使用默认值PIXEL_FORMAT_YVU_SEMIPLANAR_420.
+    @param videoFormat[in]: -1表示使用默认值VIDEO_FORMAT_LINEAR.
+    @param dynamicRange[in]: -1表示使用默认值DYNAMIC_RANGE_SDR8.
+    @param compressMode[in]: -1表示使用默认值COMPRESS_MODE_NONE.
+*/
+void ViCfgSetChn(ViCfg* self, int chnId,
+    PIXEL_FORMAT_E pixFormat, VIDEO_FORMAT_E videoFormat,
+    DYNAMIC_RANGE_E dynamicRange, COMPRESS_MODE_E compressMode);
+
+/**
+    获取sensor type.
+
+    ViCfgInit()中会根据编译配置确定sensor type，这里返回其配置的值。
+    也可以直接访问全局变量SENSOR0_TYPE，获得编译时配置的sensor type。
+*/
+SAMPLE_SNS_TYPE_E ViCfgSnsType(const ViCfg* self);
+
+/*************************************************************************************************
+    VDEC config.
+    设置好VdecCfg后，可使用它创建VDEC.
+*************************************************************************************************/
+/**
+    VDEC video config
+*/
+typedef struct VdecVideoCfg {
+    VIDEO_DEC_MODE_E enDecMode;
+    HI_U32 u32RefFrameNum;
+    DATA_BITWIDTH_E enBitWidth;
+}   VdecVideoCfg;
+
+/**
+    VDEC picture config
+*/
+typedef struct VdecPicCfg {
+    PIXEL_FORMAT_E enPixelFormat;
+    HI_U32 u32Alpha;
+}   VdecPicCfg;
+
+/**
+    VDEC config.
+*/
+typedef struct VdecCfg {
+    HI_S32 chnId;
+
+    VB_SOURCE_E vbSrcType;
+    PAYLOAD_TYPE_E codecType;
+    VIDEO_MODE_E videoMode;
+
+    HI_U32 maxWidth;
+    HI_U32 maxHeight;
+
+    HI_U32 frmBufNum;
+    HI_U32 displayFrmNum;
+
+    union {
+        VdecVideoCfg videoCfg;
+        VdecPicCfg picCfg;
+    };
+
+    int fps;
+}   VdecCfg;
+
+/**
+    设置VdecCfg.
+
+    用参数指定的信息填充VdecCfg.
+
+    @param chnId[in]: chn id.
+    @param codecType[in]: 编解码类型.
+    @param videoMode[in]: video mode. -1表示使用默认值VIDEO_MODE_FRAME.
+    @param vbSrcType[in]: vb buffer type. -1表示使用默认值VB_SOURCE_MODULE.
+    @param size[in]: 解码的最大分辨率. NULL表示使用芯片的最大能力.
+*/
+void VdecCfgInit(VdecCfg* self, int chnId,
+    PAYLOAD_TYPE_E codecType, VIDEO_MODE_E videoMode, VB_SOURCE_E vbSrcType,
+    const SIZE_S* size);
+
+/*************************************************************************************************
+    VPSS config
+    设置好VdecCfg后，可使用它创建VENC.
+*************************************************************************************************/
+/**
+    VPSS channel config.
+    用以设置一个channel的属性。
+*/
+typedef struct VpssChnCfg {
+    int id; // VpssChn ID
+    VPSS_CHN_ATTR_S attr; // VpssChn属性
+}   VpssChnCfg;
+
+/**
+    VPSS config.
+    每个VpssCfg对应1个VPSS group，及1个或多个VPSS channel.
+*/
+typedef struct VpssCfg {
+    VPSS_GRP grpId; // VpssGrp ID
+    VPSS_GRP_ATTR_S grpAttr; // VpssGrp属性
+
+    int chnNum; // 配置使用的chnnel数目
+    VpssChnCfg chnCfgs[VPSS_MAX_PHY_CHN_NUM]; // VpssChnCfg数组，前chnNum-1个元素有效
+}   VpssCfg;
+
+/**
+    初始化VpssCfg.
+
+    初始化VpssCfg后，用VpssCfg_setGrp(), VpssCfgAddChn()配置group和channels.
+    要重用已经配置好的VpssCfg，可再次调用此函数.
+*/
+void VpssCfgInit(VpssCfg* self);
+
+/**
+    设置VPSS group.
+
+    当@param grpAttr为NULL时，表示使用默认属性，如下
+    +   self->grpAttr.enPixelFormat = PIXEL_FORMAT_YVU_SEMIPLANAR_420;
+    +   self->grpAttr.enDynamicRange = DYNAMIC_RANGE_SDR8;
+    +   self->grpAttr.stFrameRate.s32SrcFrameRate = -1;
+    +   self->grpAttr.stFrameRate.s32DstFrameRate = -1;
+    +   self->grpAttr.bNrEn = HI_TRUE;
+
+    @param grpId[in]: VpssGrp ID.
+    @param grpAttr[in]: VpssGrp属性，其值会被复制到VpssCfg中. 置为NULL表示使用默认值.
+    @param maxWidth[in]: VpssGrp支持的最大width. 当grpAttr为NULL时使用.
+    @param maxHeight[in]: VpssGrp支持的最大height. 当grpAttr为NULL时使用.
+*/
+void VpssCfgSetGrp(VpssCfg* self,
+    int grpId, const VPSS_GRP_ATTR_S* grpAttr, int maxWidth, int maxHeight);
+
+/**
+    添加一个VPSS channel.
+
+    当@param chnAttr为NULL时，表示使用默认属性，如下
+    +   chnCfg->attr.enChnMode = VPSS_CHN_MODE_USER;
+    +   chnCfg->attr.enVideoFormat = VIDEO_FORMAT_LINEAR;
+    +   chnCfg->attr.enPixelFormat = PIXEL_FORMAT_YVU_SEMIPLANAR_420;
+    +   chnCfg->attr.enDynamicRange = DYNAMIC_RANGE_SDR8;
+    +   chnCfg->attr.enCompressMode = COMPRESS_MODE_NONE;
+    +   chnCfg->attr.stFrameRate.s32SrcFrameRate = -1;
+    +   chnCfg->attr.stFrameRate.s32DstFrameRate = -1;
+    +   chnCfg->attr.u32Depth = 2;
+    +   chnCfg->attr.bMirror = HI_FALSE;
+    +   chnCfg->attr.bFlip = HI_FALSE;
+    +   chnCfg->attr.stAspectRatio.enMode = ASPECT_RATIO_NONE;
+
+    @param chnId[in]: VpssChn ID.
+    @param chnAttr[in]: VpssChn属性，其值会被复制到VpssCfg中. 置为NULL表示使用默认值.
+    @param width[in]: VpssChn输出的width. 当chnAttr为NULL时使用.
+    @param height[in]: VpssChn输出的height. 当chnAttr为NULL时使用.
+*/
+VPSS_CHN_ATTR_S* VpssCfgAddChn(VpssCfg* self,
+    int chnId, const VPSS_CHN_ATTR_S* chnAttr, int width, int height);
+
+/*************************************************************************************************
+    VENC config
+    设置好VencCfg后，可使用它创建VENC.
+*************************************************************************************************/
+/**
+    VENC config.
+*/
+typedef struct VencCfg {
+    int chnId; // VencChn ID
+    PIC_SIZE_E sizeType; // 支持的分辨率type.
+    PAYLOAD_TYPE_E codecType; // 编解码类型
+    VENC_GOP_MODE_E gopMode; // GRP mode.
+    SAMPLE_RC_E rcMode; // rate control mode.
+
+    uint32_t profile;
+    bool rcnRefShareBuf;
+}   VencCfg;
+
+/**
+    设置VencCfg.
+
+    用参数指定的信息填充VencCfg.
+
+    @param chnId[in]: VencChn ID.
+    @param sizeType[in]: 分辨率type.
+    @param codecType[in]: 编解码类型.
+    @param grpMode[in]: GOP model. 置为-1表示使用默认值VENC_GOPMODE_NORMALP.
+    @param rcMode[in]: rate control mode. 置为-1表示使用默认值SAMPLE_RC_VBR.
+*/
+void VencCfgInit(VencCfg* self, int chnId,
+    PIC_SIZE_E sizeType, PAYLOAD_TYPE_E codecType,
+    VENC_GOP_MODE_E gopMode, SAMPLE_RC_E rcMode);
+
+/*************************************************************************************************
+    MPP session.
+*************************************************************************************************/
+#define SP_MPP_SESS
+
+/**
+    标记组件是否启用的flags
+*/
+#define MPP_VI      HI_BIT0
+#define MPP_VDEC    HI_BIT1
+#define MPP_VPSS    HI_BIT2
+#define MPP_VENC    HI_BIT3
+#define MPP_VO      HI_BIT5
+
+/**
+    MppSess超集.
+
+    MppSess对应的create()函数会将需要的cfg值复制到对象中，并启动session.
+
+    MppSess未提供构造函数，user只能通过create()函数创建对象，并用MppSess_destroy()销毁对象.
+
+    MppSess中定义了当前MppSess使用的资源ID，vpssGrp, vpssChn0, vpssChn1, vdecChn, vencChn.
+    这些值由create()设置，used未标识的组件的对应ID会被置为-1.这些资源ID从create()传入的
+    参数xxxCfg中获取，复制到对象中可简化APP使用.
+
+    目前没有定义VI的channel ID，其总是会与VPSS绑定后使用，通过VPSS chn即可获得VI的数据.
+*/
+typedef struct MppSess {
+    uint32_t used; // 启用的组件集合，由create()函数设置
+
+    ViCfg viCfg; // 可选的ViCfg
+    VdecCfg vdecCfg; // 可选的VdecCfg
+    VpssCfg vpssCfg; // 可选的VpssCfg
+    VencCfg vencCfg; // 可选的VencCfg
+
+    VPSS_GRP vpssGrp; // VPSS group ID, -1表示其对应的MPP组件未启动.
+    VPSS_CHN vpssChn0; // VPSS channel[0] ID, -1表示其对应的MPP组件未启动.
+    VPSS_CHN vpssChn1; // VPSS channel[1] ID, -1表示其对应的MPP组件未启动.
+    VDEC_CHN vdecChn; // VDEC channel ID, -1表示其对应的MPP组件未启动.
+    VENC_CHN vencChn; // VENC channel ID, -1表示其对应的MPP组件未启动.
+}   MppSess;
+
+/**
+    destroy MppSess.
+
+    它会终止MppSess中正在工作的各个组件，并free对象.
+    用任一MppSess create()创建的MppSess均用此函数destroy.
+*/
+void MppSessDestroy(MppSess* self);
+
+/**
+    创建并启动仅含VDEC的MppSess.
+
+    @param sess[out]: 成功时返回创建的sess，失败时返回NULL.
+    @param vdecCfg[in]: 使用的VdecCfg. 会被复制到sess中.
+*/
+int VdecCreate(MppSess** sess, const VdecCfg* vdecCfg);
+
+/**
+    创建并启动仅含VPSS的MppSess.
+
+    @param sess[out]: 成功时返回创建的sess，失败时返回NULL.
+    @param vpssCfg[in]: 使用的VpssCfg. 会被复制到sess中.
+*/
+int VpssCreate(MppSess** sess, const VpssCfg* vpssCfg);
+
+/**
+    创建并启动仅含VENC的MppSess.
+
+    @param sess[out]: 成功时返回创建的sess，失败时返回NULL.
+    @param vencCfg[in]: 使用的VencCfg. 会被复制到sess中.
+*/
+int VencCreate(MppSess** sess, const VencCfg* vencCfg);
+
+/**
+    创建并启动{VI->VPSS}MppSess.
+
+    它会建立VI->VPSS的绑定关系。
+
+    @param sess[out]: 成功时返回创建的sess，失败时返回NULL.
+    @param viCfg[in]: 使用的ViCfg. 会被复制到sess中.
+    @param vpssCfg[in]: 使用的VpssCfg. 会被复制到sess中.
+*/
+int ViVpssCreate(MppSess** sess, const ViCfg* viCfg, const VpssCfg* vpssCfg);
+
+/**
+    创建并启动{VDEC->VPSS}MppSess.
+
+    @param sess[out]: 成功时返回创建的sess，失败时返回NULL.
+    @param viCfg[in]: 使用的ViCfg. 会被复制到sess中.
+    @param vpssCfg[in]: 使用的VpssCfg. 会被复制到sess中.
+    @param bind[in]: 是否建立VDEC->VPSS的绑定关系.
+*/
+int VdecVpssCreate(MppSess** sess, const VdecCfg* vdecCfg, const VpssCfg* vpssCfg, bool bind);
+
+/*************************************************************************************************
+    MPP helper util
+*************************************************************************************************/
+#define SP_MPP_UTIL
+
+/**
+    初始化MPP，并创建VB.
+*/
+int MppSysInit(const VB_CONFIG_S* vbCfg);
+
+/**
+    销毁VB并去初始化MPP
+*/
+void MppSysExit(void);
+
+/**
+    Sensor scene init.
+    基于mpp/sample/auto_scene简单封装。
+*/
+int SceneInit(const char* sensorParamPath);
+
+/**
+    Sensor scene exit.
+    基于mpp/sample/auto_scene简单封装。
+*/
+void SceneExit(void);
+
+/**
+    根据ViCfg启动VI.
+*/
+int ViStart(const ViCfg* viCfg);
+
+/**
+    终止用ViCfg启动的VI.
+*/
+int ViStop(const ViCfg* viCfg);
+
+/**
+    根据VdecCfg启动VDEC.
+*/
+int VdecStart(const VdecCfg *vdecCfg);
+
+/**
+    终止用VdecCfg启动的VDEC.
+*/
+int VdecStop(const VdecCfg* vdecCfg);
+
+/**
+    根据VpssCfg启动VPSS.
+*/
+int VpssStart(const VpssCfg* cfg);
+
+/**
+    终止用VpssCfg启动的VPSS.
+*/
+int VpssStop(const VpssCfg* cfg);
+
+/**
+    根据VencCfg启动VENC.
+*/
+int VencStart(const VencCfg* cfg);
+
+/**
+    终止用VencCfg启动的VENC.
+*/
+int VecnStop(const VencCfg* cfg);
+
+/**
+    bind VI to VPSS.
+*/
+int ViBindVpss(VI_PIPE viPipe, VI_CHN viChn, VPSS_GRP vpssGrp);
+
+/**
+    unbind VI from VPSS.
+*/
+int ViUnbindVpss(VI_PIPE viPipe, VI_CHN viChn, VPSS_GRP vpssGrp);
+
+/**
+    bind VDEC to VPSS.
+*/
+int VdecBindVpss(VDEC_CHN vdecChn, VPSS_GRP vpssGrp);
+
+/**
+    unbind VDEC from VPSS.
+*/
+int VdecUnbindVpss(VDEC_CHN vdecChn, VPSS_GRP vpssGrp);
+
+/**
+    检测VDEC与VPSS是否绑定.
+*/
+bool VdecVpssBinded(VDEC_CHN vdecChn, VPSS_GRP vpssGrp);
+
+/**
+    获取sensor info
+
+    sensor信息是在编译时配置的，配置为SENSOR0_TYPE, SENSOR1_TYPE.
+    而该type值为宏名，在<sample_comm.h>中定义为enum SAMPLE_SNS_TYPE_E.
+    通过此函数可以返回其名称和ID(enum的值).
+
+    @param id[in]: sensor id, 0或1.
+    @param type[out]: sensor type, enum SAMPLE_SNS_TYPE_E的值.
+    @return sensor的名称.
+*/
+const char* CurSnsType(int id, int* type);
+
+/**
+    MPP size type to size.
+*/
+SIZE_S MppSizetToSize(PIC_SIZE_E sizeType);
+
+/**
+    获取sensor支持的最大size.
+*/
+SIZE_S CurSnsMaxSize(SAMPLE_SNS_TYPE_E snsType);
+
+/**
+    支持引用计数的VencStrm.
+*/
+typedef struct VencFrm {
+    VENC_STREAM_S strm;
+    VENC_CHN chn;
+    struct list_head lnode;
+    int refNum;
+    uint8_t packs[];
+}   VencFrm;
+
+/**
+    新建VencStrm.
+*/
+VencFrm* VencFrmNew(size_t packsSize, VENC_CHN chn);
+
+/**
+    增加引用.
+*/
+void VencFrmAddRef(VencFrm* strm);
+
+/**
+    释放引用.
+*/
+void VencFrmDelRef(VencFrm* strm);
+
+/**
+    从VENC读取一帧.
+    当监听到VENC有输出时，可调用此函数获取一帧.
+    此函数会为@param strm分配空间.
+*/
+int VencGetFrm(VENC_STREAM_S *strm, VENC_CHN vencChn);
+
+/**
+    从VENC读取一帧.
+*/
+int VencGetFrmx(VencFrm **self, VENC_CHN vencChn);
+
+/**
+    将VENC输出的frame输出到MemBlk.
+
+    将venc frame各pack组织为连续数据块输出到MemBlk。
+
+    @param mblk[in|out]: 为NULL表示请求此函数创建新的MemBlk。
+    @param pfxRsvSize[in]: 指示在@param mblk头部保留的字节长度，可为0。
+
+    @return 如果@param mblk为NULL，返回创建的MemBlk，否则返回mblk.
+*/
+MemBlk* VencFrmToMblk(const VENC_STREAM_S *frm, MemBlk* mblk, int pfxRsvSize);
+
+/**
+    save venc out stream frame to file.
+*/
+int VencFrmToFile(const VENC_STREAM_S* strm, FILE* file);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // MPP_SESS_HELP_H
diff -urpBN hiopenais/src/mpp_help/osd_img.c hiopenais_modify/src/mpp_help/osd_img.c
--- hiopenais/src/mpp_help/osd_img.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/mpp_help/osd_img.c	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,274 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <ctype.h>
+#include <stdbool.h>
+
+#include "hi_ext_util.h"
+#include "osd_img.h"
+
+#define OSD_FONT_ASC
+#define OSD_FONT_MOD_W          16
+#define OSD_FONT_MOD_H          32
+
+#define OSD_FONT_WIDTH_DEF      40 // 榛璁ょ瀛浣width
+#define OSD_FONT_HEIGHT_DEF     40 // 榛璁ょ瀛浣height
+
+/**
+    OSD瀛浣搴.
+*/
+static const HI_U8 G_FONT_LIB[] __attribute__((aligned(4))) = {
+#include "simsunb_16x32.dat"
+};
+
+/**
+    ㄥ瀵硅薄.
+    澶涓OsdSet瀹渚浼浠ㄥpool涓id
+*/
+static void* g_osdHndPool[HI_OSD_MAX_CNT]; // ㄤ互璇index handle琚浣跨
+static pthread_mutex_t g_osdMutex; // pool璁块
+
+/**
+    濮OSD瀛搴.
+*/
+static int OsdInitFont(HI_CHAR *character, HI_U8 **fontMod, HI_S32 *fontModLen)
+{
+    static const HI_CHAR baseChar = 0x20;
+
+    // Get Font Mod in ASCII Fontlib
+    HI_APPCOMM_CHECK_POINTER(character, HI_FAILURE);
+    HI_APPCOMM_CHECK_POINTER(fontMod, HI_FAILURE);
+    HI_APPCOMM_CHECK_POINTER(fontModLen, HI_FAILURE);
+    if (!isascii(character[0])) { // ュ颁负ASCII瀛绗杩true,杩NULL(0)
+        return HI_FAILURE;
+    }
+    HI_U32 offset = (character[0] - baseChar) * (OSD_FONT_MOD_H * OSD_FONT_MOD_W / HI_BYTE_BITS);
+    *fontMod = (HI_U8 *)G_FONT_LIB + offset;
+    *fontModLen = OSD_FONT_MOD_H * OSD_FONT_MOD_W / HI_BYTE_BITS;
+    return HI_SUCCESS;
+}
+
+/**
+    濮OsdSet lib.
+*/
+int OsdLibInit(void)
+{
+    RecurMutexInit(&g_osdMutex);
+
+#   if defined(OSD_FONT_HZK) || defined(OSD_FONT_ASC)
+    HI_OSD_FONTS_S stOsdFonts;
+    stOsdFonts.u32FontWidth = OSD_FONT_MOD_W;
+    stOsdFonts.u32FontHeight = OSD_FONT_MOD_H;
+    stOsdFonts.pfnGetFontMod = OsdInitFont;
+    return HI_OSD_Init(&stOsdFonts);
+#   else
+    return HI_OSD_Init(NULL);
+#   endif
+}
+
+/**
+    诲濮OsdSet lib.
+*/
+int OsdLibExit()
+{
+    MutexDestroy(&g_osdMutex);
+    return HI_OSD_Deinit();
+}
+
+/**
+    OSD region set.
+*/
+struct OsdSet {
+    /// OSD Binded Module: Static
+    HI_OSD_BIND_MOD_E bindMod;
+    /// Binded Module Handle: Static eg.VcapPipeHdl, VpssHdl, StitchHdl, DispHdl, 0
+    HI_U32 modHnd;
+    /// Binded Channel Handle: Static eg.PipeChnHdl, VPortHdl, StitchPortHdl, WndHdl, VencHdl
+    HI_U32 chnHnd;
+};
+
+/**
+    寤OsdSet.
+*/
+OsdSet* OsdsCreate(HI_OSD_BIND_MOD_E bindMod, HI_U32 modHnd, HI_U32 chnHnd)
+{
+    OsdSet *self = NULL;
+
+    self = (OsdSet*)malloc(sizeof(*self));
+    if (!self) {
+        HI_ASSERT(0);
+    }
+    if (memset_s(self, sizeof(*self), 0, sizeof(*self)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    self->bindMod = bindMod;
+    self->modHnd = modHnd;
+    self->chnHnd = chnHnd;
+    return self;
+}
+
+/**
+    姣OsdSet.
+*/
+void OsdsDestroy(OsdSet* self)
+{
+    HI_ASSERT(self);
+    OsdsClear(self);
+    free(self);
+}
+
+/**
+    姣OsdSet涓region.
+*/
+void OsdsClear(OsdSet* self)
+{
+    MutexLock(&g_osdMutex);
+    for (int i = 0; i < HI_ARRAY_SIZE(g_osdHndPool); i++) {
+        if (g_osdHndPool[i] && g_osdHndPool[i] == (void*)self) {
+            OsdsDestroyRgn(self, i);
+        }
+    }
+    MutexUnlock(&g_osdMutex);
+}
+
+/**
+    OsdSet涓寤轰涓region.
+*/
+int OsdsCreateRgn(OsdSet* self)
+{
+    HI_ASSERT(self);
+    int ret = -1;
+
+    MutexLock(&g_osdMutex);
+    for (int i = 0; i < HI_ARRAY_SIZE(g_osdHndPool); i++) {
+        if (!g_osdHndPool[i]) {
+            g_osdHndPool[i] = self;
+            ret = i;
+            break;
+        }
+    }
+    MutexUnlock(&g_osdMutex);
+    return ret;
+}
+
+/**
+    姣OsdSet涓瀹region.
+*/
+void OsdsDestroyRgn(OsdSet* self, int rgnHnd)
+{
+    HI_ASSERT(self);
+    HI_ASSERT(rgnHnd >= 0 && rgnHnd < HI_OSD_MAX_CNT);
+
+    MutexLock(&g_osdMutex);
+    HI_ASSERT(g_osdHndPool[rgnHnd] && g_osdHndPool[rgnHnd] == (void*)self);
+    g_osdHndPool[rgnHnd] = NULL;
+    MutexUnlock(&g_osdMutex);
+
+    HI_OSD_Stop(rgnHnd);
+}
+
+/**
+    涓OsdSet涓瀹region璁剧疆灞.
+*/
+int OsdsSetRgn(OsdSet* self, int rgnHnd, const HI_OSD_ATTR_S* rgnAttr)
+{
+    HI_ASSERT(self);
+    HI_ASSERT(rgnHnd >= 0 && rgnHnd < HI_OSD_MAX_CNT);
+    HI_ASSERT(g_osdHndPool[rgnHnd] && g_osdHndPool[rgnHnd] == (void*)self); // not need lock
+    HI_OSD_ATTR_S attr;
+    int ret;
+
+    if (!rgnAttr) { // hidden the region
+        if (memset_s(&attr, sizeof(attr), 0, sizeof(attr)) != EOK) {
+            HI_ASSERT(0);
+        }
+        attr.u32DispNum = 1;
+        attr.astDispAttr[0].bShow = HI_FALSE;
+    } else {
+        attr = *rgnAttr;
+    }
+
+    attr.astDispAttr[0].enBindedMod = self->bindMod;
+    attr.astDispAttr[0].ModHdl = self->modHnd;
+    attr.astDispAttr[0].ChnHdl = self->chnHnd;
+
+    ret = HI_OSD_SetAttr(rgnHnd, &attr);
+    HI_CHK_RET(ret, "HI_OSD_SetAttr FAIL, ret=%d\n", ret);
+
+    ret = HI_OSD_Start(rgnHnd);
+    HI_CHK_RET(ret, "HI_OSD_Start FAIL, ret=%d\n", ret);
+    return 0;
+}
+
+/**
+    峰OsdSet涓瀹region灞у.
+*/
+int OsdsGetRgn(OsdSet* self, int rgnHnd, HI_OSD_ATTR_S* rgnAttr)
+{
+    HI_ASSERT(self && rgnAttr);
+    HI_ASSERT(rgnHnd >= 0 && rgnHnd < HI_OSD_MAX_CNT);
+    HI_ASSERT(g_osdHndPool[rgnHnd] && g_osdHndPool[rgnHnd] == (void*)self); // not need lock
+    HI_S32 ret;
+
+    ret = HI_OSD_GetAttr(rgnHnd, rgnAttr);
+    if (ret == HI_SUCCESS) {
+        return 0;
+    }
+    if (memset_s(rgnAttr, sizeof(*rgnAttr), 0, sizeof(*rgnAttr)) != EOK) {
+        HI_ASSERT(0);
+    }
+    return ret;
+}
+
+/**
+    璁剧疆region灞у.
+*/
+int TxtRgnInit(HI_OSD_ATTR_S* rgnAttr,
+    const char* str, uint32_t begX, uint32_t begY,
+    uint32_t color, int fontWidth, int fontHeight)
+{
+    HI_ASSERT(rgnAttr);
+    if (!str) {
+        HI_ASSERT(0);
+    }
+    static const uint32_t bgAlpha = 64; // [0,128]锛瀛搴锛瓒澶у棰茶娣憋0琛ㄧず锛冲ㄩ
+    static const uint32_t fgAlpha = 128; // [0,128]锛瀛浜搴锛瓒澶у瀛瓒浜
+
+    if (memset_s(rgnAttr, sizeof(*rgnAttr), 0, sizeof(*rgnAttr)) != EOK) {
+        HI_ASSERT(0);
+    }
+    rgnAttr->u32DispNum = 1;
+    rgnAttr->astDispAttr[0].bShow = (str && *str) ? HI_TRUE : HI_FALSE;
+    rgnAttr->astDispAttr[0].enBindedMod = HI_OSD_BINDMOD_BUTT;
+    rgnAttr->astDispAttr[0].ChnHdl = UINT32_MAX;
+    rgnAttr->astDispAttr[0].u32BgAlpha = bgAlpha;
+    rgnAttr->astDispAttr[0].u32FgAlpha = fgAlpha;
+    rgnAttr->astDispAttr[0].enCoordinate = HI_OSD_COORDINATE_ABS_COOR;
+    rgnAttr->astDispAttr[0].stStartPos.s32X = begX;
+    rgnAttr->astDispAttr[0].stStartPos.s32Y = begY;
+    rgnAttr->astDispAttr[0].enAttachDest = ATTACH_JPEG_MAIN;
+    rgnAttr->stContent.enType = HI_OSD_TYPE_STRING;
+    rgnAttr->stContent.u32Color = color; // ARGB #FFFF0000 Red
+    HiStrxfrm(rgnAttr->stContent.szStr, str, sizeof(rgnAttr->stContent.szStr));
+    rgnAttr->stContent.stFontSize.u32Width = fontWidth <= 0 ? OSD_FONT_WIDTH_DEF : fontWidth;
+    rgnAttr->stContent.stFontSize.u32Height = fontHeight <= 0 ? OSD_FONT_HEIGHT_DEF : fontHeight;
+    return 0;
+}
+
diff -urpBN hiopenais/src/mpp_help/osd_img.h hiopenais_modify/src/mpp_help/osd_img.h
--- hiopenais/src/mpp_help/osd_img.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/mpp_help/osd_img.h	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,125 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef OSD_HELP_H
+#define OSD_HELP_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "hi_common.h"
+#include "hi_comm_video.h"
+#include "hi_comm_venc.h"
+#include "hi_osd.h"
+#include "hi_ext_util.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    OSD region set.
+
+    OsdSet表示一个OSD region集合. 可以在OsdSet中创建和销毁region, 为region设置属性以显示或不显示.
+    OsdSet基于中间件HI_OSD实现. 相对于HI_OSD，增加了region句柄分配/释放管理, 以简化使用.
+*/
+typedef struct OsdSet OsdSet;
+
+/**
+    创建OsdSet.
+
+    @param bindMod[in]: OSD绑定的MPP组件.
+    @param modHnd[in]: Binded Module Handle.
+    @param chnHnd[in]: Binded Channel Handle.
+*/
+OsdSet* OsdsCreate(HI_OSD_BIND_MOD_E bindMod, uint32_t modHnd, uint32_t chnHnd);
+
+/**
+    销毁OsdSet.
+*/
+void OsdsDestroy(OsdSet* self);
+
+/**
+    销毁OsdSet中的所有region.
+*/
+void OsdsClear(OsdSet* self);
+
+/**
+    在OsdSet中创建一个region.
+
+    @return 成功则返回创建的region的句柄，否则返回-1. 当OsdSet中的region用完后create会失败.
+*/
+int OsdsCreateRgn(OsdSet* self);
+
+/**
+    销毁OsdSet中指定的region.
+
+    @param rgnHnd[in]: OsdsCreateRgn()为region分配的句柄.
+*/
+void OsdsDestroyRgn(OsdSet* self, int rgnHnd);
+
+/**
+    为OsdSet中的指定region设置属性.
+
+    @param rgnHnd[in]: OsdsCreateRgn()为region分配的句柄.
+    @param rgnAttr[in]: 置为NULL表示不显示region，否则表示用rgnAttr的属性值显示region.
+*/
+int OsdsSetRgn(OsdSet* self, int rgnHnd, const HI_OSD_ATTR_S* rgnAttr);
+
+/**
+    获得OsdSet中指定region的属性值.
+
+    @param rgnHnd[in]: OsdsCreateRgn()为region分配的句柄.
+    @param rgnAttr[out]: 若成功，则返回region的属性值.
+*/
+int OsdsGetRgn(OsdSet* self, int rgnHnd, HI_OSD_ATTR_S* rgnAttr);
+
+/**
+    设置文本region的属性值.
+
+    设置后的rgnAttr可用于`OsdsSetRgn()`，以设置和显示指定的region.
+
+    @param str[in]: 待显示的字符串文本.
+    @param begX[in]: 显示文本的起点的X坐标.
+    @param begY[in]: 显示文本的起点的Y坐标.
+    @param color[in]: 文本的颜色. ARGB1555格式.
+    @param foutWidth[in]: 字体的width(像素). 置为-1表示采用默认值.
+    @param foutHeight[in]: 字体的height(像素). 置为-1表示采用默认值.
+*/
+int TxtRgnInit(HI_OSD_ATTR_S* rgnAttr,
+    const char* str, uint32_t begX, uint32_t begY,
+    uint32_t color, int fontWidth, int fontHeight);
+
+/**
+    初始化OsdSet lib.
+
+    通常在app启动时调用.
+    对于HiOpenais，插件不应调用此函数。
+*/
+int OsdLibInit(void);
+
+/**
+    去初始化OsdSet lib.
+
+    通常在app终止时调用.
+    对于HiOpenais，插件不应调用此函数。
+*/
+int OsdLibExit(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // OSD_HELP_H
diff -urpBN hiopenais/src/mpp_help/vgs_img.c hiopenais_modify/src/mpp_help/vgs_img.c
--- hiopenais/src/mpp_help/vgs_img.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/mpp_help/vgs_img.c	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,420 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdbool.h>
+
+#include "hi_comm_vb.h"
+#include "hi_comm_vgs.h"
+#include "hi_comm_region.h"
+#include "mpi_sys.h"
+#include "mpi_vgs.h"
+#include "sample_comm.h"
+
+#include "hi_ext_util.h"
+#include "vgs_img.h"
+
+// 褰缂╂惧>15讹瀹姐楂搴4绱瀵归锛瑕2绱瀵归
+#define VGS_ZOOM_IN_MAX         16 // 涓娆℃浣澶ф惧ぇ
+#define VGS_ZOOM_OUT_MAX        30 // 涓娆℃浣澶х缉灏
+
+#define VGS_MAX_LINE            100 // 涓娆″惧舰浣澶line
+#define RECT_LINES              4 // 涓涓╁舰寸嚎扮.
+#define LINE_THICK              2 // 惧舰绾挎″搴榛璁ゅ.
+
+#define RECT_LINE1              1
+#define RECT_LINE2              2
+#define RECT_LINE3              3
+#define WIDTH_THRESH            4
+#define HEIGHT_THREEH           4
+#define DRAWCROSS_NUM           2
+
+/**
+    灏存板涓淇翠负舵.
+*/
+static inline int IntToOven(int x)
+{
+    if (x % HI_OVEN_BASE == 0) {
+        return x;
+    } else {
+        return x + 1;
+    }
+}
+
+/**
+    ц涓娆VGS resize.
+
+    姣涓娆VGS resize缂╂惧版剁. VGS瀵逛骞惧杩琛缂╂撅澶ф惧
+    瀹介惧ぇ16锛缂╁30 锛Y锛缂╂俱
+*/
+static int VgsResizeOnce(
+    const VIDEO_FRAME_INFO_S* src,
+    VIDEO_FRAME_INFO_S* dst,
+    uint32_t dstWidth, uint32_t dstHeight)
+{
+    HI_ASSERT(src && dst);
+    HI_ASSERT(dstWidth > 0 && dstHeight > 0);
+    VGS_HANDLE jobHnd = -1;
+    VGS_TASK_ATTR_S task;
+    int ret;
+
+    ret = MppFrmCreate(dst, dstWidth, dstHeight,
+        src->stVFrame.enPixelFormat, DATA_BITWIDTH_8,
+        src->stVFrame.enCompressMode, 0);
+    HI_CHK_RET(ret, "frm resize FAIL, for create dstFrm FAIL\n");
+
+    if (memset_s(&task, sizeof(task), 0, sizeof(task)) != EOK) {
+        HI_ASSERT(0);
+    }
+    task.stImgIn = *src;
+    task.stImgOut = *dst;
+
+    ret = HI_MPI_VGS_BeginJob(&jobHnd);
+    HI_CHK_GOTO(ret, FAIL, "HI_MPI_VGS_BeginJob FAIL, ret=%08X\n", ret);
+    HI_ASSERT(jobHnd >= 0);
+
+    ret = HI_MPI_VGS_AddScaleTask(jobHnd, &task, VGS_SCLCOEF_NORMAL);
+    HI_CHK_GOTO(ret, FAIL, "HI_MPI_VGS_AddScaleTask FAIL, ret=%08X\n", ret);
+
+    ret = HI_MPI_VGS_EndJob(jobHnd);
+    HI_CHK_GOTO(ret, FAIL, "HI_MPI_VGS_EndJob FAIL, ret=%08X\n", ret);
+    return 0;
+
+    FAIL:
+        if (jobHnd >= 0 && HI_MPI_VGS_CancelJob(jobHnd) != HI_SUCCESS) {
+            HI_ASSERT(0);
+        }
+        MppFrmDestroy(dst);
+        return ret;
+}
+
+/**
+    寤哄苟цVGS draw lines job.
+*/
+static HI_S32 VgsDrawLines(
+    VIDEO_FRAME_INFO_S *frm,
+    const VGS_DRAW_LINE_S lines[], int lineNum)
+{
+    VGS_HANDLE jobHnd = -1;
+    VGS_TASK_ATTR_S task;
+    int ret;
+
+    if (memset_s(&task, sizeof(task), 0, sizeof(task)) != EOK) {
+        HI_ASSERT(0);
+    }
+    task.stImgIn = *frm;
+    task.stImgOut = *frm;
+
+    ret = HI_MPI_VGS_BeginJob(&jobHnd);
+    HI_CHK_GOTO(ret, FAIL, "HI_MPI_VGS_BeginJob FAIL, ret=%08X\n", ret);
+    HI_ASSERT(jobHnd >= 0);
+
+    ret = HI_MPI_VGS_AddDrawLineTaskArray(jobHnd, &task, lines, lineNum);
+    HI_CHK_GOTO(ret, FAIL, "HI_MPI_VGS_AddDrawLineTaskArray FAIL, ret=%08X\n", ret);
+
+    ret = HI_MPI_VGS_EndJob(jobHnd);
+    HI_CHK_GOTO(ret, FAIL, "HI_MPI_VGS_EndJob FAIL, ret=%08X\n", ret);
+    return 0;
+
+    FAIL:
+        if (jobHnd >= 0 && HI_MPI_VGS_CancelJob(jobHnd) != HI_SUCCESS) {
+            HI_ASSERT(0);
+        }
+        return ret;
+}
+
+/**
+    璁剧疆framebuf.
+*/
+static void MppFrmSetBuf(VIDEO_FRAME_INFO_S* frm,
+    const VB_CAL_CONFIG_S *vbCfg, HI_U64 phyAddr, uint8_t *virAddr)
+{
+    // SP422/SP420锛涓SP444锛娌℃浣跨addr[2]
+    frm->stVFrame.u32HeaderStride[0] = vbCfg->u32HeadStride;
+    frm->stVFrame.u32HeaderStride[1] = vbCfg->u32HeadStride;
+    frm->stVFrame.u32HeaderStride[2] = vbCfg->u32HeadStride; // 2: 扮涓,涓瓒
+    frm->stVFrame.u64HeaderPhyAddr[0] = phyAddr;
+    frm->stVFrame.u64HeaderPhyAddr[1] = frm->stVFrame.u64HeaderPhyAddr[0] + vbCfg->u32HeadYSize;
+    frm->stVFrame.u64HeaderPhyAddr[2] = frm->stVFrame.u64HeaderPhyAddr[1]; // 2: 扮涓,涓瓒
+    frm->stVFrame.u64HeaderVirAddr[0] = (HI_U64)(HI_UL)virAddr;
+    frm->stVFrame.u64HeaderVirAddr[1] = frm->stVFrame.u64HeaderVirAddr[0] + vbCfg->u32HeadYSize;
+    frm->stVFrame.u64HeaderVirAddr[2] = frm->stVFrame.u64HeaderVirAddr[1]; // 2: 扮涓,涓瓒
+
+    frm->stVFrame.u32Stride[0] = vbCfg->u32MainStride;
+    frm->stVFrame.u32Stride[1] = vbCfg->u32MainStride;
+    frm->stVFrame.u32Stride[2] = vbCfg->u32MainStride; // 2: 扮涓,涓瓒
+    frm->stVFrame.u64PhyAddr[0] = frm->stVFrame.u64HeaderPhyAddr[0] + vbCfg->u32HeadSize;
+    frm->stVFrame.u64PhyAddr[1] = frm->stVFrame.u64PhyAddr[0] + vbCfg->u32MainYSize;
+    frm->stVFrame.u64PhyAddr[2] = frm->stVFrame.u64PhyAddr[1]; // 2: 扮涓,涓瓒
+    frm->stVFrame.u64VirAddr[0] = frm->stVFrame.u64HeaderVirAddr[0] + vbCfg->u32HeadSize;
+    frm->stVFrame.u64VirAddr[1] = frm->stVFrame.u64VirAddr[0] + vbCfg->u32MainYSize;
+    frm->stVFrame.u64VirAddr[2] = frm->stVFrame.u64VirAddr[1]; // 2: 扮涓,涓瓒
+}
+
+/**
+    寤轰涓绌虹frame buf.
+*/
+int MppFrmCreate(
+    VIDEO_FRAME_INFO_S* frm,
+    int width, int height,
+    PIXEL_FORMAT_E pixelFormat,
+    DATA_BITWIDTH_E bitWidth,
+    COMPRESS_MODE_E compressMode,
+    int align)
+{
+    HI_ASSERT(frm);
+    VB_CAL_CONFIG_S vbCfg;
+
+    if (memset_s(frm, sizeof(*frm), 0, sizeof(*frm)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    HI_ASSERT(width > 0 && height > 0);
+    if ((int)pixelFormat < 0) {
+        pixelFormat = PIXEL_FORMAT_YVU_SEMIPLANAR_420;
+    }
+    if ((int)bitWidth < 0) {
+        bitWidth = DATA_BITWIDTH_8;
+    }
+    if ((int)compressMode < 0) {
+        compressMode = COMPRESS_MODE_NONE;
+    }
+    if (align < 0) {
+        align = 0;
+    }
+
+    COMMON_GetPicBufferConfig(width, height, pixelFormat, bitWidth, compressMode, align, &vbCfg);
+
+    VB_BLK vbHnd = HI_MPI_VB_GetBlock(VB_INVALID_POOLID, vbCfg.u32VBSize, NULL);
+    HI_EXP_RET(vbHnd == VB_INVALID_HANDLE, -1, "HI_MPI_VB_GetBlock FAIL\n");
+
+    HI_U64 phyAddr = HI_MPI_VB_Handle2PhysAddr(vbHnd);
+    HI_ASSERT(phyAddr);
+    uint8_t* virAddr = (uint8_t*)HI_MPI_SYS_Mmap(phyAddr, vbCfg.u32VBSize);
+    HI_ASSERT(virAddr);
+
+    // u64PrivateDataㄦュㄦ灏瀛洪垮害vbHnd锛destroy朵ㄥ
+    frm->stVFrame.u64PrivateData = ((uint64_t)(uint32_t)vbHnd) << HI_INT32_BITS;
+    frm->stVFrame.u64PrivateData |= (uint64_t)vbCfg.u32VBSize; // ensure xiao
+
+    frm->enModId = HI_ID_VGS;
+    frm->u32PoolId = HI_MPI_VB_Handle2PoolId(vbHnd);
+
+    frm->stVFrame.u32Width = width;
+    frm->stVFrame.u32Height = height;
+    frm->stVFrame.enField = VIDEO_FIELD_FRAME;
+    frm->stVFrame.enPixelFormat = pixelFormat;
+    frm->stVFrame.enVideoFormat = VIDEO_FORMAT_LINEAR;
+    frm->stVFrame.enCompressMode = compressMode;
+    frm->stVFrame.enDynamicRange = DYNAMIC_RANGE_SDR8;
+    frm->stVFrame.enColorGamut = COLOR_GAMUT_BT601;
+
+    MppFrmSetBuf(frm, &vbCfg, phyAddr, virAddr);
+    return HI_SUCCESS;
+}
+
+/**
+    姣frame.
+*/
+void MppFrmDestroy(VIDEO_FRAME_INFO_S* frm)
+{
+    if (!MppFrmValid(frm)) {
+        return;
+    }
+
+    // u64PrivateData琚ㄦュㄦ灏瀛洪垮害vbHnd锛create惰剧疆
+    uint32_t memSize = (uint32_t)(frm->stVFrame.u64PrivateData);
+    uint32_t vbHnd = (uint32_t)(frm->stVFrame.u64PrivateData >> HI_INT32_BITS);
+    HI_S32 ret;
+
+    ret = HI_MPI_SYS_Munmap((void*)(uintptr_t)frm->stVFrame.u64VirAddr[0], memSize);
+    HI_ASSERT(ret == HI_SUCCESS);
+    ret = HI_MPI_VB_ReleaseBlock(vbHnd);
+    HI_ASSERT(ret == HI_SUCCESS);
+    if (memset_s(frm, sizeof(*frm), 0, sizeof(*frm)) != EOK) {
+        HI_ASSERT(0);
+    }
+}
+
+/**
+    ゆframe. 虫浜瀛.
+*/
+bool MppFrmValid(const VIDEO_FRAME_INFO_S* frm)
+{
+    // VPSS杈虹frame榛璁ゆ病灏板
+    return frm->stVFrame.u64PhyAddr[0];
+}
+
+/**
+    resize frame.
+
+    澶娆¤vgs_resize浠ュ颁换姣渚缂╂俱
+    涓虹瀹帮绾瀹姣娆＄缉炬澶14锛姝ゆ跺姐楂浠2绱瀵归
+
+    褰涓や釜瑰缂╂炬瑰涓讹渚濡涓(濡X)惧ぇ锛涓缂╁锛瑰澶
+    姝ゆ舵涓瑰涓や釜瑰缂╂炬渚瓒锛涔涓瑕瑰澶
+*/
+int MppFrmResize(
+    const VIDEO_FRAME_INFO_S* src,
+    VIDEO_FRAME_INFO_S* dst,
+    uint32_t dstWidth, uint32_t dstHeight)
+{
+    static const double rateMax = 14.0; // 惧ぇ澶у
+    static const double rateMin = 1.0 / rateMax; // 惧ぇ灏帮涔崇缉灏澶ф渚
+
+    uint32_t srcWidth = src->stVFrame.u32Width;
+    uint32_t srcHeight = src->stVFrame.u32Height;
+    HI_ASSERT(srcWidth > 0 && srcHeight > 0);
+    HI_ASSERT(!(srcWidth % HI_OVEN_BASE) && !(srcHeight % HI_OVEN_BASE));
+    HI_ASSERT(dstWidth > 0 && dstHeight > 0);
+    HI_ASSERT(!(dstWidth % HI_OVEN_BASE) && !(dstHeight % HI_OVEN_BASE));
+    int ret;
+
+    // 惧ぇ
+    double widthRate = ((double)dstWidth) / (double)srcWidth; // >1琛ㄧず惧ぇ锛<1琛ㄧず缂╁
+    double heightRate = ((double)dstHeight) / (double)srcHeight; // >1琛ㄧず惧ぇ锛<1琛ㄧず缂╁
+
+    // 规缂╂惧板澶
+    if (widthRate > rateMax || widthRate < rateMin ||
+        heightRate > rateMax || heightRate < rateMin) {
+        // 缂╂惧拌杩涓娆VGS澶у兼讹褰澶 ...
+        uint32_t midWidth = (uint32_t)IntZoomTo((int)srcWidth, widthRate, rateMin, rateMax);
+        uint32_t midHeight = (uint32_t)IntZoomTo((int)srcHeight, heightRate, rateMin, rateMax);
+        // 纭淇涓哄舵般涓哄版讹惧ぇ涓锛涓
+        if (midWidth % HI_OVEN_BASE) {
+            midWidth += widthRate > 1 ? -1 : 1;
+        }
+        if (midHeight % HI_OVEN_BASE) {
+            midHeight += heightRate > 1 ? -1 : 1;
+        }
+
+        LOGD("@@@ multi-lev vgs resize, src={%u, %u}, mid={%u, %u}, dst={%u, %u}, rate={%.4f, %.4f}\n",
+            srcWidth, srcHeight, midWidth, midHeight, dstWidth, dstHeight, widthRate, heightRate);
+
+        // 缂╂句娆
+        VIDEO_FRAME_INFO_S midFrm;
+        ret = VgsResizeOnce(src, &midFrm, midWidth, midHeight);
+        HI_CHK_RET(ret, "VgsResizeOnce(dw=%u, dh=%u) FAIL\n", midWidth, midHeight);
+
+        // 浠midFrm涓src褰璋
+        ret = MppFrmResize(&midFrm, dst, dstWidth, dstHeight);
+        MppFrmDestroy(&midFrm);
+        HI_CHK_RET(ret, "sub call MppFrmResize(dw=%u, dh=%u) FAIL\n", dstWidth, dstHeight);
+    } else { // 缂╂惧版瓒杩涓娆VGS澶у硷存ュ
+        ret = VgsResizeOnce(src, dst, dstWidth, dstHeight);
+        HI_CHK_RET(ret, "VgsResizeOnce(dw=%u, dh=%u) FAIL\n", dstWidth, dstHeight);
+    }
+    return ret;
+}
+
+/**
+    frame涓涓涓澶涓╁舰妗.
+*/
+int MppFrmDrawRects(VIDEO_FRAME_INFO_S *frm,
+    const RectBox *boxes, int boxesNum, uint32_t color, int thick)
+{
+    VGS_DRAW_LINE_S lines[VGS_MAX_LINE];
+    int i;
+
+    if (thick <= 0) {
+        thick = LINE_THICK;
+    }
+
+    // 灏╁舰杈瑰钩㈠涓lines
+    for (i = 0; i < boxesNum; i++) {
+        lines[RECT_LINES * i].stStartPoint.s32X = IntToOven(boxes[i].xmin);
+        lines[RECT_LINES * i].stStartPoint.s32Y = IntToOven(boxes[i].ymin);
+        lines[RECT_LINES * i].stEndPoint.s32X = IntToOven(boxes[i].xmax);
+        lines[RECT_LINES * i].stEndPoint.s32Y = IntToOven(boxes[i].ymin);
+        lines[RECT_LINES * i].u32Color = color;
+        lines[RECT_LINES * i].u32Thick = thick;
+        lines[RECT_LINES * i + RECT_LINE1].stStartPoint.s32X = IntToOven(boxes[i].xmax);
+        lines[RECT_LINES * i + RECT_LINE1].stStartPoint.s32Y = IntToOven(boxes[i].ymin);
+        lines[RECT_LINES * i + RECT_LINE1].stEndPoint.s32X = IntToOven(boxes[i].xmax);
+        lines[RECT_LINES * i + RECT_LINE1].stEndPoint.s32Y = IntToOven(boxes[i].ymax);
+        lines[RECT_LINES * i + RECT_LINE1].u32Color = color;
+        lines[RECT_LINES * i + RECT_LINE1].u32Thick = thick;
+        lines[RECT_LINES * i + RECT_LINE2].stStartPoint.s32X = IntToOven(boxes[i].xmax);
+        lines[RECT_LINES * i + RECT_LINE2].stStartPoint.s32Y = IntToOven(boxes[i].ymax);
+        lines[RECT_LINES * i + RECT_LINE2].stEndPoint.s32X = IntToOven(boxes[i].xmin);
+        lines[RECT_LINES * i + RECT_LINE2].stEndPoint.s32Y = IntToOven(boxes[i].ymax);
+        lines[RECT_LINES * i + RECT_LINE2].u32Color = color;
+        lines[RECT_LINES * i + RECT_LINE2].u32Thick = thick;
+        lines[RECT_LINES * i + RECT_LINE3].stStartPoint.s32X = IntToOven(boxes[i].xmin);
+        lines[RECT_LINES * i + RECT_LINE3].stStartPoint.s32Y = IntToOven(boxes[i].ymax);
+        lines[RECT_LINES * i + RECT_LINE3].stEndPoint.s32X = IntToOven(boxes[i].xmin);
+        lines[RECT_LINES * i + RECT_LINE3].stEndPoint.s32Y = IntToOven(boxes[i].ymin);
+        lines[RECT_LINES * i + RECT_LINE3].u32Color = color;
+        lines[RECT_LINES * i + RECT_LINE3].u32Thick = thick;
+    }
+    return VgsDrawLines(frm, lines, i * RECT_LINES);
+}
+
+/**
+    frame涓涓涓╁舰妗.
+*/
+int MppFrmDrawRect(VIDEO_FRAME_INFO_S *frm,
+    const RectBox *box, uint32_t color, int thick)
+{
+    return MppFrmDrawRects(frm, box, 1, color, thick);
+}
+
+/**
+    frame涓涓涓瀛.
+*/
+int MppFrmDrawCross(VIDEO_FRAME_INFO_S *frm,
+    int x, int y, int width, int height, uint32_t color, int thick)
+{
+    HI_ASSERT(width >= WIDTH_THRESH);
+    HI_ASSERT(height >= HEIGHT_THREEH);
+    VGS_DRAW_LINE_S lines[2]; // 浠2line
+    VGS_DRAW_LINE_S *line = NULL;
+    int xmin, xmax, ymin, ymax;
+
+    thick = thick <= 0 ? LINE_THICK : thick;
+
+    // 姘村钩绾
+    xmin = x - width / DRAWCROSS_NUM;
+    xmin = HI_MAX(xmin, 0);
+    ymin = y;
+    xmax = x + width / DRAWCROSS_NUM;
+    ymax = y;
+    line = &lines[0];
+    line->stStartPoint.s32X = IntToOven(xmin);
+    line->stStartPoint.s32Y = IntToOven(ymin);
+    line->stEndPoint.s32X = IntToOven(xmax);
+    line->stEndPoint.s32Y = IntToOven(ymax);
+    line->u32Color = color;
+    line->u32Thick = thick;
+
+    // 寸嚎
+    xmin = x;
+    ymin = y - height / DRAWCROSS_NUM;
+    ymin = HI_MAX(ymin, 0);
+    xmax = x;
+    ymax = y + height / DRAWCROSS_NUM;
+    line = &lines[1];
+    line->stStartPoint.s32X = IntToOven(xmin);
+    line->stStartPoint.s32Y = IntToOven(ymin);
+    line->stEndPoint.s32X = IntToOven(xmax);
+    line->stEndPoint.s32Y = IntToOven(ymax);
+    line->u32Color = color;
+    line->u32Thick = thick;
+
+    return VgsDrawLines(frm, lines, HI_ARRAY_SIZE(lines));
+}
+
diff -urpBN hiopenais/src/mpp_help/vgs_img.h hiopenais_modify/src/mpp_help/vgs_img.h
--- hiopenais/src/mpp_help/vgs_img.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/mpp_help/vgs_img.h	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,127 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef VGS_HELP_H
+#define VGS_HELP_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "hi_common.h"
+#include "hi_comm_video.h"
+#include "hi_comm_venc.h"
+#include "hi_ext_util.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*************************************************************************************************
+    MPP frame处理helper.
+
+    主要基于VGS API实现，提供更大粒度的helper API，以简化使用。
+    最常用的操作时frame resize, draw rect. APP均只需要一次函数调用即可完成.
+*************************************************************************************************/
+#ifndef API_DESC_PAD
+#define API_DESC_PAD
+#endif
+
+/**
+    创建一个空的frame buf.
+
+    它根据参数只是的规格计算frame所需空间，为frame分配内存.
+
+    @param frm[in|out]: 若成功，创建的frame信息会复制到frm.
+    @param width[in]: frame width.
+    @param height[in]: frame height.
+    @param pixelFormat[in]: 置为-1表示取默认值PIXEL_FORMAT_YVU_SEMIPLANAR_420.
+    @param bitWidth[in]: 置为-1表示取默认值DATA_BITWIDTH_8.
+    @param compressMode[in]: 置为-1表示取默认值COMPRESS_MODE_NONE.
+    @param align[in]: 对齐的字节长度. 置为-1表示取默认值'自动对齐'.
+*/
+int MppFrmCreate(
+    VIDEO_FRAME_INFO_S* frm,
+    int width, int height,
+    PIXEL_FORMAT_E pixelFormat,
+    DATA_BITWIDTH_E bitWidth,
+    COMPRESS_MODE_E compressMode,
+    int align);
+
+/**
+    销毁frame.
+
+    目前仅用于销毁MPP helper API创建并返回的frame. 如MppFrmCreate()创建的frame,
+    MppFrmResize()通过@param dstFrm输出的frame.
+*/
+void MppFrmDestroy(VIDEO_FRAME_INFO_S* frm);
+
+/**
+    判断frame是否可用. 即是否分配了内存.
+*/
+bool MppFrmValid(const VIDEO_FRAME_INFO_S* frm);
+
+/**
+    resize frame.
+
+    支持任意倍数的缩放.
+    此函数会为dst分配空间来存储缩放后的图像.
+    user负责调用MppFrmDestroy()销毁@param dst返回的frame.
+
+    @param src[in]: 待缩放的原始frame.
+    @param dst[out]: 保存缩放后的frame的buf.
+    @param dstWidth[in]: 需要的缩放width.
+    @param dstHeight[in]: 需要的缩放height.
+*/
+int MppFrmResize(
+    const VIDEO_FRAME_INFO_S* src,
+    VIDEO_FRAME_INFO_S* dst,
+    uint32_t dstWidth, uint32_t dstHeight);
+
+/**
+    在frame中叠加矩形框.
+
+    MppFrmDrawRect()可以叠加一个矩形框.
+    MppFrmDrawRects()可以叠加一个或多个矩形框.
+
+    @param frm[in|out]: 待画框的frame. 叠加的图形也保存在该frame中.
+    @param boxes[in]: 待叠加的矩形框信息数组.
+    @param boxesNum[in]: boxes数组的size, box的数量.
+    @param box[in]: 矩形框信息.
+    @param color[in]: 叠加的图形的颜色. 格式为RGB888.
+    @param thick[in]: 图形线条的像素数.
+*/
+int MppFrmDrawRects(VIDEO_FRAME_INFO_S *frm,
+    const RectBox *boxes, int boxesNum, uint32_t color, int thick);
+int MppFrmDrawRect(VIDEO_FRAME_INFO_S *frm,
+    const RectBox *box, uint32_t color, int thick);
+
+/**
+    在frame中叠加一个十字叉.
+
+    @param x: 中心点X坐标.
+    @param y: 中心点Y坐标.
+    @param width: 水平线条长度.
+    @param height: 垂直线条长度.
+    @param color[in]: 叠加的图形的颜色. 格式为RGB888.
+    @param thick[in]: 图形线条的像素数.
+*/
+int MppFrmDrawCross(VIDEO_FRAME_INFO_S *frm,
+    int x, int y, int width, int height, uint32_t color, int thick);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // VGS_HELP_H
diff -urpBN hiopenais/src/plug_demo/cat_classify/cat_classify.c hiopenais_modify/src/plug_demo/cat_classify/cat_classify.c
--- hiopenais/src/plug_demo/cat_classify/cat_classify.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/plug_demo/cat_classify/cat_classify.c	2021-07-21 02:26:26.656796255 -0700
@@ -0,0 +1,288 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+
+#include "sample_comm_nnie.h"
+#include "nnie_sample_plug.h"
+
+#include "hi_ext_util.h"
+#include "mpp_help.h"
+#include "ai_plug.h"
+#include "audio_test.h"
+
+#include "hisignalling.h"
+
+
+#define PLUG_UUID          "\"hi.cat_classify\""
+#define PLUG_DESC          "\"璇锛绫荤锛(cnn)\""     // UTF8 encode
+
+#define FRM_WIDTH          224
+#define FRM_HEIGHT         224
+// resnet_inst.wk轰寮婧妯″resnet18璁锛杩.caffemodel杞wk缁
+#define MODEL_FILE_CAT    "./plugs/catsVSdogs_inst.wk" // 寮婧妯″杞
+
+#define RET_NUM_MAX         4 		// 杩number澶ф扮trr
+#define SCORE_MAX           4096 	// 澶ф瀵瑰score
+#define THRESH_MIN          30 		// ュ姒(瓒杩姝ゅ煎杩缁app)
+
+#define TXT_BEGX           20
+#define TXT_BEGY           20
+#define FONT_WIDTH         32
+#define FONT_HEIGHT        40
+#define AUDIO_CASE_TWO     2
+#define AUDIO_SCORE        90 		// 缃淇″害琛缃
+#define AUDIO_FRAME        14 		// 姣15甯ц涓娆★琛缃
+
+static OsdSet* g_osdsCat = NULL;
+static HI_S32 g_osd0Cat = -1;
+static int g_num = 108;
+static int g_count = 0;
+static pthread_t g_thrdId = 0;
+static int g_supportAudio = 0;
+
+static int uart_fd ;
+
+static SkPair g_stmChn = {
+    .in = -1,
+    .out = -1
+};
+
+static void PlayAudio(const RecogNumInfo items)
+{
+	if (g_count < AUDIO_FRAME) {
+		g_count++;
+		return;
+	}
+
+	const RecogNumInfo *item = &items;
+	uint32_t score = item->score * 100 / 4096;
+	if ((score > AUDIO_SCORE) && (g_num != item->num)) {
+		g_num = item->num;
+		audio_test(AUDIO_CASE_TWO, g_num, -1);
+	}
+	g_count = 0;
+}
+
+
+static void* GetAudioFileName(void* arg)
+{
+	RecogNumInfo resBuf = {0};
+	int ret;
+
+	while(1) {
+		ret = FdReadMsg(g_stmChn.in, &resBuf, sizeof(RecogNumInfo));
+		if (ret == sizeof(RecogNumInfo)) {
+			PlayAudio(resBuf);
+		}
+	}
+}
+
+
+static const HI_CHAR CAT_CLASSIFY[] = "{"
+    "\"uuid\": " PLUG_UUID ","
+    "\"desc\": " PLUG_DESC ","
+    "\"frmWidth\": " HI_TO_STR(FRM_WIDTH) ","
+    "\"frmHeight\": " HI_TO_STR(FRM_HEIGHT) ","
+    "\"butt\": 0"
+"}";
+
+static const HI_CHAR* CatClassifyProf(void)
+{
+    return CAT_CLASSIFY;
+}
+
+static HI_S32 CatClassifyLoad(uintptr_t* model, OsdSet* osds)
+{
+    SAMPLE_SVP_NNIE_CFG_S *self = NULL;
+    HI_S32 ret;
+
+    g_osdsCat = osds;
+    HI_ASSERT(g_osdsCat);
+    g_osd0Cat = OsdsCreateRgn(g_osdsCat);
+    HI_ASSERT(g_osd0Cat >= 0);
+
+    ret = CnnCreate(&self, MODEL_FILE_CAT);
+    *model = ret < 0 ? 0 : (uintptr_t)self;
+
+	if (GetCfgBool("audio_player:support_audio", true)) {
+		ret = SkPairCreate(&g_stmChn);
+		HI_ASSERT(ret == 0);
+		if (pthread_create(&g_thrdId, NULL, GetAudioFileName, NULL) < 0) {
+			HI_ASSERT(0);
+		}
+		g_supportAudio = 1;
+	}
+
+    uart_fd =  uartOpenInit();//qi dong  UART
+    if (uart_fd < 0) {
+        LOGI("uart open failed");
+    } else {
+        LOGI("uart open successed\n");
+    }
+
+	return ret;
+}
+
+static HI_S32 CatClassifyUnload(uintptr_t model)
+{
+    CnnDestroy((SAMPLE_SVP_NNIE_CFG_S*)model);
+    OsdsClear(g_osdsCat);
+	if (g_supportAudio == 1) {
+		SkPairDestroy(&g_stmChn);
+		pthread_join(g_thrdId, NULL);
+	}
+
+    return HI_SUCCESS;
+}
+
+/**
+    灏璁＄缁涓resJson.
+*/
+HI_CHAR* CatClassifyToJson(const RecogNumInfo items[], HI_S32 itemNum)
+{
+    HI_S32 jsonSize = TINY_BUF_SIZE + itemNum * TINY_BUF_SIZE; // 姣涓itemsize涓TINY_BUF_SIZE
+    HI_CHAR *jsonBuf = (HI_CHAR*)malloc(jsonSize);
+    HI_ASSERT(jsonBuf);
+    HI_S32 offset = 0;
+
+    offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1, "[");
+    for (HI_S32 i = 0; i < itemNum; i++) {
+        const RecogNumInfo *item = &items[i];
+        uint32_t score = item->score * HI_PER_BASE / SCORE_MAX;
+        if (score < THRESH_MIN) {
+            break;
+        }
+
+        offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1,
+            "%s{ \"classify num\": %u, \"score\": %u }", (i == 0 ? "\n  " : ", "), (uint)item->num, (uint)score);
+        HI_ASSERT(offset < jsonSize);
+    }
+    offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1, "]");
+    HI_ASSERT(offset < jsonSize);
+    return jsonBuf;
+}
+
+/**
+    灏璁＄缁涓OSD剧ず瀹.
+*/
+static HI_S32 CatClassifyToOsd(const RecogNumInfo items[], HI_S32 itemNum, HI_CHAR* buf, HI_S32 size)
+{
+    HI_S32 offset = 0;
+    HI_CHAR *cat_name = NULL;
+
+    offset += snprintf_s(buf + offset, size - offset, size - offset - 1, "cat classify: {");
+    for (HI_S32 i = 0; i < itemNum; i++) {
+        const RecogNumInfo *item = &items[i];
+        uint32_t score = item->score * HI_PER_BASE / SCORE_MAX;
+        if (score < THRESH_MIN) {
+            break;
+        }
+        switch (item->num) {
+            case 0u:
+                cat_name = "Cat";
+                usbUartSendRead(uart_fd, CAT);
+                usleep(100*1000);
+                break;
+            case 1u:
+                cat_name = "Dog";
+                usbUartSendRead(uart_fd, DOG);
+                usleep(100*1000);
+                break;
+            default:
+                cat_name = "Background";
+                break;
+        }
+
+        offset += snprintf_s(buf + offset, size - offset, size - offset - 1,
+            "%s%s %u:%u%%", (i == 0 ? " " : ", "), cat_name, (int)item->num, (int)score);
+        HI_ASSERT(offset < size);
+    }
+    offset += snprintf_s(buf + offset, size - offset, size - offset - 1, " }");
+    HI_ASSERT(offset < size);
+    return offset;
+}
+
+static HI_S32 CatClassifyCal(uintptr_t model,
+    VIDEO_FRAME_INFO_S *srcFrm, VIDEO_FRAME_INFO_S *resFrm, HI_CHAR** resJson)
+{
+    SAMPLE_SVP_NNIE_CFG_S *self = (SAMPLE_SVP_NNIE_CFG_S*)model; // reference to SDK sample_comm_nnie.h Line 99
+    IVE_IMAGE_S img; // referece to SDK hi_comm_ive.h Line 143
+    static HI_CHAR prevOsd[NORM_BUF_SIZE] = ""; // 瀹锛浠舵舵绾瀹跺浼涓涓绾跨璁块浠
+    HI_CHAR osdBuf[NORM_BUF_SIZE] = "";
+    /*
+        01-Kitchen_Watermelon_rind    02_Kitchen_Egg_shell
+        03_Kitchen_Fishbone           04_Kitchen_Eggplant
+        05_Kitchen_Scallion           06_Kitchen_Mushromm
+        07_Hazardous_Waste_battery    08_Hazardous_Expired_cosmetrics
+        09_Hazardous_Woundplast       10_Hazardous_Medical_gauze
+        11_Recyclabel_Old_dolls       12_Recyclabel_Old_clip
+        13_Recyclabel_Toothbrush      14_Recyclabel_Milk_box
+        15_Recyclabel_Old_handbag     16_Recyclabel_Zip_top_can
+        17_other_Ciggrate_end         18_Other_Bad_closestool
+        19_other_Brick                20_Other_Dish
+    */
+    RecogNumInfo resBuf[RET_NUM_MAX] = {0};
+    HI_S32 reslen = 0;
+    HI_S32 ret;
+
+    ret = FrmToOrigImg((VIDEO_FRAME_INFO_S*)srcFrm, &img);
+    HI_EXP_RET(ret != HI_SUCCESS, ret, "CatClassifyCal FAIL, for YUV2RGB FAIL, ret=%#x\n", ret);
+
+    ret = CnnCalU8c1Img(self, &img, resBuf, HI_ARRAY_SIZE(resBuf), &reslen); // 娌跨ㄨユㄧ昏
+    HI_EXP_LOGE(ret < 0, "cnn cal FAIL, ret=%d\n", ret);
+    HI_ASSERT(reslen <= sizeof(resBuf) / sizeof(resBuf[0]));
+
+    // resJsonresOsd
+    HI_CHAR *jsonBuf = CatClassifyToJson(resBuf, reslen);
+    *resJson = jsonBuf;
+    CatClassifyToOsd(resBuf, reslen, osdBuf, sizeof(osdBuf));
+	if (g_supportAudio == 1) {
+		if (FdWriteMsg(g_stmChn.out, &resBuf[0], sizeof(RecogNumInfo)) != sizeof(RecogNumInfo)) {
+			LOGE("FdWriteMsg FAIL\n");
+		}
+	}
+
+    // 浠褰resJson涓姝ゅ璁＄,版OSD杈烘瀛
+    if (strcmp(osdBuf, prevOsd) != 0) {
+        HiStrxfrm(prevOsd, osdBuf, sizeof(prevOsd));
+
+        // 惧舰resFrm涓
+        HI_OSD_ATTR_S rgn;
+        TxtRgnInit(&rgn, osdBuf, TXT_BEGX, TXT_BEGY, ARGB1555_YELLOW2, FONT_WIDTH, FONT_HEIGHT);
+        OsdsSetRgn(g_osdsCat, g_osd0Cat, &rgn);
+        LOGI("CNN cat classify: %s\n", osdBuf);
+    }
+    return ret;
+}
+
+static const AiPlug G_CAT_CLASSIFY_ITF = {
+    .Prof = CatClassifyProf,
+    .Load = CatClassifyLoad,
+    .Unload = CatClassifyUnload,
+    .Cal = CatClassifyCal,
+};
+
+const AiPlug* AiPlugItf(uint32_t* magic)
+{
+    if (magic) {
+        *magic = AI_PLUG_MAGIC;
+    }
+
+    return (AiPlug*)&G_CAT_CLASSIFY_ITF;
+}
diff -urpBN hiopenais/src/plug_demo/cnn_gender_classify/cnn_gender_classify.c hiopenais_modify/src/plug_demo/cnn_gender_classify/cnn_gender_classify.c
--- hiopenais/src/plug_demo/cnn_gender_classify/cnn_gender_classify.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/plug_demo/cnn_gender_classify/cnn_gender_classify.c	2021-07-03 03:47:18.000000000 -0700
@@ -0,0 +1,238 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+
+#include "sample_comm_nnie.h"
+#include "nnie_sample_plug.h"
+#include "sample_nnie_main.h"
+#include "rfcn_face_detect.h"  // 浜鸿告娴澶存浠
+
+#include "hi_ext_util.h"
+#include "mpp_help.h"
+#include "ai_plug.h"
+
+#define PLUG_UUID          "\"hi.cnn_gender_classify\""
+#define PLUG_DESC          "\"у绫(cnn)\""     // UTF8 encode
+
+#define FRM_WIDTH           640 // 杈ュ颁汉告娴妯″杈ㄧ涓瀹瑕 640*360
+#define FRM_HEIGHT          360
+
+#define MODEL_FILE_GENDER    "./plugs/face_gender_resnet.wk" // 寮婧妯″杞
+#define CLASS_NUM            3  // 妯″杈虹绫绘
+
+#define RET_NUM_MAX          4 		// 杩number澶ф扮trr
+#define SCORE_MAX            4096 	// 澶ф瀵瑰score
+#define GENDER_MIN           30 		// ュ姒(瓒杩姝ゅ煎杩缁app)
+#define DETECT_OBJ_MAX		 16      // 涓甯у惧涓妫娴澶ф扮
+#define IMAGE_WIDTH		     224 		// 版у绫荤妯″IMAGE杈ㄧ256*256
+#define IMAGE_HEIGHT	     224
+#define OSD_FONT_WIDTH		 16
+#define OSD_FONT_HEIGHT		 24
+#define DRAW_RETC_THICK		 2 		// 缁跺惧舰绾挎″藉害
+#define EXPANDRATE           10      // 浜鸿告娴妗╁ぇ姣渚
+#define WIDTH_LIMIT        	 32		// VGS 32*32浠ヤ杈ㄧ
+#define HEIGHT_LIMIT       	 32
+
+static OsdSet* g_osdsGender = NULL;
+
+static const HI_CHAR CNN_GENDER_CLASSIFY[] = "{"
+    "\"uuid\": " PLUG_UUID ","
+    "\"desc\": " PLUG_DESC ","
+    "\"frmWidth\": " HI_TO_STR(FRM_WIDTH) ","
+    "\"frmHeight\": " HI_TO_STR(FRM_HEIGHT) ","
+    "\"butt\": 0"
+"}";
+
+static const HI_CHAR* CnnGenderClassifyProf(void)
+{
+    return CNN_GENDER_CLASSIFY;
+}
+
+static HI_S32 CnnGenderClassifyLoad(uintptr_t* model, OsdSet* osds)
+{
+    SAMPLE_SVP_NNIE_CFG_S *self = NULL;
+    HI_S32 ret;
+
+    g_osdsGender = osds;
+	g_rfcnCfg.classNum = CLASS_NUM;
+    ret = CnnCreate(&self, MODEL_FILE_GENDER);
+    *model = ret < 0 ? 0 : (uintptr_t)self;
+
+	FaceDetectInit(); // 濮浜鸿告娴妯″
+	
+	return ret;
+}
+
+static HI_S32 CnnGenderClassifyUnload(uintptr_t model)
+{
+    CnnDestroy((SAMPLE_SVP_NNIE_CFG_S*)model);
+
+	if (g_osdsGender) {
+		OsdsClear(g_osdsGender);
+		g_osdsGender = NULL;
+	}
+	FaceDetectExit(); // 诲濮浜鸿告娴妯″
+	
+    return HI_SUCCESS;
+}
+
+/**
+    灏璁＄缁涓resJson.
+*/
+HI_CHAR* CnnGenderClassifyToJson(const RecogNumInfo items[], HI_S32 itemNum)
+{
+    HI_S32 jsonSize = TINY_BUF_SIZE + itemNum * TINY_BUF_SIZE; // 姣涓itemsize涓TINY_BUF_SIZE
+    HI_CHAR *jsonBuf = (HI_CHAR*)malloc(jsonSize);
+    HI_ASSERT(jsonBuf);
+    HI_S32 offset = 0;
+
+    offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1, "[");
+    for (HI_S32 i = 0; i < itemNum; i++) {
+        const RecogNumInfo *item = &items[i];
+        uint32_t score = item->score * HI_PER_BASE / SCORE_MAX;
+        if (score < GENDER_MIN) {
+            break;
+        }
+
+        offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1,
+            "%s{ \"classify num\": %u, \"score\": %u }", (i == 0 ? "\n  " : ", "), (uint)item->num, (uint)score);
+        HI_ASSERT(offset < jsonSize);
+    }
+    offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1, "]");
+    HI_ASSERT(offset < jsonSize);
+    return jsonBuf;
+}
+
+/**
+    娣诲у淇℃扮╁舰妗
+*/
+static void FaceDetectAddTxt(const RectBox box, const RecogNumInfo resBuf, uint32_t color)
+{
+	HI_OSD_ATTR_S osdRgn;
+	char osdTxt[TINY_BUF_SIZE];
+	HI_CHAR *gender_name = NULL;
+	HI_ASSERT(g_osdsGender);
+	if (resBuf.num == 0u) {
+		gender_name = "male";
+	} else if (resBuf.num == 1u) {
+		gender_name = "female";
+	} else {
+		gender_name = "unknow";
+	}
+	
+	uint32_t score = (resBuf.score) * HI_PER_BASE / SCORE_MAX;
+	int res = snprintf_s(osdTxt, sizeof(osdTxt), sizeof(osdTxt) - 1, "%d_%s,%d %%", resBuf.num, gender_name, score);
+	HI_ASSERT(res > 0);
+	
+	int osdId = OsdsCreateRgn(g_osdsGender);
+	HI_ASSERT(osdId >= 0);
+	
+	int x = box.xmin / HI_OVEN_BASE * HI_OVEN_BASE;
+	int y = (box.ymin - 30) / HI_OVEN_BASE * HI_OVEN_BASE;
+	if (y < 0) {
+		LOGD("osd_y < 0, y=%d\n", y);
+		OsdsDestroyRgn(g_osdsGender, osdId);
+	} else {
+		TxtRgnInit(&osdRgn, osdTxt, x, y, color, OSD_FONT_WIDTH, OSD_FONT_HEIGHT);
+		OsdsSetRgn(g_osdsGender, osdId, &osdRgn);
+	}
+}
+
+static HI_S32 CnnGenderClassifyCal(uintptr_t model,
+    VIDEO_FRAME_INFO_S *srcFrm, VIDEO_FRAME_INFO_S *resFrm, HI_CHAR** resJson)
+{
+    SAMPLE_SVP_NNIE_CFG_S *self = (SAMPLE_SVP_NNIE_CFG_S*)model;
+	IVE_IMAGE_S img;
+	DetectObjInfo resBuf[DETECT_OBJ_MAX] = {0};
+	RectBox boxs[DETECT_OBJ_MAX] = {0};
+	RectBox cnnBoxs[DETECT_OBJ_MAX] = {0}; // 涓洪版у绫绘āBox,浜鸿哥浣缃
+    RecogNumInfo numInfo[RET_NUM_MAX] = {0};
+	int detectNum = 0;
+	HI_S32 resLen = 0;
+	HI_S32 ret;
+	IVE_IMAGE_S imgIn;
+	IVE_IMAGE_S imgDst;
+	VIDEO_FRAME_INFO_S frmIn;
+	VIDEO_FRAME_INFO_S frmDst;
+
+	OsdsClear(g_osdsGender);
+	
+	ret = FrmToOrigImg(srcFrm, &img);
+	HI_EXP_RET(ret < 0, ret, "CnnGenderClassifyCal FAIL, for frm_to_img FAIL\n");
+	// 灏img颁汉告娴妯″杩琛妫娴锛detectNum涓轰img涓妫娴烘ョ浜鸿哥扮锛 resBuf瀵瑰姣寮浜鸿哥浣缃
+	detectNum = FaceDetectCal(&img, resBuf);
+	
+	for (int i = 0; i < detectNum; i++) {
+		cnnBoxs[i] = resBuf[i].box;
+		ret = ImgYuvCrop(&img, &imgIn, &cnnBoxs[i]); // 灏浜鸿告ㄧ浣缃crop烘ワ淇瀛板涓涓IVE_IMAGE_S涓
+		HI_EXP_LOGE(ret < 0, "ImgYuvCrop FAIL, ret = %d\n", ret);
+		
+		if((imgIn.u32Width >= WIDTH_LIMIT) && (imgIn.u32Height >= HEIGHT_LIMIT)) {
+			COMPRESS_MODE_E enCompressMode = srcFrm->stVFrame.enCompressMode;
+			ret = OrigImgToFrm(&imgIn, &frmIn);
+			frmIn.stVFrame.enCompressMode = enCompressMode;
+			ret = MppFrmResize(&frmIn, &frmDst, IMAGE_WIDTH, IMAGE_HEIGHT);
+			ret = FrmToOrigImg(&frmDst, &imgDst);
+			
+			ret = CnnCalU8c1Img(self,  &imgDst, numInfo, HI_ARRAY_SIZE(numInfo), &resLen);
+			HI_EXP_LOGE(ret < 0, "CnnCalU8c1Img FAIL, ret = %d\n", ret);
+			HI_ASSERT(resLen <= sizeof(numInfo) / sizeof(numInfo[0]));
+			RectBoxTran(&cnnBoxs[i], FRM_WIDTH, FRM_HEIGHT,
+						resFrm->stVFrame.u32Width, resFrm->stVFrame.u32Height);
+			FaceDetectAddTxt(cnnBoxs[i], numInfo[0], ARGB1555_WHITE); 
+			
+			MppFrmDestroy(&frmDst);
+		}
+		
+		RectBox *box = &resBuf[i].box;
+		RectBoxTran(box, FRM_WIDTH, FRM_HEIGHT,
+					resFrm->stVFrame.u32Width, resFrm->stVFrame.u32Height);
+		LOGD("FaceDetect: {%d, %d, %d, %d}, objNum = %d\n",
+			box->xmin, box->ymin, box->xmax, box->ymax, detectNum);
+		boxs[i] = *box;
+		
+		IveImgDestroy(&imgIn);
+	}
+	
+	if (detectNum > 0) {
+		MppFrmDrawRects(resFrm, boxs, detectNum, RGB888_RED, DRAW_RETC_THICK);
+	}
+	
+	// resJson
+	HI_CHAR *jsonBuf = CnnGenderClassifyToJson(numInfo, resLen);
+	*resJson = jsonBuf;
+	
+    return ret;
+}
+
+static const AiPlug G_CNN_GENDER_CLASSIFY_ITF = {
+    .Prof = CnnGenderClassifyProf,
+    .Load = CnnGenderClassifyLoad,
+    .Unload = CnnGenderClassifyUnload,
+    .Cal = CnnGenderClassifyCal,
+};
+
+const AiPlug* AiPlugItf(uint32_t* magic)
+{
+    if (magic) {
+        *magic = AI_PLUG_MAGIC;
+    }
+
+    return (AiPlug*)&G_CNN_GENDER_CLASSIFY_ITF;
+}
diff -urpBN hiopenais/src/plug_demo/cnn_hand_gesture/cnn_hand_gesture.c hiopenais_modify/src/plug_demo/cnn_hand_gesture/cnn_hand_gesture.c
--- hiopenais/src/plug_demo/cnn_hand_gesture/cnn_hand_gesture.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/plug_demo/cnn_hand_gesture/cnn_hand_gesture.c	2021-07-01 00:46:42.000000000 -0700
@@ -0,0 +1,205 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+
+#include "sample_comm_nnie.h"
+#include "nnie_sample_plug.h"
+
+#include "hi_ext_util.h"
+#include "mpp_help.h"
+#include "ai_plug.h"
+
+#define PLUG_UUID          "\"hi.cnn_hand_gesture\""
+#define PLUG_DESC          "\"胯(cnn)\""     // UTF8 encode
+
+#define FRM_WIDTH          224
+#define FRM_HEIGHT         224
+// resnet_inst.wk轰寮婧妯″resnet18璁锛杩.caffemodel杞wk缁
+#define MODEL_FILE_GESTURE    "./plugs/hand_gesture.wk" // 寮婧妯″杞
+
+#define RET_NUM_MAX         4       // 杩number澶ф扮trr
+#define SCORE_MAX           4096    // 澶ф瀵瑰score
+#define THRESH_MIN          30      // ュ姒(瓒杩姝ゅ煎杩缁app)
+
+#define TXT_BEGX           20
+#define TXT_BEGY           20
+#define FONT_WIDTH         32
+#define FONT_HEIGHT        40
+
+static OsdSet* g_osdsGesture = NULL;
+static HI_S32 g_osd0Gesture = -1;
+
+static const HI_CHAR CNN_HAND_GESTURE[] = "{"
+    "\"uuid\": " PLUG_UUID ","
+    "\"desc\": " PLUG_DESC ","
+    "\"frmWidth\": " HI_TO_STR(FRM_WIDTH) ","
+    "\"frmHeight\": " HI_TO_STR(FRM_HEIGHT) ","
+    "\"butt\": 0"
+"}";
+
+static const HI_CHAR* CnnHandGestureProf(void)
+{
+    return CNN_HAND_GESTURE;
+}
+
+static HI_S32 CnnHandGestureLoad(uintptr_t* model, OsdSet* osds)
+{
+    SAMPLE_SVP_NNIE_CFG_S *self = NULL;
+    HI_S32 ret;
+
+    g_osdsGesture = osds;
+    HI_ASSERT(g_osdsGesture);
+    g_osd0Gesture = OsdsCreateRgn(g_osdsGesture);
+    HI_ASSERT(g_osd0Gesture >= 0);
+
+    ret = CnnCreate(&self, MODEL_FILE_GESTURE);
+    *model = ret < 0 ? 0 : (uintptr_t)self;
+
+    return ret;
+}
+
+static HI_S32 CnnHandGestureUnload(uintptr_t model)
+{
+    CnnDestroy((SAMPLE_SVP_NNIE_CFG_S*)model);
+    OsdsClear(g_osdsGesture);
+
+    return HI_SUCCESS;
+}
+
+/**
+    灏璁＄缁涓resJson.
+*/
+HI_CHAR* CnnHandGestureToJson(const RecogNumInfo items[], HI_S32 itemNum)
+{
+    HI_S32 jsonSize = TINY_BUF_SIZE + itemNum * TINY_BUF_SIZE; // 姣涓itemsize涓TINY_BUF_SIZE
+    HI_CHAR *jsonBuf = (HI_CHAR*)malloc(jsonSize);
+    HI_ASSERT(jsonBuf);
+    HI_S32 offset = 0;
+
+    offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1, "[");
+    for (HI_S32 i = 0; i < itemNum; i++) {
+        const RecogNumInfo *item = &items[i];
+        uint32_t score = item->score * HI_PER_BASE / SCORE_MAX;
+        if (score < THRESH_MIN) {
+            break;
+        }
+
+        offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1,
+            "%s{ \"classify num\": %u, \"score\": %u }", (i == 0 ? "\n  " : ", "), (uint)item->num, (uint)score);
+        HI_ASSERT(offset < jsonSize);
+    }
+    offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1, "]");
+    HI_ASSERT(offset < jsonSize);
+    return jsonBuf;
+}
+
+/**
+    灏璁＄缁涓OSD剧ず瀹.
+*/
+static HI_S32 CnnHandGestureToOsd(const RecogNumInfo items[], HI_S32 itemNum, HI_CHAR* buf, HI_S32 size)
+{
+    HI_S32 offset = 0;
+    HI_CHAR *gesture_name = NULL;
+
+    offset += snprintf_s(buf + offset, size - offset, size - offset - 1, "hand gesture: {");
+    for (HI_S32 i = 0; i < itemNum; i++) {
+        const RecogNumInfo *item = &items[i];
+        uint32_t score = item->score * HI_PER_BASE / SCORE_MAX;
+        if (score < THRESH_MIN) {
+            break;
+        }
+        switch (item->num) {
+            case 0u:
+                gesture_name = "gesture palm";
+                break;
+            case 1u:
+                gesture_name = "gesture first";
+                break;
+            case 2u:
+                gesture_name = "gesture others";
+                break;
+            default:
+                gesture_name = "Unkown";
+                break;
+        }
+
+        offset += snprintf_s(buf + offset, size - offset, size - offset - 1,
+            "%s%s %u:%u%%", (i == 0 ? " " : ", "), gesture_name, (int)item->num, (int)score);
+        HI_ASSERT(offset < size);
+    }
+    offset += snprintf_s(buf + offset, size - offset, size - offset - 1, " }");
+    HI_ASSERT(offset < size);
+    return offset;
+}
+
+static HI_S32 CnnHandGestureCal(uintptr_t model,
+    VIDEO_FRAME_INFO_S *srcFrm, VIDEO_FRAME_INFO_S *resFrm, HI_CHAR** resJson)
+{
+    SAMPLE_SVP_NNIE_CFG_S *self = (SAMPLE_SVP_NNIE_CFG_S*)model; // reference to SDK sample_comm_nnie.h Line 99
+    IVE_IMAGE_S img; // referece to SDK hi_comm_ive.h Line 143
+    static HI_CHAR prevOsd[NORM_BUF_SIZE] = ""; // 瀹锛浠舵舵绾瀹跺浼涓涓绾跨璁块浠
+    HI_CHAR osdBuf[NORM_BUF_SIZE] = "";
+    /*
+        01-palm          02_first
+        03_others
+    */
+    RecogNumInfo resBuf[RET_NUM_MAX] = {0};
+    HI_S32 reslen = 0;
+    HI_S32 ret;
+
+    ret = FrmToOrigImg((VIDEO_FRAME_INFO_S*)srcFrm, &img);
+    HI_EXP_RET(ret != HI_SUCCESS, ret, "CnnTrashClassifyCal FAIL, for YUV2RGB FAIL, ret=%#x\n", ret);
+
+    ret = CnnCalU8c1Img(self, &img, resBuf, HI_ARRAY_SIZE(resBuf), &reslen); // 娌跨ㄨユㄧ昏
+    HI_EXP_LOGE(ret < 0, "cnn cal FAIL, ret=%d\n", ret);
+    HI_ASSERT(reslen <= sizeof(resBuf) / sizeof(resBuf[0]));
+
+    // resJsonresOsd
+    HI_CHAR *jsonBuf = CnnHandGestureToJson(resBuf, reslen);
+    *resJson = jsonBuf;
+    CnnHandGestureToOsd(resBuf, reslen, osdBuf, sizeof(osdBuf));
+
+    // 浠褰resJson涓姝ゅ璁＄,版OSD杈烘瀛
+    if (strcmp(osdBuf, prevOsd) != 0) {
+        HiStrxfrm(prevOsd, osdBuf, sizeof(prevOsd));
+
+        // 惧舰resFrm涓
+        HI_OSD_ATTR_S rgn;
+        TxtRgnInit(&rgn, osdBuf, TXT_BEGX, TXT_BEGY, ARGB1555_YELLOW2, FONT_WIDTH, FONT_HEIGHT);
+        OsdsSetRgn(g_osdsGesture, g_osd0Gesture, &rgn);
+        LOGI("CNN hand gesture: %s\n", osdBuf);
+    }
+    return ret;
+}
+
+static const AiPlug G_HAND_GESTURE_ITF = {
+    .Prof = CnnHandGestureProf,
+    .Load = CnnHandGestureLoad,
+    .Unload = CnnHandGestureUnload,
+    .Cal = CnnHandGestureCal,
+};
+
+const AiPlug* AiPlugItf(uint32_t* magic)
+{
+    if (magic) {
+        *magic = AI_PLUG_MAGIC;
+    }
+
+    return (AiPlug*)&G_HAND_GESTURE_ITF;
+}
diff -urpBN hiopenais/src/plug_demo/cnn_mnist/cnn_mnist.c hiopenais_modify/src/plug_demo/cnn_mnist/cnn_mnist.c
--- hiopenais/src/plug_demo/cnn_mnist/cnn_mnist.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/plug_demo/cnn_mnist/cnn_mnist.c	2021-03-26 18:55:39.000000000 -0700
@@ -0,0 +1,183 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+
+#include "sample_comm_nnie.h"
+#include "nnie_sample_plug.h"
+
+#include "hi_ext_util.h"
+#include "mpp_help.h"
+#include "ai_plug.h"
+
+#define PLUG_UUID           "\"hi.cnn_mnist\""
+#define PLUG_DESC           "\"板璇(cnn)\"" // 数字识别UTF8
+
+#define FRM_WIDTH           28
+#define FRM_HEIGHT          28
+
+#define MODEL_FILE          "./plugs/hi.cnn_mnist.wk"
+#define TEST_FILES          "./nnie_data/nnie_image/y/0_28x28.y" // 目前没有使用
+
+#define SCORE_MAX           4096 // 最大概率对应的score
+#define THRESH_MIN          30 // 可接受的概率阈值(超过此值则返回给app)
+#define RET_NUM_MAX         4 // 返回number的最大数目
+
+#define TXT_BEGX            20
+#define TXT_BEGY            20
+#define FONT_WIDTH          32
+#define FONT_HEIGHT         40
+
+static OsdSet* g_osds = NULL; // 临时，应添加到plug对象中
+static int g_osd0 = -1;
+
+static const char CNN_MNIST_PROF[] = "{"
+    "\"uuid\": " PLUG_UUID ","
+    "\"desc\": " PLUG_DESC ","
+    "\"frmWidth\": " HI_TO_STR(FRM_WIDTH) ","
+    "\"frmHeight\": " HI_TO_STR(FRM_HEIGHT) ","
+    "\"butt\": 0"
+"}";
+
+static const char* CnnMnistProf(void)
+{
+    return CNN_MNIST_PROF;
+}
+
+static int CnnMnistLoad(uintptr_t* model, OsdSet* osds)
+{
+    SAMPLE_SVP_NNIE_CFG_S *self = NULL;
+    int ret;
+
+    g_osds = osds;
+    HI_ASSERT(g_osds);
+    g_osd0 = OsdsCreateRgn(g_osds);
+    HI_ASSERT(g_osd0 >= 0);
+
+    ret = CnnCreate(&self, MODEL_FILE);
+    *model = ret < 0 ? 0 : (uintptr_t)self;
+    return ret;
+}
+
+static int CnnMnistUnload(uintptr_t model)
+{
+    CnnDestroy((SAMPLE_SVP_NNIE_CFG_S*)model);
+    OsdsClear(g_osds);
+    return 0;
+}
+
+/**
+    将计算结果打包为resJson.
+*/
+char* CnnMnistToJson(const RecogNumInfo items[], int itemNum)
+{
+    int jsonSize = TINY_BUF_SIZE + itemNum * TINY_BUF_SIZE; // 每个item的打包size为TINY_BUF_SIZE
+    char *jsonBuf = (char*)malloc(jsonSize);
+    HI_ASSERT(jsonBuf);
+    int offset = 0;
+
+    offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1, "[");
+    for (int i = 0; i < itemNum; i++) {
+        const RecogNumInfo *item = &items[i];
+        uint32_t score = item->score * HI_PER_BASE / SCORE_MAX;
+        if (score < THRESH_MIN) {
+            break;
+        }
+
+        offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1,
+            "%s{ \"num\": %u, \"score\": %u }", (i == 0 ? "\n  " : ", "), (uint)item->num, (uint)score);
+        HI_ASSERT(offset < jsonSize);
+    }
+    offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1, "]");
+    HI_ASSERT(offset < jsonSize);
+    return jsonBuf;
+}
+
+/**
+    将计算结果打包为OSD显示内容.
+*/
+static int CnnMnistToOsd(const RecogNumInfo items[], int itemNum, char* buf, int size)
+{
+    int offset = 0;
+
+    offset += snprintf_s(buf + offset, size - offset, size - offset - 1, "mnist: {");
+    for (int i = 0; i < itemNum; i++) {
+        const RecogNumInfo *item = &items[i];
+        uint32_t score = item->score * HI_PER_BASE / SCORE_MAX;
+        if (score < THRESH_MIN) {
+            break;
+        }
+
+        offset += snprintf_s(buf + offset, size - offset, size - offset - 1,
+            "%s%u:%u%%", (i == 0 ? " " : ", "), (int)item->num, (int)score);
+        HI_ASSERT(offset < size);
+    }
+    offset += snprintf_s(buf + offset, size - offset, size - offset - 1, " }");
+    HI_ASSERT(offset < size);
+    return offset;
+}
+
+static int CnnMnistCal(uintptr_t model,
+    VIDEO_FRAME_INFO_S *srcFrm, VIDEO_FRAME_INFO_S *resFrm, char** resJson)
+{
+    SAMPLE_SVP_NNIE_CFG_S *self = (SAMPLE_SVP_NNIE_CFG_S*)model;
+    IVE_IMAGE_S img;
+    static char prevOsd[NORM_BUF_SIZE] = ""; // 安全，插件架构约定同时只会有一个线程访问插件
+    char osdBuf[NORM_BUF_SIZE] = "";
+    RecogNumInfo resBuf[RET_NUM_MAX] = {0};
+    int resLen = 0;
+    int ret;
+
+    FrmToU8c1Img(srcFrm, &img); // 转换为灰度图像，不会分配内存
+    ret = CnnCalU8c1Img(self, &img, resBuf, HI_ARRAY_SIZE(resBuf), &resLen);
+    HI_EXP_LOGE(ret < 0, "cnn cal FAIL, ret=%d\n", ret);
+    HI_ASSERT(resLen <= sizeof(resBuf) / sizeof(resBuf[0]));
+
+    // 生成resJson和resOsd
+    char *jsonBuf = CnnMnistToJson(resBuf, resLen);
+    *resJson = jsonBuf;
+    CnnMnistToOsd(resBuf, resLen, osdBuf, sizeof(osdBuf));
+
+    // 仅当resJson与此前计算发生变化时，才重新打OSD输出文字
+    if (strcmp(osdBuf, prevOsd) != 0) {
+        HiStrxfrm(prevOsd, osdBuf, sizeof(prevOsd));
+
+        // 叠加图形到resFrm中
+        HI_OSD_ATTR_S rgn;
+        TxtRgnInit(&rgn, osdBuf, TXT_BEGX, TXT_BEGY, ARGB1555_YELLOW2, FONT_WIDTH, FONT_HEIGHT);
+        OsdsSetRgn(g_osds, g_osd0, &rgn);
+        LOGD("CNN: %s\n", osdBuf);
+    }
+    return ret;
+}
+
+static const AiPlug G_CNN_MNIST_ITF = {
+    .Prof = CnnMnistProf,
+    .Load = CnnMnistLoad,
+    .Unload = CnnMnistUnload,
+    .Cal = CnnMnistCal,
+};
+
+const AiPlug* AiPlugItf(uint32_t* magic)
+{
+    if (magic) {
+        *magic = AI_PLUG_MAGIC;
+    }
+    return (AiPlug*)&G_CNN_MNIST_ITF;
+}
+
diff -urpBN hiopenais/src/plug_demo/cnn_trash_classify/cnn_trash_classify.c hiopenais_modify/src/plug_demo/cnn_trash_classify/cnn_trash_classify.c
--- hiopenais/src/plug_demo/cnn_trash_classify/cnn_trash_classify.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/plug_demo/cnn_trash_classify/cnn_trash_classify.c	2021-07-01 20:04:22.000000000 -0700
@@ -0,0 +1,292 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+
+#include "sample_comm_nnie.h"
+#include "nnie_sample_plug.h"
+
+#include "hi_ext_util.h"
+#include "mpp_help.h"
+#include "ai_plug.h"
+#include "audio_test.h"
+
+#define PLUG_UUID          "\"hi.cnn_trash_classify\""
+#define PLUG_DESC          "\"惧绫(cnn)\""     // UTF8 encode
+
+#define FRM_WIDTH          224
+#define FRM_HEIGHT         224
+// resnet_inst.wk轰寮婧妯″resnet18璁锛杩.caffemodel杞wk缁
+#define MODEL_FILE_TRASH    "./plugs/resnet_inst.wk" // 寮婧妯″杞
+
+#define RET_NUM_MAX         4 		// 杩number澶ф扮trr
+#define SCORE_MAX           4096 	// 澶ф瀵瑰score
+#define THRESH_MIN          30 		// ュ姒(瓒杩姝ゅ煎杩缁app)
+
+#define TXT_BEGX           20
+#define TXT_BEGY           20
+#define FONT_WIDTH         32
+#define FONT_HEIGHT        40
+#define AUDIO_CASE_TWO     2
+#define AUDIO_SCORE        90 		// 缃淇″害琛缃
+#define AUDIO_FRAME        14 		// 姣15甯ц涓娆★琛缃
+
+static OsdSet* g_osdsTrash = NULL;
+static HI_S32 g_osd0Trash = -1;
+static int g_num = 108;
+static int g_count = 0;
+static pthread_t g_thrdId = 0;
+static int g_supportAudio = 0;
+
+static SkPair g_stmChn = {
+    .in = -1,
+    .out = -1
+};
+
+static void PlayAudio(const RecogNumInfo items)
+{
+	if (g_count < AUDIO_FRAME) {
+		g_count++;
+		return;
+	}
+
+	const RecogNumInfo *item = &items;
+	uint32_t score = item->score * 100 / 4096;
+	if ((score > AUDIO_SCORE) && (g_num != item->num)) {
+		g_num = item->num;
+		audio_test(AUDIO_CASE_TWO, g_num, -1);
+	}
+	g_count = 0;
+}
+
+static void* GetAudioFileName(void* arg)
+{
+	RecogNumInfo resBuf = {0};
+	int ret;
+	
+	while(1) {
+		ret = FdReadMsg(g_stmChn.in, &resBuf, sizeof(RecogNumInfo));
+		if (ret == sizeof(RecogNumInfo)) {
+			PlayAudio(resBuf);
+		}
+	}
+}
+
+static const HI_CHAR CNN_TRASH_CLASSIFY[] = "{"
+    "\"uuid\": " PLUG_UUID ","
+    "\"desc\": " PLUG_DESC ","
+    "\"frmWidth\": " HI_TO_STR(FRM_WIDTH) ","
+    "\"frmHeight\": " HI_TO_STR(FRM_HEIGHT) ","
+    "\"butt\": 0"
+"}";
+
+static const HI_CHAR* CnnTrashClassifyProf(void)
+{
+    return CNN_TRASH_CLASSIFY;
+}
+
+static HI_S32 CnnTrashClassifyLoad(uintptr_t* model, OsdSet* osds)
+{
+    SAMPLE_SVP_NNIE_CFG_S *self = NULL;
+    HI_S32 ret;
+
+    g_osdsTrash = osds;
+    HI_ASSERT(g_osdsTrash);
+    g_osd0Trash = OsdsCreateRgn(g_osdsTrash);
+    HI_ASSERT(g_osd0Trash >= 0);
+
+    ret = CnnCreate(&self, MODEL_FILE_TRASH);
+    *model = ret < 0 ? 0 : (uintptr_t)self;
+
+	if (GetCfgBool("audio_player:support_audio", true)) {
+		ret = SkPairCreate(&g_stmChn);
+		HI_ASSERT(ret == 0);
+		if (pthread_create(&g_thrdId, NULL, GetAudioFileName, NULL) < 0) {
+			HI_ASSERT(0);
+		}
+		g_supportAudio = 1;
+	}
+	
+	return ret;
+}
+
+static HI_S32 CnnTrashClassifyUnload(uintptr_t model)
+{
+    CnnDestroy((SAMPLE_SVP_NNIE_CFG_S*)model);
+    OsdsClear(g_osdsTrash);
+	if (g_supportAudio == 1) {
+		SkPairDestroy(&g_stmChn);
+		pthread_join(g_thrdId, NULL);
+	}
+	
+    return HI_SUCCESS;
+}
+
+/**
+    灏璁＄缁涓resJson.
+*/
+HI_CHAR* CnnTrashClassifyToJson(const RecogNumInfo items[], HI_S32 itemNum)
+{
+    HI_S32 jsonSize = TINY_BUF_SIZE + itemNum * TINY_BUF_SIZE; // 姣涓itemsize涓TINY_BUF_SIZE
+    HI_CHAR *jsonBuf = (HI_CHAR*)malloc(jsonSize);
+    HI_ASSERT(jsonBuf);
+    HI_S32 offset = 0;
+
+    offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1, "[");
+    for (HI_S32 i = 0; i < itemNum; i++) {
+        const RecogNumInfo *item = &items[i];
+        uint32_t score = item->score * HI_PER_BASE / SCORE_MAX;
+        if (score < THRESH_MIN) {
+            break;
+        }
+
+        offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1,
+            "%s{ \"classify num\": %u, \"score\": %u }", (i == 0 ? "\n  " : ", "), (uint)item->num, (uint)score);
+        HI_ASSERT(offset < jsonSize);
+    }
+    offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1, "]");
+    HI_ASSERT(offset < jsonSize);
+    return jsonBuf;
+}
+
+/**
+    灏璁＄缁涓OSD剧ず瀹.
+*/
+static HI_S32 CnnTrashClassifyToOsd(const RecogNumInfo items[], HI_S32 itemNum, HI_CHAR* buf, HI_S32 size)
+{
+    HI_S32 offset = 0;
+    HI_CHAR *trash_name = NULL;
+
+    offset += snprintf_s(buf + offset, size - offset, size - offset - 1, "trash classify: {");
+    for (HI_S32 i = 0; i < itemNum; i++) {
+        const RecogNumInfo *item = &items[i];
+        uint32_t score = item->score * HI_PER_BASE / SCORE_MAX;
+        if (score < THRESH_MIN) {
+            break;
+        }
+        switch (item->num) {
+            case 0u:
+            case 1u:
+            case 2u:
+            case 3u:
+            case 4u:
+            case 5u:
+                trash_name = "Kitchen Waste";
+                break;
+            case 6u:
+            case 7u:
+            case 8u:
+            case 9u:
+                trash_name = "Harmful Waste";
+                break;
+            case 10u:
+            case 11u:
+            case 12u:
+            case 13u:
+            case 14u:
+            case 15u:
+                trash_name = "Recycle Waste";
+                break;
+            case 16u:
+            case 17u:
+            case 18u:
+            case 19u:
+                trash_name = "Other Waste";
+                break;
+            default:
+                trash_name = "Unkown Waste";
+                break;
+        }
+
+        offset += snprintf_s(buf + offset, size - offset, size - offset - 1,
+            "%s%s %u:%u%%", (i == 0 ? " " : ", "), trash_name, (int)item->num, (int)score);
+        HI_ASSERT(offset < size);
+    }
+    offset += snprintf_s(buf + offset, size - offset, size - offset - 1, " }");
+    HI_ASSERT(offset < size);
+    return offset;
+}
+
+static HI_S32 CnnTrashClassifyCal(uintptr_t model,
+    VIDEO_FRAME_INFO_S *srcFrm, VIDEO_FRAME_INFO_S *resFrm, HI_CHAR** resJson)
+{
+    SAMPLE_SVP_NNIE_CFG_S *self = (SAMPLE_SVP_NNIE_CFG_S*)model; // reference to SDK sample_comm_nnie.h Line 99
+    IVE_IMAGE_S img; // referece to SDK hi_comm_ive.h Line 143
+    static HI_CHAR prevOsd[NORM_BUF_SIZE] = ""; // 瀹锛浠舵舵绾瀹跺浼涓涓绾跨璁块浠
+    HI_CHAR osdBuf[NORM_BUF_SIZE] = "";
+    /*
+        01-Kitchen_Watermelon_rind    02_Kitchen_Egg_shell
+        03_Kitchen_Fishbone           04_Kitchen_Eggplant
+        05_Kitchen_Scallion           06_Kitchen_Mushromm
+        07_Hazardous_Waste_battery    08_Hazardous_Expired_cosmetrics
+        09_Hazardous_Woundplast       10_Hazardous_Medical_gauze
+        11_Recyclabel_Old_dolls       12_Recyclabel_Old_clip
+        13_Recyclabel_Toothbrush      14_Recyclabel_Milk_box
+        15_Recyclabel_Old_handbag     16_Recyclabel_Zip_top_can
+        17_other_Ciggrate_end         18_Other_Bad_closestool
+        19_other_Brick                20_Other_Dish
+    */
+    RecogNumInfo resBuf[RET_NUM_MAX] = {0};
+    HI_S32 reslen = 0;
+    HI_S32 ret;
+
+    ret = FrmToOrigImg((VIDEO_FRAME_INFO_S*)srcFrm, &img);
+    HI_EXP_RET(ret != HI_SUCCESS, ret, "CnnTrashClassifyCal FAIL, for YUV2RGB FAIL, ret=%#x\n", ret);
+
+    ret = CnnCalU8c1Img(self, &img, resBuf, HI_ARRAY_SIZE(resBuf), &reslen); // 娌跨ㄨユㄧ昏
+    HI_EXP_LOGE(ret < 0, "cnn cal FAIL, ret=%d\n", ret);
+    HI_ASSERT(reslen <= sizeof(resBuf) / sizeof(resBuf[0]));
+
+    // resJsonresOsd
+    HI_CHAR *jsonBuf = CnnTrashClassifyToJson(resBuf, reslen);
+    *resJson = jsonBuf;
+    CnnTrashClassifyToOsd(resBuf, reslen, osdBuf, sizeof(osdBuf));
+	if (g_supportAudio == 1) {
+		if (FdWriteMsg(g_stmChn.out, &resBuf[0], sizeof(RecogNumInfo)) != sizeof(RecogNumInfo)) {
+			LOGE("FdWriteMsg FAIL\n"); 
+		}
+	}
+	
+    // 浠褰resJson涓姝ゅ璁＄,版OSD杈烘瀛
+    if (strcmp(osdBuf, prevOsd) != 0) {
+        HiStrxfrm(prevOsd, osdBuf, sizeof(prevOsd));
+
+        // 惧舰resFrm涓
+        HI_OSD_ATTR_S rgn;
+        TxtRgnInit(&rgn, osdBuf, TXT_BEGX, TXT_BEGY, ARGB1555_YELLOW2, FONT_WIDTH, FONT_HEIGHT);
+        OsdsSetRgn(g_osdsTrash, g_osd0Trash, &rgn);
+        LOGI("CNN trash classify: %s\n", osdBuf);
+    }
+    return ret;
+}
+
+static const AiPlug G_CNN_TRASH_CLASSIFY_ITF = {
+    .Prof = CnnTrashClassifyProf,
+    .Load = CnnTrashClassifyLoad,
+    .Unload = CnnTrashClassifyUnload,
+    .Cal = CnnTrashClassifyCal,
+};
+
+const AiPlug* AiPlugItf(uint32_t* magic)
+{
+    if (magic) {
+        *magic = AI_PLUG_MAGIC;
+    }
+
+    return (AiPlug*)&G_CNN_TRASH_CLASSIFY_ITF;
+}
diff -urpBN hiopenais/src/plug_demo/hand_classify/hand_classify.c hiopenais_modify/src/plug_demo/hand_classify/hand_classify.c
--- hiopenais/src/plug_demo/hand_classify/hand_classify.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/plug_demo/hand_classify/hand_classify.c	2021-11-10 23:47:46.696287022 -0800
@@ -0,0 +1,447 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+
+#include "sample_comm_nnie.h"
+#include "nnie_sample_plug.h"
+#include "yolov2_hand_detect.h"
+
+#include "hi_ext_util.h"
+#include "mpp_help.h"
+#include "ai_plug.h"
+#include "ive_img.h"
+#include "audio_test.h"
+
+#include "hisignalling.h"
+
+#define PLUG_UUID          "\"hi.hand_classify\""
+#define PLUG_DESC          "\"妫娴绫(darknet+resnet)\""     // UTF8 encode
+
+#define FRM_WIDTH          640
+#define FRM_HEIGHT         384
+#define MODEL_FILE_GESTURE    "./plugs/classify.wk" // darknet framework wk model
+
+#define RET_NUM_MAX        4
+#define SCORE_MAX          4096
+#define THRESH_MIN         0.25
+#define DETECT_OBJ_MAX     32
+#define PIRIOD_NUM_MAX     49   // Logs are printed when the number of targets is detected
+#define DRAW_RETC_THICK    2    // Draw the width of the line
+#define IMAGE_WIDTH		   224  // The resolution of the model IMAGE sent to the classification is 224*224
+#define IMAGE_HEIGHT	   224
+#define OSD_FONT_WIDTH	   16
+#define OSD_FONT_HEIGHT	   24
+#define GESTURE_MIN        30   // confidence threshold
+#define WIDTH_LIMIT        32
+#define HEIGHT_LIMIT       32
+
+#define AUDIO_CASE_TWO     2
+#define AUDIO_SCORE        90 		// 缃淇″害琛缃
+#define AUDIO_FRAME        14 		// 姣15甯ц涓娆★琛缃
+
+static OsdSet* g_osdsGesture = NULL;
+static HI_S32 g_osd0Gesture = -1;
+
+static int g_num = 108;
+static int g_count = 0;
+static pthread_t g_thrdId = 0;
+static int g_supportAudio = 0;
+
+double sum = 0;
+double New_Num = 0;   
+
+static HI_CHAR *gesture_name = NULL;
+
+int Flag1 = 0;
+
+static int uart_fd ;
+static SkPair g_stmChn = {
+    .in = -1,
+    .out = -1
+};
+
+static void PlayAudio(const RecogNumInfo items)
+{
+	if (g_count < AUDIO_FRAME) {
+		g_count++;
+		return;
+	}
+
+	const RecogNumInfo *item = &items;
+	uint32_t score = item->score * 100 / 4096;
+	if ((score > AUDIO_SCORE) && (g_num != item->num)) {
+		g_num = item->num;
+		audio_test(AUDIO_CASE_TWO, g_num, -1);
+	}
+	g_count = 0;
+}
+
+static void* GetAudioFileName(void* arg)
+{
+	RecogNumInfo resBuf = {0};
+	int ret;
+
+	while(1) {
+		ret = FdReadMsg(g_stmChn.in, &resBuf, sizeof(RecogNumInfo));
+		if (ret == sizeof(RecogNumInfo)) {
+			PlayAudio(resBuf);
+		}
+	}
+}
+
+
+
+static const char YOLO2_HAND_DETECT_RESNET_CLASSIFY[] = "{"
+    "\"uuid\": " PLUG_UUID ","
+    "\"desc\": " PLUG_DESC ","
+    "\"frmWidth\": " HI_TO_STR(FRM_WIDTH) ","
+    "\"frmHeight\": " HI_TO_STR(FRM_HEIGHT) ","
+    "\"butt\": 0"
+"}";
+
+static const char* Yolo2HandDetectResnetClassifyProf(void)
+{
+    return YOLO2_HAND_DETECT_RESNET_CLASSIFY;
+}
+
+static HI_S32 Yolo2HandDetectResnetClassifyLoad(uintptr_t* model, OsdSet* osds)
+{
+    SAMPLE_SVP_NNIE_CFG_S *self = NULL;
+    HI_S32 ret;
+
+    g_osdsGesture = osds;
+    HI_ASSERT(g_osdsGesture);
+    g_osd0Gesture = OsdsCreateRgn(g_osdsGesture);
+    HI_ASSERT(g_osd0Gesture >= 0);
+
+    ret = CnnCreate(&self, MODEL_FILE_GESTURE);
+    *model = ret < 0 ? 0 : (uintptr_t)self;
+    HandDetectInit(); // Initialize the hand detection model
+
+    if (GetCfgBool("audio_player:support_audio", true)) {
+		ret = SkPairCreate(&g_stmChn);
+		HI_ASSERT(ret == 0);
+		if (pthread_create(&g_thrdId, NULL, GetAudioFileName, NULL) < 0) {
+			HI_ASSERT(0);
+		}
+		g_supportAudio = 1;
+	}
+
+
+
+    uart_fd =  uartOpenInit();//qi dong  UART
+    if (uart_fd < 0) {
+        LOGI("uart open failed");
+    } else {
+        LOGI("uart open successed\n");
+    }
+
+    return ret;
+}
+
+static HI_S32 Yolo2HandDetectResnetClassifyUnload(uintptr_t model)
+{
+    CnnDestroy((SAMPLE_SVP_NNIE_CFG_S*)model);
+    if (g_osdsGesture) {
+        OsdsClear(g_osdsGesture);
+        g_osdsGesture = NULL;
+    }
+
+    if (g_supportAudio == 1) {
+		SkPairDestroy(&g_stmChn);
+		pthread_join(g_thrdId, NULL);
+	}
+
+    HandDetectExit(); // Uninitialize the hand detection model
+
+    return 0;
+}
+
+/**
+	Get the maximum hand
+*/
+static HI_S32 GetBiggestHandIndex(RectBox boxs[], int detectNum)
+{
+    HI_S32 handIndex = 0;
+    HI_S32 biggestBoxIndex = handIndex;
+    HI_S32 biggestBoxWidth = boxs[handIndex].xmax - boxs[handIndex].xmin + 1;
+    HI_S32 biggestBoxHeight = boxs[handIndex].ymax - boxs[handIndex].ymin + 1;
+    HI_S32 biggestBoxArea = biggestBoxWidth * biggestBoxHeight;
+
+    for (handIndex = 1; handIndex < detectNum; handIndex++) {
+        HI_S32 boxWidth = boxs[handIndex].xmax - boxs[handIndex].xmin + 1;
+        HI_S32 boxHeight = boxs[handIndex].ymax - boxs[handIndex].ymin + 1;
+        HI_S32 boxArea = boxWidth * boxHeight;
+        if (biggestBoxArea < boxArea) {
+            biggestBoxArea = boxArea;
+            biggestBoxIndex = handIndex;
+        }
+        biggestBoxWidth = boxs[biggestBoxIndex].xmax - boxs[biggestBoxIndex].xmin + 1;
+        biggestBoxHeight = boxs[biggestBoxIndex].ymax - boxs[biggestBoxIndex].ymin + 1;
+    }
+
+    if ((biggestBoxWidth == 1) || (biggestBoxHeight == 1) || (detectNum == 0)) {
+        biggestBoxIndex = -1;
+    }
+
+    return biggestBoxIndex;
+}
+
+
+
+/**
+    Add gesture recognition information next to the rectangle
+*/
+static void HandDetectAddTxt(const RectBox box, const RecogNumInfo resBuf, uint32_t color)
+{
+    HI_OSD_ATTR_S osdRgn;
+    char osdTxt[TINY_BUF_SIZE]; 
+    HI_ASSERT(g_osdsGesture);
+    Flag1++;
+    sum += resBuf.num;  
+    if(Flag1 == 3){
+    New_Num = sum/3;
+    if(New_Num < 0.9){
+        gesture_name = "Cat";
+        //usbUartSendRead(uart_fd, CAT);
+         // usleep(100*1000);
+    }else{
+        gesture_name = "Gog";
+        //usbUartSendRead(uart_fd, DOG);
+       // usleep(100*1000);
+    }   
+    // switch (resBuf.num) {
+    //     case 0u:
+    //         gesture_name = "gesture cat";
+    //         usbUartSendRead(uart_fd, CAT);
+    //         break;
+    //     case 1u:
+    //         gesture_name = "gesture gog";
+    //         usbUartSendRead(uart_fd, DOG);
+    //         usleep(100*1000);
+    //         break;
+    //     default:
+    //         gesture_name = "background";
+    //         usbUartSendRead(uart_fd, UNKNOWN);
+    //         usleep(100*1000);
+    //         break;
+    // }
+    uint32_t score = (resBuf.score) * HI_PER_BASE / SCORE_MAX;
+	int res = snprintf_s(osdTxt, sizeof(osdTxt), sizeof(osdTxt) - 1, "%.2f_%s,%d %%",New_Num, gesture_name, score);
+	HI_ASSERT(res > 0);
+	int osdId = OsdsCreateRgn(g_osdsGesture);
+	HI_ASSERT(osdId >= 0);
+
+    int x = box.xmin / HI_OVEN_BASE * HI_OVEN_BASE;
+    int y = (box.ymin - 30) / HI_OVEN_BASE * HI_OVEN_BASE; // 30: empirical value
+    if (y < 0) {
+        LOGD("osd_y < 0, y=%d\n", y);
+        OsdsDestroyRgn(g_osdsGesture, osdId);
+    } else {
+        TxtRgnInit(&osdRgn, osdTxt, x, y, color, OSD_FONT_WIDTH, OSD_FONT_HEIGHT);
+        OsdsSetRgn(g_osdsGesture, osdId, &osdRgn);
+    }
+    Flag1 = 0;
+    New_Num = 0;
+    sum = 0;
+    }
+}
+
+
+/**
+    灏璁＄缁涓resJson.
+*/
+static HI_CHAR* CnnGestureClassifyToJson(const RecogNumInfo items[], HI_S32 itemNum)
+{
+    HI_S32 jsonSize = TINY_BUF_SIZE + itemNum * TINY_BUF_SIZE; // 姣涓itemsize涓TINY_BUF_SIZE
+    HI_CHAR *jsonBuf = (HI_CHAR*)malloc(jsonSize);
+    HI_ASSERT(jsonBuf);
+    HI_S32 offset = 0;
+
+    offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1, "[");
+    for (HI_S32 i = 0; i < itemNum; i++) {
+        const RecogNumInfo *item = &items[i];
+        uint32_t score = item->score * HI_PER_BASE / SCORE_MAX;
+        if (score < GESTURE_MIN) {
+            break;
+        }
+        offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1,
+            "%s{ \"classify num\": %u, \"score\": %u }", (i == 0 ? "\n  " : ", "), (uint)item->num, (uint)score);
+        HI_ASSERT(offset < jsonSize);
+    }
+    offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1, "]");
+    HI_ASSERT(offset < jsonSize);
+    return jsonBuf;
+}
+
+
+static HI_S32 Yolo2HandDetectResnetClassifyCal(uintptr_t model,
+    VIDEO_FRAME_INFO_S *srcFrm, VIDEO_FRAME_INFO_S *dstFrm, HI_CHAR** resJson)
+{
+    SAMPLE_SVP_NNIE_CFG_S *self = (SAMPLE_SVP_NNIE_CFG_S*)model;
+    IVE_IMAGE_S img;
+    DetectObjInfo objs[DETECT_OBJ_MAX] = {0};
+    RectBox boxs[DETECT_OBJ_MAX] = {0};
+    RectBox objBoxs[DETECT_OBJ_MAX] = {0};
+    RectBox remainingBoxs[DETECT_OBJ_MAX] = {0};
+    RectBox cnnBoxs[DETECT_OBJ_MAX] = {0}; // Store the results of the classification network
+    RecogNumInfo numInfo[RET_NUM_MAX] = {0};
+    HI_S32 resLen = 0;
+    int objNum;
+    int ret;
+    int biggestBoxIndex;
+    int num = 0;
+
+    OsdsClear(g_osdsGesture);
+    ret = FrmToOrigImg((VIDEO_FRAME_INFO_S*)srcFrm, &img);
+    HI_EXP_RET(ret != HI_SUCCESS, ret, "hand_detect_cal FAIL, for YUV Frm to Img FAIL, ret=%#x\n", ret);
+
+    objNum = HandDetectCal(&img, objs); // Send IMG to the detection net for reasoning
+    for (int i = 0; i < objNum; i++) {
+        cnnBoxs[i] = objs[i].box;
+        RectBox *box = &objs[i].box;
+
+        RectBoxTran(box, FRM_WIDTH, FRM_HEIGHT,
+            dstFrm->stVFrame.u32Width, dstFrm->stVFrame.u32Height);
+
+        LOGI("yolo2_out: {%d, %d, %d, %d}\n",
+            box->xmin, box->ymin, box->xmax, box->ymax);
+        //xmax MAX涓1920锛ymax MAX涓1080    
+        /**
+        /* usbUartSendRead(uart_fd, DOG);
+        /* usleep(100*1000);
+        **/
+       if(gesture_name == "Gog"){
+       if(box->xmin <= 0){
+        usbUartSendRead(uart_fd, 0x04);
+        usleep(1000);
+       }
+       else if(box->xmax >= 1920){
+        usbUartSendRead(uart_fd, 0x06);
+        usleep(1000);
+       }
+       else if(box->ymin <= 0){
+        usbUartSendRead(uart_fd, 0x03);
+        usleep(1000);
+       }
+       else if(box->ymax >= 1080){
+        usbUartSendRead(uart_fd, 0x08);
+        usleep(1000);
+       }
+       else
+        usbUartSendRead(uart_fd, 0x02);
+        usleep(1000);
+       }
+
+       if(gesture_name == "Cat"){
+       if(box->xmin <= 0){
+        usbUartSendRead(uart_fd, 0x14);
+        usleep(1000);
+       }
+       else if(box->xmax >= 1920){
+        usbUartSendRead(uart_fd, 0x16);
+        usleep(1000);
+       }
+       else if(box->ymin <= 0){
+        usbUartSendRead(uart_fd, 0x13);
+        usleep(1000);
+       }
+       else if(box->ymax >= 1080){
+        usbUartSendRead(uart_fd, 0x18);
+        usleep(1000);
+       }
+       else
+        usbUartSendRead(uart_fd, 0x01);
+        usleep(1000);
+    }
+       
+        boxs[i] = *box;
+    }
+    biggestBoxIndex = GetBiggestHandIndex(boxs, objNum);
+    LOGI("biggestBoxIndex:%d, objNum:%d\n", biggestBoxIndex, objNum);
+
+    // When an object is detected, a rectangle is drawn in the DSTFRM
+    if (biggestBoxIndex >= 0) {
+        objBoxs[0] = boxs[biggestBoxIndex];
+        MppFrmDrawRects(dstFrm, objBoxs, 1, RGB888_GREEN, DRAW_RETC_THICK); // Target hand objnum is equal to 1
+
+        for (int j = 0; (j < objNum) && (objNum > 1); j++) {
+            if (j != biggestBoxIndex) {
+                remainingBoxs[num++] = boxs[j];
+                // others hand objnum is equal to objnum -1
+                MppFrmDrawRects(dstFrm, remainingBoxs, objNum - 1, RGB888_RED, DRAW_RETC_THICK);
+            }
+        }
+
+        IVE_IMAGE_S imgIn;
+        IVE_IMAGE_S imgDst;
+        VIDEO_FRAME_INFO_S frmIn;
+        VIDEO_FRAME_INFO_S frmDst;
+
+        ret = ImgYuvCrop(&img, &imgIn, &cnnBoxs[biggestBoxIndex]); // Crop the image to classification network
+        HI_EXP_LOGE(ret < 0, "ImgYuvCrop FAIL, ret = %d\n", ret);
+
+        if ((imgIn.u32Width >= WIDTH_LIMIT) && (imgIn.u32Height >= HEIGHT_LIMIT)) {
+            COMPRESS_MODE_E enCompressMode = srcFrm->stVFrame.enCompressMode;
+			ret = OrigImgToFrm(&imgIn, &frmIn);
+            frmIn.stVFrame.enCompressMode = enCompressMode;
+			LOGI("crop u32Width = %d, img.u32Height = %d\n", imgIn.u32Width, imgIn.u32Height);
+            ret = MppFrmResize(&frmIn, &frmDst, IMAGE_WIDTH, IMAGE_HEIGHT);
+            ret = FrmToOrigImg(&frmDst, &imgDst);
+
+            ret = CnnCalU8c1Img(self,  &imgDst, numInfo, HI_ARRAY_SIZE(numInfo), &resLen);
+			HI_EXP_LOGE(ret < 0, "CnnCalU8c1Img FAIL, ret = %d\n", ret);
+			HI_ASSERT(resLen <= sizeof(numInfo) / sizeof(numInfo[0]));
+            RectBoxTran(&cnnBoxs[biggestBoxIndex], FRM_WIDTH, FRM_HEIGHT,
+                dstFrm->stVFrame.u32Width, dstFrm->stVFrame.u32Height);
+            HandDetectAddTxt(cnnBoxs[biggestBoxIndex], numInfo[0], ARGB1555_WHITE);
+
+            MppFrmDestroy(&frmDst);
+        }
+        IveImgDestroy(&img);
+        IveImgDestroy(&imgIn);
+    }
+
+    HI_CHAR *jsonBuf = CnnGestureClassifyToJson(numInfo, resLen);
+    *resJson = jsonBuf;
+
+    if (g_supportAudio == 1) {
+		if (FdWriteMsg(g_stmChn.out, &numInfo[0], sizeof(RecogNumInfo)) != sizeof(RecogNumInfo)) {
+			LOGE("FdWriteMsg FAIL\n");
+		}
+	}
+
+    return ret;
+}
+
+static const AiPlug G_HAND_CLASSIFY_ITF = {
+    .Prof = Yolo2HandDetectResnetClassifyProf,
+    .Load = Yolo2HandDetectResnetClassifyLoad,
+    .Unload = Yolo2HandDetectResnetClassifyUnload,
+    .Cal = Yolo2HandDetectResnetClassifyCal,
+};
+
+const AiPlug* AiPlugItf(uint32_t* magic)
+{
+    if (magic) {
+        *magic = AI_PLUG_MAGIC;
+    }
+
+    return (AiPlug*)&G_HAND_CLASSIFY_ITF;
+}
\ 浠跺熬娌℃㈣绗
diff -urpBN hiopenais/src/plug_demo/hisignalling/hisignalling.c hiopenais_modify/src/plug_demo/hisignalling/hisignalling.c
--- hiopenais/src/plug_demo/hisignalling/hisignalling.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/plug_demo/hisignalling/hisignalling.c	2021-11-11 02:04:26.781134182 -0800
@@ -0,0 +1,400 @@
+#include <stdio.h>
+#include "hisignalling.h"
+#include <stdlib.h>
+#include <string.h>
+#include <pthread.h>
+#include <limits.h>
+#include <math.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <termios.h>
+#include <errno.h>
+#include <sys/fcntl.h>
+#include <poll.h>
+//#include "cnn_gender_classify.h"
+
+#define MSG(args...) printf(args)
+
+/*涓插ｈ剧疆*/
+int uart1_config(int fd)
+{
+    struct termios newtio,oldtio;
+    /*峰涓插ｉ缃*/
+    if  ( tcgetattr(fd, &oldtio)  !=  0) { 
+        perror("SetupSerial 1");
+        return -1;
+    }
+    memset( &newtio, 0, sizeof(newtio) );
+    /*CREAD 寮涓茶版ユ讹CLOCAL骞舵寮拌ユā寮*/
+    newtio.c_cflag  |=  CLOCAL | CREAD;
+
+    /*璁剧疆版浣8*/
+    newtio.c_cflag &= ~CSIZE;
+    newtio.c_cflag |= CS8;
+    /* 璁剧疆濂舵￠浣 */
+    newtio.c_cflag &= ~PARENB; //濂舵￠
+    /* 璁剧疆娉㈢圭 115200*/
+	cfsetispeed(&newtio, B115200);
+	cfsetospeed(&newtio, B115200);
+
+    /*璁剧疆姝浣*/
+    newtio.c_cflag &=  ~CSTOPB;/*榛璁や负涓浣姝浣锛 */
+    /*璁剧疆灏瀛绗绛寰堕达瀵逛ユ跺绗绛寰堕存病瑰瑕姹*/
+    newtio.c_cc[VTIME]  = 0;/*瑙妯″璇诲剁瓒舵堕达*/
+    newtio.c_cc[VMIN] = 0;/*瑙妯″璇诲剁灏瀛绗*/
+    /*tcflush娓绌虹绔瀹杈/杈鸿锋版锛TCIFLUSH琛ㄧず娓绌烘ｆ跺扮版锛涓涓璇诲烘 */
+    tcflush(fd, TCIFLUSH);
+    if((tcsetattr(fd, TCSANOW,&newtio))!=0) {
+        perror("com set error");
+        return -1;
+    }
+    return 0;
+}
+/**
+	@berf uart send
+	@param int fd: uart file descriptor
+	@param void *buf:send data buf
+	@param int len:data buf len
+*/
+int uart_send(int fd, void *buf, int len)
+{
+    int ret = 0;
+    int count = 0;
+
+    tcflush(fd, TCIFLUSH);
+
+    while (len > 0) {
+        ret = write(fd, (char*)buf + count, len);
+        if (ret < 1) {
+			printf("write data below 1 byte % d\r\n", ret);
+            break;
+        }
+        count += ret;
+        len = len - ret;
+    }
+
+    return count;
+}
+/**
+	@berf uart read
+	@param int uart_fd: uart file descriptor
+	@param void *buf:read data buf
+	@param int len:data buf len
+	@param int timeout_ms: read data time
+*/
+int uart_read(int uart_fd, void *buf, int len, int timeout_ms)
+{
+    int ret;
+    size_t  rsum = 0;
+    ret = 0;
+    fd_set rset;
+    struct timeval time;
+
+    while (rsum < len) {
+        time.tv_sec = timeout_ms/1000;
+        time.tv_usec = (timeout_ms - time.tv_sec*1000)*1000;
+        FD_ZERO(&rset);
+        FD_SET(uart_fd, &rset);
+        ret = select(uart_fd+1, &rset, NULL, NULL, &time);
+        if (ret <= 0) {
+            if (ret == 0) {
+				printf("time over!\r\n");
+                return -1;
+            }
+            if (ret == -1) {
+				printf("select error!\r\n");
+                // 淇″蜂腑
+                continue;
+            }
+            return -1;
+        } else {
+            ret = read(uart_fd, (char *)buf + rsum, len - rsum);
+            if (ret < 0){
+				printf("read data failed\r\n");
+                return ret;
+            } else {
+                rsum += ret;
+            }
+        }
+    }
+
+    return rsum;
+}
+
+/*
+ *crc32 Verification implementation
+*/
+static const unsigned int crc32table[] = {
+ 0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL,
+ 0x076dc419L, 0x706af48fL, 0xe963a535L, 0x9e6495a3L,
+ 0x0edb8832L, 0x79dcb8a4L, 0xe0d5e91eL, 0x97d2d988L,
+ 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L, 0x90bf1d91L,
+ 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+ 0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L,
+ 0x136c9856L, 0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL,
+ 0x14015c4fL, 0x63066cd9L, 0xfa0f3d63L, 0x8d080df5L,
+ 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L, 0xa2677172L,
+ 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+ 0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L,
+ 0x32d86ce3L, 0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L,
+ 0x26d930acL, 0x51de003aL, 0xc8d75180L, 0xbfd06116L,
+ 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L, 0xb8bda50fL,
+ 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+ 0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL,
+ 0x76dc4190L, 0x01db7106L, 0x98d220bcL, 0xefd5102aL,
+ 0x71b18589L, 0x06b6b51fL, 0x9fbfe4a5L, 0xe8b8d433L,
+ 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL, 0xe10e9818L,
+ 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+ 0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL,
+ 0x6c0695edL, 0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L,
+ 0x65b0d9c6L, 0x12b7e950L, 0x8bbeb8eaL, 0xfcb9887cL,
+ 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L, 0xfbd44c65L,
+ 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+ 0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL,
+ 0x4369e96aL, 0x346ed9fcL, 0xad678846L, 0xda60b8d0L,
+ 0x44042d73L, 0x33031de5L, 0xaa0a4c5fL, 0xdd0d7cc9L,
+ 0x5005713cL, 0x270241aaL, 0xbe0b1010L, 0xc90c2086L,
+ 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+ 0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L,
+ 0x59b33d17L, 0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL,
+ 0xedb88320L, 0x9abfb3b6L, 0x03b6e20cL, 0x74b1d29aL,
+ 0xead54739L, 0x9dd277afL, 0x04db2615L, 0x73dc1683L,
+ 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+ 0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L,
+ 0xf00f9344L, 0x8708a3d2L, 0x1e01f268L, 0x6906c2feL,
+ 0xf762575dL, 0x806567cbL, 0x196c3671L, 0x6e6b06e7L,
+ 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL, 0x67dd4accL,
+ 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+ 0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L,
+ 0xd1bb67f1L, 0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL,
+ 0xd80d2bdaL, 0xaf0a1b4cL, 0x36034af6L, 0x41047a60L,
+ 0xdf60efc3L, 0xa867df55L, 0x316e8eefL, 0x4669be79L,
+ 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+ 0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL,
+ 0xc5ba3bbeL, 0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L,
+ 0xc2d7ffa7L, 0xb5d0cf31L, 0x2cd99e8bL, 0x5bdeae1dL,
+ 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL, 0x026d930aL,
+ 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+ 0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L,
+ 0x92d28e9bL, 0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L,
+ 0x86d3d2d4L, 0xf1d4e242L, 0x68ddb3f8L, 0x1fda836eL,
+ 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L, 0x18b74777L,
+ 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+ 0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L,
+ 0xa00ae278L, 0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L,
+ 0xa7672661L, 0xd06016f7L, 0x4969474dL, 0x3e6e77dbL,
+ 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L, 0x37d83bf0L,
+ 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+ 0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L,
+ 0xbad03605L, 0xcdd70693L, 0x54de5729L, 0x23d967bfL,
+ 0xb3667a2eL, 0xc4614ab8L, 0x5d681b02L, 0x2a6f2b94L,
+ 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL, 0x2d02ef8dL
+};
+ 
+/**
+	@berf CRC check
+	@param const unsigned char *buf: Data to be verified buff
+	@param unsigned int size: Data to be verified length
+*/
+static unsigned int crc32( const unsigned char *buf, unsigned int size)
+{
+    unsigned int  i, crc = 0xFFFFFFFF;
+ 
+    for (i = 0; i < size; i++) {
+        crc = crc32table[(crc ^ buf[i]) & 0xff] ^ (crc >> 8);
+    }
+    return crc^0xFFFFFFFF;
+}
+
+/*hisignal Hi3516 message send*/
+static unsigned int hisignalling_data_package(hisignalling_protocal_type *buf, unsigned int len, unsigned char *hisignalling_data_buf)
+{
+    unsigned int crc_check_send;
+	unsigned int package_len = 0;
+
+    memcpy(hisignalling_data_buf, buf->frame_header, HISGNALLING_MSG_FRAME_HEADER_LEN);
+    memcpy(&hisignalling_data_buf[HISGNALLING_MSG_FRAME_HEADER_LEN], buf->hisignalling_msg_buf, len);
+    memcpy(&hisignalling_data_buf[HISGNALLING_MSG_FRAME_HEADER_LEN + len], &(buf->end_of_frame), HISIGNALLING_MSG_HEADER_LEN);
+
+    crc_check_send = crc32(hisignalling_data_buf, (len + HISIGNALLING_MSG_HEADER_TAIL_LEN));
+    hisignalling_data_buf[len + HISIGNALLING_MSG_HEADER_TAIL_LEN] = 	(unsigned char)((crc_check_send & 0xff000000)>>24);
+    hisignalling_data_buf[len + HISIGNALLING_MSG_HEADER_TAIL_LEN + 1] = (unsigned char)((crc_check_send & 0x00ff0000)>>16);
+    hisignalling_data_buf[len + HISIGNALLING_MSG_HEADER_TAIL_LEN + 2] = (unsigned char)((crc_check_send & 0x0000ff00)>>8);
+    hisignalling_data_buf[len + HISIGNALLING_MSG_HEADER_TAIL_LEN + 3] = (unsigned char)crc_check_send;
+    package_len = len + HISIGNALLING_MSG_HEADER_TAIL_LEN + 4;
+    return package_len;
+}
+
+/*hisignalling Hi3561 message recevice*/
+static hisignalling_error_type hisignalling_msg_receive(int fd, unsigned char *buf, unsigned int len)
+{
+    unsigned int crc_check_received;
+	int i = 0,read_len = 0;
+	/*Hi3516dv300 uart read*/
+	read_len = uart_read(fd, buf, len, 1000);
+	if (read_len <= 0) {
+		printf("uart_read data failed\r\n");
+		return HISIGNALLING_RET_VAL_ERROR;
+	}
+	printf("read_len=%d\r\n", read_len);
+    /*￠crc*/
+	if (len > 4) {
+		crc_check_received = crc32(buf, len-4);
+		if (((unsigned char)((crc_check_received & 0xff000000)>>24) != buf[len-4]) &&
+			((unsigned char)((crc_check_received & 0x00ff0000)>>16) != buf[len-3]) &&
+			((unsigned char)((crc_check_received & 0x0000ff00)>>8)  != buf[len-2]) &&
+			((unsigned char)crc_check_received != buf[len-1])) {
+			printf("<Hi3516dv300>: crc32 Verification failed!\r\n");
+			printf("<Hi3516dv300>: crc_4=0x%x, crc_3=0x%x, crc_2=0x%x, crc_1=0x%x\r\n", buf[len-4], buf[len-3], buf[len-2], buf[len-1]);
+			return HISIGNALLING_RET_VAL_ERROR;
+		}
+	}
+    /*杈烘跺扮版*/ 
+    for (i = 0; i < len; i++) {
+        printf("0x%x ", buf[i]);
+    }
+    printf("\r\n");
+
+    return HISIGNALLING_RET_VAL_CORRECT;
+}
+
+/**
+	@berf hisignalling protocol send msg
+	@param void *buf: send data buff
+	@param unsigned int data_len: send data length
+*/
+static unsigned int hisignalling_msg_send(int fd, void *buf, unsigned int data_len)
+{
+	unsigned int ret;
+    hisignalling_protocal_type hisignalling_msg;
+    unsigned char hisignalling_send_buf[HISIGNALLING_MSG_BUFF_LEN] = {0};
+    unsigned int hisignalling_package_len = 0;
+
+    hisignalling_msg.frame_header[0]= 0xAA;
+    hisignalling_msg.frame_header[1]= 0x55; 
+    memcpy(hisignalling_msg.hisignalling_msg_buf, buf, data_len);
+    hisignalling_msg.end_of_frame = 0xff;
+
+    hisignalling_package_len = hisignalling_data_package(&hisignalling_msg, data_len, hisignalling_send_buf);
+	if (!hisignalling_package_len) {
+        printf("hisignalling_data_package failed = %d\r\n", hisignalling_package_len);
+        return -1;
+    }
+    if (*hisignalling_send_buf == 0) {
+        printf("hisignalling send buf is null!\r\n");
+        return -1;
+    }
+	ret = uart_send(fd, hisignalling_send_buf, hisignalling_package_len);
+	if (ret < 0) {
+		printf("write data failed\r\n");
+		return -1;
+	}
+	return 0;
+}
+
+unsigned int usbOpenInit(void)
+{
+    int fd;
+    char *usb = "/dev/ttyUSB0";
+
+    if((fd = open(usb, O_RDWR | O_NOCTTY | O_NDELAY)) < 0) {
+        printf("open %s is failed",usb);
+        return -1;
+	} else {
+		uart1_config(fd);
+    }
+    return fd;
+}
+
+unsigned int uartOpenInit(void)
+{
+    int fd;
+    // char *usb = "/dev/ttyUSB0";
+    char *uart1 = "/dev/ttyAMA1";
+
+    if((fd = open(uart1, O_RDWR | O_NOCTTY | O_NDELAY)) < 0) {
+        printf("open %s is failed",uart1);
+        return -1;
+	} else {
+		uart1_config(fd);
+    }
+    return fd;
+}
+
+void usbUartSendRead(int fd, refuseClassification refuseType)
+{
+
+    unsigned char write_buffer2[4] = {0,2,0,1};
+	unsigned char write_buffer3[4] = {0,2,0,2};
+
+    unsigned char write_buffer_D[4] = {0,2,0,2};    // 
+    unsigned char write_buffer_LX_D[4] = {0,2,4,2}; // 稿乏绉
+    unsigned char write_buffer_Rx_D[4] = {0,2,6,2}; // 稿冲绉
+    unsigned char write_buffer_Dy_D[4] = {0,2,8,2}; // 镐绉 
+    unsigned char write_buffer_Uy_D[4] = {0,2,2,2}; // 镐绉
+
+    unsigned char write_buffer_C[4] = {0,2,0,1};    // 
+    unsigned char write_buffer_LX_C[4] = {0,2,4,1}; // 稿乏绉
+    unsigned char write_buffer_Rx_C[4] = {0,2,6,1}; // 稿冲绉
+    unsigned char write_buffer_Dy_C[4] = {0,2,8,1}; // 镐绉 
+    unsigned char write_buffer_Uy_C[4] = {0,2,2,1}; // 镐绉
+ 
+    unsigned char read_buff[16] = {0};
+
+ #ifdef  EXPANSION_BOARD
+// #ifdef  ROBOT_BOARD
+    // switch (refuseType) {
+    //     case CAT:
+    //         hisignalling_msg_send(fd, write_buffer2, sizeof(write_buffer2)/sizeof(write_buffer2[0]));
+
+    //         break;
+    //     case DOG: 
+    //         hisignalling_msg_send(fd, write_buffer3, sizeof(write_buffer3)/sizeof(write_buffer3[0]));
+    //         break;
+    //     case UNKNOWN:
+    //         break;     
+    // }
+
+        //告娴
+        if(refuseType == 0x01){         //
+            hisignalling_msg_send(fd, write_buffer_C, sizeof(write_buffer_C)/sizeof(write_buffer_C[0]));
+        }
+        if(refuseType == 0x14){         //稿乏绉
+            hisignalling_msg_send(fd, write_buffer_LX_C, sizeof(write_buffer_LX_C)/sizeof(write_buffer_LX_C[0]));
+        }
+        if(refuseType == 0x16){         //稿崇Щ
+            hisignalling_msg_send(fd, write_buffer_Rx_C, sizeof(write_buffer_Rx_C)/sizeof(write_buffer_Rx_C[0]));
+        }
+        if(refuseType == 0x13){         //镐绉
+            hisignalling_msg_send(fd, write_buffer_Dy_C, sizeof(write_buffer_Dy_C)/sizeof(write_buffer_Dy_C[0]));
+        }
+        if(refuseType == 0x18){         //镐绉
+            hisignalling_msg_send(fd, write_buffer_Uy_C, sizeof(write_buffer_Uy_C)/sizeof(write_buffer_Uy_C[0]));
+        }   
+
+        //告娴
+        if(refuseType == 0x02){         //
+            hisignalling_msg_send(fd, write_buffer_D, sizeof(write_buffer_D)/sizeof(write_buffer_D[0]));
+        }
+        if(refuseType == 0x04){         //稿乏绉
+            hisignalling_msg_send(fd, write_buffer_LX_D, sizeof(write_buffer_LX_D)/sizeof(write_buffer_LX_D[0]));
+        }
+        if(refuseType == 0x06){         //稿崇Щ
+            hisignalling_msg_send(fd, write_buffer_Rx_D, sizeof(write_buffer_Rx_D)/sizeof(write_buffer_Rx_D[0]));
+        }
+        if(refuseType == 0x03){         //镐绉
+            hisignalling_msg_send(fd, write_buffer_Dy_D, sizeof(write_buffer_Dy_D)/sizeof(write_buffer_Dy_D[0]));
+        }
+        if(refuseType == 0x08){         //镐绉
+            hisignalling_msg_send(fd, write_buffer_Uy_D, sizeof( write_buffer_Uy_D)/sizeof(write_buffer_Uy_D[0]));
+        }
+
+#endif
+// #endif					
+    /*涓插ｈ绘浣*/
+    if (read_buff[0] == 0xaa && read_buff[1] == 0x55){
+        hisignalling_msg_receive(fd, read_buff, HISIGNALLING_MSG_MOTOR_ENGINE_LEN);
+    }
+}
浜杩舵浠 hiopenais/src/plug_demo/hisignalling/.hisignalling.c.swp  hiopenais_modify/src/plug_demo/hisignalling/.hisignalling.c.swp 涓
diff -urpBN hiopenais/src/plug_demo/hisignalling/hisignalling.h hiopenais_modify/src/plug_demo/hisignalling/hisignalling.h
--- hiopenais/src/plug_demo/hisignalling/hisignalling.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/plug_demo/hisignalling/hisignalling.h	2021-07-21 02:26:26.831202279 -0700
@@ -0,0 +1,55 @@
+/**/
+#ifndef __HISIGNALLING_H_
+#define __HISIGNALLING_H_
+#include <stdio.h>
+// #include "cnn_gender_classify.h"
+
+#define HISIGNALLING_MSG_HEADER_LEN         (1)
+#define HISGNALLING_MSG_FRAME_HEADER_LEN    (2)
+#define HISIGNALLING_MSG_HEADER_TAIL_LEN    (3)
+#define HISGNALLING_FREE_TASK_TIME          (10)
+#define HISIGNALLING_MSG_MOTOR_ENGINE_LEN	(11)
+#define HISIGNALLING_MSG_ONE_FRAME_LEN		(16)
+#define HISIGNALLING_MSG_BUFF_LEN           (512)
+
+/**
+*@brief Adapter plate selection
+*浣跨ㄦ堕╂寮瀹锛浣跨ㄥ璁炬╁挎寮#define BOARD_SELECT_IS_EXPANSION_BOARD杩涓瀹锛浣跨Robot挎寮#define BOARD_SELECT_IS_ROBOT_BOARD杩涓瀹
+**/
+// #define BOARD_SELECT_IS_ROBOT_BOARD
+#define BOARD_SELECT_IS_EXPANSION_BOARD
+#ifdef BOARD_SELECT_IS_EXPANSION_BOARD
+#define EXPANSION_BOARD
+#else 
+#define ROBOT_BOARD
+#endif
+
+typedef struct hisignalling_protocal {
+    unsigned char frame_header[HISGNALLING_MSG_FRAME_HEADER_LEN];
+    unsigned char hisignalling_msg_buf[HISIGNALLING_MSG_BUFF_LEN];
+    unsigned int hisigalling_msg_len;
+    unsigned char end_of_frame;
+    unsigned int hisignalling_crc32_check; 
+}hisignalling_protocal_type;
+
+typedef enum hisignalling_return_val{
+    HISIGNALLING_RET_VAL_CORRECT = 0,
+    HISIGNALLING_RET_VAL_ERROR,
+    HISGNALLING_RET_VAL_MAX
+}hisignalling_error_type;
+
+typedef enum {
+        CAT = 0x00,
+        DOG = 0x01,
+        UNKNOWN = 0x02,
+}  refuseClassification;
+
+/*
+*hisignalling protocal Function declaration
+*/
+unsigned int hisignalling_msg_task(void);
+unsigned int usbOpenInit(void);
+unsigned int uartOpenInit(void);
+void usbUartSendRead(int fd, refuseClassification refuseType);
+
+#endif
\ 浠跺熬娌℃㈣绗
diff -urpBN hiopenais/src/plug_demo/nnie_sample_plug/nnie_sample_plug.c hiopenais_modify/src/plug_demo/nnie_sample_plug/nnie_sample_plug.c
--- hiopenais/src/plug_demo/nnie_sample_plug/nnie_sample_plug.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/plug_demo/nnie_sample_plug/nnie_sample_plug.c	2021-07-18 19:48:00.031618668 -0700
@@ -0,0 +1,1147 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <signal.h>
+#include <pthread.h>
+#include <sys/prctl.h>
+#include <math.h>
+#include <assert.h>
+
+#include "hi_common.h"
+#include "hi_comm_sys.h"
+#include "hi_comm_svp.h"
+#include "sample_comm.h"
+#include "sample_comm_svp.h"
+#include "sample_comm_nnie.h"
+#include "sample_comm_ive.h"
+#include "sample_svp_nnie_software.h"
+#include "sample_nnie_main.h"
+
+#include "nnie_sample_plug.h"
+
+/******************************************************************************
+    nnie sample to HiOpenAIS plugs
+******************************************************************************/
+#define SP_NNIE_PLUG
+
+#include <hi_ext_util.h>
+
+char* DetectObjsToJson(const DetectObjInfo items[], int itemNum, int* resBytes)
+{
+    int jsonSize = TINY_BUF_SIZE + itemNum * SMALL_BUF_SIZE; // 姣涓涓objSMALL_BUF_SIZE绌洪
+    char *jsonBuf = (char*)malloc(jsonSize);
+    HI_ASSERT(jsonBuf);
+    int offset = 0;
+
+    offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1, "[");
+    for (int i = 0; i < itemNum; i++) {
+        const DetectObjInfo *item = &items[i];
+        offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1,
+            "%s\n  { \"class\": %d, \"score\": %.2f, \"box\": "
+            "{ \"xmin\": %d, \"ymin\": %d, \"xmax\": %d, \"ymax\": %d }}",
+            (i == 0 ? "" : ","), item->cls, item->score,
+            item->box.xmin, item->box.ymin, item->box.xmax, item->box.ymax);
+        HI_ASSERT(offset < jsonSize);
+    }
+    offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1, "]");
+    HI_ASSERT(offset < jsonSize);
+
+    if (resBytes) {
+        *resBytes = offset;
+    }
+    return jsonBuf;
+}
+
+static HI_S32 FillNnieByImg(SAMPLE_SVP_NNIE_CFG_S* pstNnieCfg,
+    SAMPLE_SVP_NNIE_PARAM_S *pstNnieParam, int segId, int nodeId, const IVE_IMAGE_S *img)
+{
+    HI_U32 i;
+    HI_U32 j;
+    HI_U32 n;
+    HI_U32 u32Height = 0;
+    HI_U32 u32Width = 0;
+    HI_U32 u32Chn = 0;
+    HI_U32 u32Stride = 0;
+    HI_U32 u32VarSize;
+    HI_U8 *pu8PicAddr = NULL;
+
+    /* get data size */
+    if (SVP_BLOB_TYPE_U8 <= pstNnieParam->astSegData[segId].astSrc[nodeId].enType &&
+        SVP_BLOB_TYPE_YVU422SP >= pstNnieParam->astSegData[segId].astSrc[nodeId].enType) {
+        u32VarSize = sizeof(HI_U8);
+    } else {
+        u32VarSize = sizeof(HI_U32);
+    }
+
+    /* fill src data */
+    if (SVP_BLOB_TYPE_SEQ_S32 == pstNnieParam->astSegData[segId].astSrc[nodeId].enType) {
+        assert(0);
+    } else {
+        u32Height = pstNnieParam->astSegData[segId].astSrc[nodeId].unShape.stWhc.u32Height;
+        u32Width = pstNnieParam->astSegData[segId].astSrc[nodeId].unShape.stWhc.u32Width;
+        u32Chn = pstNnieParam->astSegData[segId].astSrc[nodeId].unShape.stWhc.u32Chn;
+        u32Stride = pstNnieParam->astSegData[segId].astSrc[nodeId].u32Stride;
+        pu8PicAddr = SAMPLE_SVP_NNIE_CONVERT_64BIT_ADDR(HI_U8,
+            pstNnieParam->astSegData[segId].astSrc[nodeId].u64VirAddr);
+
+        if (SVP_BLOB_TYPE_YVU420SP == pstNnieParam->astSegData[segId].astSrc[nodeId].enType) {
+            assert(pstNnieParam->astSegData[segId].astSrc[nodeId].u32Num == 1);
+            for (n = 0; n < pstNnieParam->astSegData[segId].astSrc[nodeId].u32Num; n++) {
+                // Y
+                const uint8_t *srcData = (const uint8_t*)(uintptr_t)img->au64VirAddr[0];
+                assert(srcData);
+                for (j = 0; j < u32Height; j++) {
+                    if (memcpy_s(pu8PicAddr, u32Width * u32VarSize, srcData, u32Width * u32VarSize) != EOK) {
+                        HI_ASSERT(0);
+                    }
+                    pu8PicAddr += u32Stride;
+                    srcData += img->au32Stride[0];
+                }
+                // UV
+                srcData = (const uint8_t*)(uintptr_t)img->au64VirAddr[1];
+                assert(srcData);
+                for (j = 0; j < u32Height / 2; j++) { // 2: 1/2Height
+                    if (memcpy_s(pu8PicAddr, u32Width * u32VarSize, srcData, u32Width * u32VarSize) != EOK) {
+                        HI_ASSERT(0);
+                    }
+                    pu8PicAddr += u32Stride;
+                    srcData += img->au32Stride[1];
+                }
+            }
+        } else if (SVP_BLOB_TYPE_YVU422SP == pstNnieParam->astSegData[segId].astSrc[nodeId].enType) {
+            assert(0);
+        } else {
+            for (n = 0; n < pstNnieParam->astSegData[segId].astSrc[nodeId].u32Num; n++) {
+                for (i = 0; i < u32Chn; i++) {
+                    const uint8_t *srcData = (const uint8_t*)(uintptr_t)img->au64VirAddr[i];
+                    assert(srcData);
+                    for (j = 0; j < u32Height; j++) {
+                        if (memcpy_s(pu8PicAddr, u32Width * u32VarSize, srcData, u32Width * u32VarSize) != EOK) {
+                            HI_ASSERT(0);
+                        }
+                        pu8PicAddr += u32Stride;
+                        srcData += img->au32Stride[i];
+                    }
+                }
+            }
+        }
+
+        SAMPLE_COMM_SVP_FlushCache(pstNnieParam->astSegData[segId].astSrc[nodeId].u64PhyAddr,
+            SAMPLE_SVP_NNIE_CONVERT_64BIT_ADDR(HI_VOID, pstNnieParam->astSegData[segId].astSrc[nodeId].u64VirAddr),
+            pstNnieParam->astSegData[segId].astSrc[nodeId].u32Num*u32Chn*u32Height*u32Stride);
+    }
+
+    return HI_SUCCESS;
+}
+
+/*
+    create CNN model based mode file
+*/
+int CnnCreate(SAMPLE_SVP_NNIE_CFG_S **model, const char* modelFile)
+{
+    SAMPLE_SVP_NNIE_CFG_S *self;
+    HI_U32 u32PicNum = 1;
+    HI_S32 s32Ret;
+
+    self = (SAMPLE_SVP_NNIE_CFG_S*)malloc(sizeof(*self));
+    assert(self);
+    if (memset_s(self, sizeof(*self), 0x00, sizeof(*self)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    // Set configuration parameter
+    self->pszPic = NULL;
+    self->u32MaxInputNum = u32PicNum; // max input image num in each batch
+    self->u32MaxRoiNum = 0;
+    self->aenNnieCoreId[0] = SVP_NNIE_ID_0; // set NNIE core
+    s_stCnnSoftwareParam.u32TopN = 5; // 5: value of the u32TopN
+
+    // Sys init
+    // CNN Load model
+    SAMPLE_SVP_TRACE_INFO("Cnn Load model!\n");
+    s32Ret = SAMPLE_COMM_SVP_NNIE_LoadModel((char*)modelFile, &s_stCnnModel);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, CNN_FAIL_0, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_COMM_SVP_NNIE_LoadModel failed!\n");
+
+    // CNN parameter initialization
+    // Cnn software parameters are set in SAMPLE_SVP_NNIE_Cnn_SoftwareParaInit,
+    // if user has changed net struct, please make sure the parameter settings in
+    // SAMPLE_SVP_NNIE_Cnn_SoftwareParaInit function are correct
+    SAMPLE_SVP_TRACE_INFO("Cnn parameter initialization!\n");
+    s_stCnnNnieParam.pstModel = &s_stCnnModel.stModel;
+    s32Ret = SAMPLE_SVP_NNIE_Cnn_ParamInit(self, &s_stCnnNnieParam, &s_stCnnSoftwareParam);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, CNN_FAIL_0, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_SVP_NNIE_Cnn_ParamInit failed!\n");
+
+    // 妯″抽淇℃
+    LOGI("model={ type=%x, frmNum=%u, chnNum=%u, w=%u, h=%u, stride=%u }\n",
+        s_stCnnNnieParam.astSegData[0].astSrc[0].enType,
+        s_stCnnNnieParam.astSegData[0].astSrc[0].u32Num,
+        s_stCnnNnieParam.astSegData[0].astSrc[0].unShape.stWhc.u32Chn,
+        s_stCnnNnieParam.astSegData[0].astSrc[0].unShape.stWhc.u32Width,
+        s_stCnnNnieParam.astSegData[0].astSrc[0].unShape.stWhc.u32Height,
+        s_stCnnNnieParam.astSegData[0].astSrc[0].u32Stride);
+
+    // record tskBuf
+    s32Ret = HI_MPI_SVP_NNIE_AddTskBuf(&(s_stCnnNnieParam.astForwardCtrl[0].stTskBuf));
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, CNN_FAIL_0, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,HI_MPI_SVP_NNIE_AddTskBuf failed!\n");
+    *model = self;
+    return 0;
+
+    CNN_FAIL_0:
+        SAMPLE_SVP_NNIE_Cnn_Deinit(&s_stCnnNnieParam, &s_stCnnSoftwareParam, &s_stCnnModel);
+        *model = NULL;
+        return -1;
+}
+
+/*
+    destroy CNN model
+*/
+void CnnDestroy(SAMPLE_SVP_NNIE_CFG_S *self)
+{
+    HI_S32 s32Ret;
+
+    /* Remove TskBuf */
+    s32Ret = HI_MPI_SVP_NNIE_RemoveTskBuf(&(s_stCnnNnieParam.astForwardCtrl[0].stTskBuf));
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, CNN_FAIL_0, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,HI_MPI_SVP_NNIE_RemoveTskBuf failed!\n");
+
+    CNN_FAIL_0:
+        SAMPLE_SVP_NNIE_Cnn_Deinit(&s_stCnnNnieParam, &s_stCnnSoftwareParam, &s_stCnnModel);
+        free(self);
+}
+
+void CnnFetchRes(SVP_BLOB_S *pstGetTopN, HI_U32 u32TopN, RecogNumInfo resBuf[], int resSize, int* resLen)
+{
+    assert(pstGetTopN);
+    HI_U32 i;
+    HI_U32 j = 0;
+    HI_U32 *pu32Tmp = NULL;
+    HI_U32 u32Stride = pstGetTopN->u32Stride;
+    if (memset_s(resBuf, resSize * sizeof(resBuf[0]), 0x00, resSize * sizeof(resBuf[0])) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    int resId = 0;
+    pu32Tmp = (HI_U32*)((HI_UL)pstGetTopN->u64VirAddr + j * u32Stride);
+    for (i = 0; i < u32TopN * 2 && resId < resSize; i += 2, resId++) { // 2: u32TopN*2
+        resBuf[resId].num = pu32Tmp[i];
+        resBuf[resId].score = pu32Tmp[i + 1];
+    }
+    *resLen = resId;
+}
+
+void CnnDumpRes(SVP_BLOB_S *pstGetTopN, HI_U32 u32TopN)
+{
+    assert(pstGetTopN);
+    HI_U32 i;
+    HI_U32 j;
+    HI_U32 *pu32Tmp = NULL;
+    HI_U32 u32Stride = pstGetTopN->u32Stride;
+
+    printf("{ ");
+    for (j = 0; j < pstGetTopN->u32Num; j++) {
+        pu32Tmp = (HI_U32*)((HI_UL)pstGetTopN->u64VirAddr + j * u32Stride);
+        for (i = 0; i < u32TopN * 2; i += 2) { // 2: u32TopN*2
+            printf("%s%u:%u", (i == 0 ? "" : ", "), pu32Tmp[i], pu32Tmp[i + 1]);
+        }
+    }
+    printf(" }");
+}
+
+/*
+    璁＄涓寮U8C1 image
+*/
+int CnnCalU8c1Img(SAMPLE_SVP_NNIE_CFG_S* self,
+    const IVE_IMAGE_S *img, RecogNumInfo resBuf[], int resSize, int* resLen)
+{
+    HI_S32 s32Ret;
+    SAMPLE_SVP_NNIE_INPUT_DATA_INDEX_S stInputDataIdx = {0};
+    SAMPLE_SVP_NNIE_PROCESS_SEG_INDEX_S stProcSegIdx = {0};
+
+    /* Fill src data */
+    self->pszPic = NULL;
+    stInputDataIdx.u32SegIdx = 0;
+    stInputDataIdx.u32NodeIdx = 0;
+    s32Ret = FillNnieByImg(self, &s_stCnnNnieParam, 0, 0, img);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, CNN_FAIL_1, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_SVP_NNIE_FillSrcData failed!\n");
+
+    /* NNIE process(process the 0-th segment) */
+    stProcSegIdx.u32SegIdx = 0;
+    s32Ret = SAMPLE_SVP_NNIE_Forward(&s_stCnnNnieParam, &stInputDataIdx, &stProcSegIdx, HI_TRUE);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, CNN_FAIL_1, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_SVP_NNIE_Forward failed!\n");
+
+    /* Software process */
+    /* if user has changed net struct, please make sure SAMPLE_SVP_NNIE_Cnn_GetTopN
+     function's input datas are correct */
+    s32Ret = SAMPLE_SVP_NNIE_Cnn_GetTopN(&s_stCnnNnieParam, &s_stCnnSoftwareParam);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, CNN_FAIL_1, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_SVP_NNIE_CnnGetTopN failed!\n");
+
+    /* Print result */
+    CnnFetchRes(&s_stCnnSoftwareParam.stGetTopN, s_stCnnSoftwareParam.u32TopN, resBuf, resSize, resLen);
+    return 0;
+
+    CNN_FAIL_1:
+        return -1;
+}
+
+/*
+    璁＄涓寮U8C1 file
+*/
+int CnnCalU8c1File(SAMPLE_SVP_NNIE_CFG_S* self, const char* picFileName)
+{
+    HI_S32 s32Ret;
+    SAMPLE_SVP_NNIE_INPUT_DATA_INDEX_S stInputDataIdx = {0};
+    SAMPLE_SVP_NNIE_PROCESS_SEG_INDEX_S stProcSegIdx = {0};
+
+    /* Fill src data */
+    SAMPLE_SVP_TRACE_INFO("cnn_cal_yun start!\n");
+    self->pszPic = (char*)picFileName;
+    stInputDataIdx.u32SegIdx = 0;
+    stInputDataIdx.u32NodeIdx = 0;
+    s32Ret = SAMPLE_SVP_NNIE_FillSrcData(self, &s_stCnnNnieParam, &stInputDataIdx);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, CNN_FAIL_1, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_SVP_NNIE_FillSrcData failed!\n");
+
+    /* NNIE process(process the 0-th segment) */
+    stProcSegIdx.u32SegIdx = 0;
+    s32Ret = SAMPLE_SVP_NNIE_Forward(&s_stCnnNnieParam, &stInputDataIdx, &stProcSegIdx, HI_TRUE);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, CNN_FAIL_1, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_SVP_NNIE_Forward failed!\n");
+
+    /* Software process */
+    /* if user has changed net struct, please make sure SAMPLE_SVP_NNIE_Cnn_GetTopN
+     function's input datas are correct */
+    s32Ret = SAMPLE_SVP_NNIE_Cnn_GetTopN(&s_stCnnNnieParam, &s_stCnnSoftwareParam);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, CNN_FAIL_1, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_SVP_NNIE_CnnGetTopN failed!\n");
+
+    /* Print result */
+    DOLOGI((printf("cnnRes="),
+        CnnDumpRes(&s_stCnnSoftwareParam.stGetTopN, s_stCnnSoftwareParam.u32TopN),
+        putchar('\n')));
+
+    SAMPLE_SVP_TRACE_INFO("cnn_cal_yun done\n");
+    return 0;
+
+    CNN_FAIL_1:
+        return -1;
+}
+
+/*
+    create rfcn model based mode file
+*/
+int RfcnCreate(SAMPLE_SVP_NNIE_CFG_S **model, const char* modelFile, LoadModelFunc loadFunc)
+{
+    SAMPLE_SVP_NNIE_CFG_S *self;
+    HI_S32 s32Ret;
+
+    *model = NULL;
+    self = (SAMPLE_SVP_NNIE_CFG_S*)malloc(sizeof(*self));
+    assert(self);
+    if (memset_s(self, sizeof(*self), 0x00, sizeof(*self)) != EOK) {
+        HI_ASSERT(0);
+    }
+    if (memset_s(&s_stRfcnModel, sizeof(s_stRfcnModel), 0, sizeof(s_stRfcnModel)) != EOK) {
+        HI_ASSERT(0);
+    }
+    if (memset_s(&s_stRfcnNnieParam, sizeof(s_stRfcnNnieParam), 0, sizeof(s_stRfcnNnieParam)) != EOK) {
+        HI_ASSERT(0);
+    }
+    if (memset_s(&s_stRfcnSoftwareParam, sizeof(s_stRfcnSoftwareParam), 0, sizeof(s_stRfcnSoftwareParam))) {
+        HI_ASSERT(0);
+    }
+
+    // Sys init
+    self->pszPic = NULL;
+    self->u32MaxInputNum = 1; // max input image num in each batch
+    self->u32MaxRoiNum = 300; // 300: value of MaxPoiNum
+    self->aenNnieCoreId[0] = SVP_NNIE_ID_0; // set NNIE core for 0-th Seg
+    self->aenNnieCoreId[1] = SVP_NNIE_ID_0; // set NNIE core for 1-th Seg
+    self->aenNnieCoreId[2] = SVP_NNIE_ID_0; // set NNIE core for 2-th Seg
+
+    LOGI("Rfcn Load model!\n");
+    if (loadFunc) {
+        s32Ret = loadFunc(&s_stRfcnModel, modelFile);
+    } else {
+        s32Ret = SAMPLE_COMM_SVP_NNIE_LoadModel((char*)modelFile, &s_stRfcnModel);
+    }
+    HI_CHK_GOTO(s32Ret, FAIL_0, "Load failed!\n");
+
+    // apcRpnDataLayerName is used to set RPN data layer name
+    // and search RPN input data,if user has changed network struct, please
+    // make sure the data layer names are correct
+    LOGI("Rfcn parameter initialization!\n");
+    s_stRfcnNnieParam.pstModel = &s_stRfcnModel.stModel;
+    s_stRfcnSoftwareParam.apcRpnDataLayerName[0] = "rpn_cls_score";
+    s_stRfcnSoftwareParam.apcRpnDataLayerName[1] = "rpn_bbox_pred";
+    s32Ret = SAMPLE_SVP_NNIE_Rfcn_ParamInit(self, &s_stRfcnNnieParam, &s_stRfcnSoftwareParam);
+    HI_CHK_GOTO(s32Ret, FAIL_0, "SAMPLE_SVP_NNIE_Rfcn_ParamInit failed!\n");
+    s_bNnieStopSignal = HI_FALSE;
+
+    // 妯″抽淇℃
+    LOGI("model.base={ type=%x, frmNum=%u, chnNum=%u, w=%u, h=%u, stride=%u }\n",
+        s_stRfcnNnieParam.astSegData[0].astSrc[0].enType,
+        s_stRfcnNnieParam.astSegData[0].astSrc[0].u32Num,
+        s_stRfcnNnieParam.astSegData[0].astSrc[0].unShape.stWhc.u32Chn,
+        s_stRfcnNnieParam.astSegData[0].astSrc[0].unShape.stWhc.u32Width,
+        s_stRfcnNnieParam.astSegData[0].astSrc[0].unShape.stWhc.u32Height,
+        s_stRfcnNnieParam.astSegData[0].astSrc[0].u32Stride);
+    LOGI("model.soft={ class=%u, ori.w=%u, ori.h=%u, nmsThresh=%u }\n",
+        s_stRfcnSoftwareParam.u32ClassNum,
+        s_stRfcnSoftwareParam.u32OriImWidth,
+        s_stRfcnSoftwareParam.u32OriImHeight,
+        s_stRfcnSoftwareParam.u32NmsThresh);
+
+    *model = self;
+    return 0;
+
+    FAIL_0:
+        SAMPLE_SVP_NNIE_Rfcn_Deinit(&s_stRfcnNnieParam, &s_stRfcnSoftwareParam, &s_stRfcnModel);
+        *model = NULL;
+        return -1;
+}
+
+/*
+    destroy rfcn model
+*/
+void RfcnDestroy(SAMPLE_SVP_NNIE_CFG_S *self)
+{
+    SAMPLE_SVP_NNIE_Rfcn_Deinit(&s_stRfcnNnieParam, &s_stRfcnSoftwareParam, &s_stRfcnModel);
+    free(self);
+}
+
+/*
+    fetch result
+*/
+void RfcnFetchRes(
+    SVP_BLOB_S *pstDstScore, SVP_BLOB_S *pstDstRoi, SVP_BLOB_S *pstClassRoiNum,
+    HI_FLOAT f32PrintResultThresh,
+    DetectObjInfo resBuf[], int resSize, int* resLen)
+{
+    HI_U32 i;
+    HI_U32 j;
+    HI_U32 u32RoiNumBias = 0;
+    HI_U32 u32ScoreBias;
+    HI_U32 u32BboxBias;
+    HI_FLOAT f32Score;
+    HI_S32* ps32Score = SAMPLE_SVP_NNIE_CONVERT_64BIT_ADDR(HI_S32, pstDstScore->u64VirAddr);
+    HI_S32* ps32Roi = SAMPLE_SVP_NNIE_CONVERT_64BIT_ADDR(HI_S32, pstDstRoi->u64VirAddr);
+    HI_S32* ps32ClassRoiNum = SAMPLE_SVP_NNIE_CONVERT_64BIT_ADDR(HI_S32, pstClassRoiNum->u64VirAddr);
+    HI_U32 u32ClassNum = pstClassRoiNum->unShape.stWhc.u32Width;
+
+    // yolo1_face2绫伙瀹涓1绫
+    /* print result, this sample has 21 classes:
+     class 0:background     class 1:plane           class 2:bicycle
+     class 3:bird           class 4:boat            class 5:bottle
+     class 6:bus            class 7:car             class 8:cat
+     class 9:chair          class10:cow             class11:diningtable
+     class 12:dog           class13:horse           class14:motorbike
+     class 15:person        class16:pottedplant     class17:sheep
+     class 18:sofa          class19:train           class20:tvmonitor */
+    assert(u32ClassNum == 2); // 2: the size of ClassNum
+    assert(resSize > 0);
+    int resId = 0;
+    *resLen = 0;
+
+    if (memset_s(resBuf, resSize * sizeof(resBuf[0]), 0x00, resSize * sizeof(resBuf[0])) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    u32RoiNumBias += ps32ClassRoiNum[0];
+    for (i = 1; i < u32ClassNum; i++) {
+        u32ScoreBias = u32RoiNumBias;
+        u32BboxBias = u32RoiNumBias * SAMPLE_SVP_NNIE_COORDI_NUM;
+
+        // if the confidence score greater than result threshold, the result will be printed
+        if ((HI_FLOAT)ps32Score[u32ScoreBias] / SAMPLE_SVP_NNIE_QUANT_BASE >=
+            f32PrintResultThresh && ps32ClassRoiNum[i] != 0) {
+        }
+
+        for (j = 0; j < (HI_U32)ps32ClassRoiNum[i]; j++) {
+            f32Score = (HI_FLOAT)ps32Score[u32ScoreBias + j] / SAMPLE_SVP_NNIE_QUANT_BASE;
+            if (f32Score < f32PrintResultThresh) {
+                break;
+            }
+            if (resId >= resSize) {
+                LOGE("rfcn resBuf full\n");
+                break;
+            }
+
+            resBuf[resId].cls = 1; // class 1
+            resBuf[resId].score = f32Score;
+
+            RectBox *box = &resBuf[resId].box;
+            box->xmin = ps32Roi[u32BboxBias + j * SAMPLE_SVP_NNIE_COORDI_NUM];
+            box->ymin = ps32Roi[u32BboxBias + j * SAMPLE_SVP_NNIE_COORDI_NUM + 1];
+            box->xmax = ps32Roi[u32BboxBias + j * SAMPLE_SVP_NNIE_COORDI_NUM + 2]; // 2: 扮涓缁
+            box->ymax = ps32Roi[u32BboxBias + j * SAMPLE_SVP_NNIE_COORDI_NUM + 3]; // 3: 扮涓缁
+            if (box->xmin >= box->xmax || box->ymin >= box->ymax) {
+                LOGD("rfcn_orig: {%d, %d, %d, %d}, %f, discard for coord ERR\n",
+                    box->xmin, box->ymin, box->xmax, box->ymax, f32Score);
+            } else {
+                LOGD("rfcn_orig: {%d, %d, %d, %d}, %f\n",
+                    box->xmin, box->ymin, box->xmax, box->ymax, f32Score);
+                resId++;
+            }
+        }
+        u32RoiNumBias += ps32ClassRoiNum[i];
+    }
+    *resLen = resId;
+}
+
+/*
+    璁＄涓寮U8C3 image
+*/
+int RfcnCalImg(SAMPLE_SVP_NNIE_CFG_S* self,
+    const IVE_IMAGE_S *img, float thresh, DetectObjInfo resBuf[], int resSize, int* resLen)
+{
+    thresh = thresh < 0 ? 0.6f : thresh;
+    HI_S32 s32Ret;
+
+    self->pszPic = NULL;
+
+    s32Ret = FillNnieByImg(self, &s_stRfcnNnieParam, 0, 0, img);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, FAIL_0, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_SVP_NNIE_FillSrcData failed!\n");
+
+    // NNIE process(process the 0-th segment)
+    // 姝ゅ芥板凡缁璋ㄤGetResult
+    s32Ret = SAMPLE_SVP_NNIE_Rfcn_Proc(&s_stRfcnNnieParam, &s_stRfcnSoftwareParam);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, FAIL_0, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_SVP_NNIE_Rfcn_Proc failed!\n");
+
+    RfcnFetchRes(&s_stRfcnSoftwareParam.stDstScore,
+        &s_stRfcnSoftwareParam.stDstRoi, &s_stRfcnSoftwareParam.stClassRoiNum,
+        thresh, resBuf, resSize, resLen);
+    return 0;
+
+    FAIL_0:
+        return -1;
+}
+
+/*
+    create yolo1 model based mode file
+*/
+int Yolo1Create(SAMPLE_SVP_NNIE_CFG_S **model, const char* modelFile)
+{
+    SAMPLE_SVP_NNIE_CFG_S *self;
+    HI_U32 u32PicNum = 1;
+    HI_S32 s32Ret;
+
+    self = (SAMPLE_SVP_NNIE_CFG_S*)malloc(sizeof(*self));
+    assert(self);
+
+    if (memset_s(self, sizeof(*self), 0x00, sizeof(*self))) {
+        HI_ASSERT(0);
+    }
+
+    // Set configuration parameter
+    self->pszPic = NULL;
+    self->u32MaxInputNum = u32PicNum; // max input image num in each batch
+    self->u32MaxRoiNum = 0;
+    self->aenNnieCoreId[0] = SVP_NNIE_ID_0; // set NNIE core
+
+    // Sys init
+    // Yolov1 Load model*/
+    SAMPLE_SVP_TRACE_INFO("Yolov1 Load model!\n");
+    s32Ret = SAMPLE_COMM_SVP_NNIE_LoadModel((char*)modelFile, &s_stYolov1Model);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, FAIL_0, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_COMM_SVP_NNIE_LoadModel failed!\n");
+
+    // Yolov1 parameter initialization
+    // Yolov1 software parameters are set in SAMPLE_SVP_NNIE_Yolov1_SoftwareInit,
+    //  if user has changed net struct, please make sure the parameter settings in
+    //  SAMPLE_SVP_NNIE_Yolov1_SoftwareInit function are correct
+    SAMPLE_SVP_TRACE_INFO("Yolov1 parameter initialization!\n");
+    s_stYolov1NnieParam.pstModel = &s_stYolov1Model.stModel;
+    s32Ret = SAMPLE_SVP_NNIE_Yolov1_ParamInit(self, &s_stYolov1NnieParam, &s_stYolov1SoftwareParam);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, FAIL_0, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_SVP_NNIE_Yolov1_ParamInit failed!\n");
+
+    // 妯″抽淇℃
+    LOGI("model.base={ type=%x, frmNum=%u, chnNum=%u, w=%u, h=%u, stride=%u }\n",
+        s_stYolov1NnieParam.astSegData[0].astSrc[0].enType,
+        s_stYolov1NnieParam.astSegData[0].astSrc[0].u32Num,
+        s_stYolov1NnieParam.astSegData[0].astSrc[0].unShape.stWhc.u32Chn,
+        s_stYolov1NnieParam.astSegData[0].astSrc[0].unShape.stWhc.u32Width,
+        s_stYolov1NnieParam.astSegData[0].astSrc[0].unShape.stWhc.u32Height,
+        s_stYolov1NnieParam.astSegData[0].astSrc[0].u32Stride);
+    LOGI("model.soft={ class=%u, ori.w=%u, ori.h=%u, bnum=%u, grid.w=%u, grid.h=%u, nmsThresh=%u, confThresh=%u }\n",
+        s_stYolov1SoftwareParam.u32ClassNum,
+        s_stYolov1SoftwareParam.u32OriImWidth,
+        s_stYolov1SoftwareParam.u32OriImHeight,
+        s_stYolov1SoftwareParam.u32BboxNumEachGrid,
+        s_stYolov1SoftwareParam.u32GridNumWidth,
+        s_stYolov1SoftwareParam.u32GridNumHeight,
+        s_stYolov1SoftwareParam.u32NmsThresh,
+        s_stYolov1SoftwareParam.u32ConfThresh);
+
+    *model = self;
+    return 0;
+
+    FAIL_0:
+        SAMPLE_SVP_NNIE_Yolov1_Deinit(&s_stYolov1NnieParam, &s_stYolov1SoftwareParam, &s_stYolov1Model);
+        *model = NULL;
+        return -1;
+}
+
+/*
+    destroy yolo1 model
+*/
+void Yolo1Destroy(SAMPLE_SVP_NNIE_CFG_S *self)
+{
+    SAMPLE_SVP_NNIE_Yolov1_Deinit(&s_stYolov1NnieParam, &s_stYolov1SoftwareParam, &s_stYolov1Model);
+    free(self);
+}
+
+/*
+    fetch result
+*/
+static void Yolo1FetchRes(
+    SVP_BLOB_S *pstDstScore, SVP_BLOB_S *pstDstRoi, SVP_BLOB_S *pstClassRoiNum,
+    HI_FLOAT f32PrintResultThresh,
+    DetectObjInfo resBuf[], int resSize, int* resLen)
+{
+    HI_U32 i;
+    HI_U32 j;
+    HI_U32 u32RoiNumBias = 0;
+    HI_U32 u32ScoreBias;
+    HI_U32 u32BboxBias;
+    HI_FLOAT f32Score;
+    HI_S32* ps32Score = SAMPLE_SVP_NNIE_CONVERT_64BIT_ADDR(HI_S32, pstDstScore->u64VirAddr);
+    HI_S32* ps32Roi = SAMPLE_SVP_NNIE_CONVERT_64BIT_ADDR(HI_S32, pstDstRoi->u64VirAddr);
+    HI_S32* ps32ClassRoiNum = SAMPLE_SVP_NNIE_CONVERT_64BIT_ADDR(HI_S32, pstClassRoiNum->u64VirAddr);
+    HI_U32 u32ClassNum = pstClassRoiNum->unShape.stWhc.u32Width;
+
+    // yolo1_face2绫伙瀹涓1绫
+    /* print result, this sample has 21 classes:
+     class 0:background     class 1:plane           class 2:bicycle
+     class 3:bird           class 4:boat            class 5:bottle
+     class 6:bus            class 7:car             class 8:cat
+     class 9:chair          class10:cow             class11:diningtable
+     class 12:dog           class13:horse           class14:motorbike
+     class 15:person        class16:pottedplant     class17:sheep
+     class 18:sofa          class19:train           class20:tvmonitor */
+    assert(u32ClassNum == 2); // 2: the size of ClassNum
+    assert(resSize > 0);
+    int resId = 0;
+    *resLen = 0;
+
+    if (memset_s(resBuf, resSize * sizeof(resBuf[0]), 0x00, resSize * sizeof(resBuf[0])) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    u32RoiNumBias += ps32ClassRoiNum[0];
+    for (i = 1; i < u32ClassNum; i++) {
+        u32ScoreBias = u32RoiNumBias;
+        u32BboxBias = u32RoiNumBias * SAMPLE_SVP_NNIE_COORDI_NUM;
+
+        // if the confidence score greater than result threshold, the result will be printed
+        if ((HI_FLOAT)ps32Score[u32ScoreBias] / SAMPLE_SVP_NNIE_QUANT_BASE >=
+            f32PrintResultThresh && ps32ClassRoiNum[i] != 0) {
+        }
+
+        for (j = 0; j < (HI_U32)ps32ClassRoiNum[i]; j++) {
+            f32Score = (HI_FLOAT)ps32Score[u32ScoreBias + j] / SAMPLE_SVP_NNIE_QUANT_BASE;
+            if (f32Score < f32PrintResultThresh) {
+                break;
+            }
+            if (resId >= resSize) {
+                LOGE("yolo1 resBuf full\n");
+                break;
+            }
+
+            resBuf[resId].cls = 1; // class 1
+            resBuf[resId].score = f32Score;
+
+            RectBox *box = &resBuf[resId].box;
+            box->xmin = ps32Roi[u32BboxBias + j * SAMPLE_SVP_NNIE_COORDI_NUM];
+            box->ymin = ps32Roi[u32BboxBias + j * SAMPLE_SVP_NNIE_COORDI_NUM + 1];
+            box->xmax = ps32Roi[u32BboxBias + j * SAMPLE_SVP_NNIE_COORDI_NUM + 2]; // 2锛扮涓缁
+            box->ymax = ps32Roi[u32BboxBias + j * SAMPLE_SVP_NNIE_COORDI_NUM + 3]; // 3: 扮涓缁
+            if (box->xmin >= box->xmax || box->ymin >= box->ymax) {
+                LOGD("yolo1_orig: {%d, %d, %d, %d}, %f, discard for coord ERR\n",
+                    box->xmin, box->ymin, box->xmax, box->ymax, f32Score);
+            } else {
+                LOGD("yolo1_orig: {%d, %d, %d, %d}, %f\n",
+                    box->xmin, box->ymin, box->xmax, box->ymax, f32Score);
+                resId++;
+            }
+        }
+        u32RoiNumBias += ps32ClassRoiNum[i];
+    }
+    *resLen = resId;
+}
+
+/*
+    dump result
+*/
+void Yolo1DumpRes(SVP_BLOB_S *pstDstScore,
+    SVP_BLOB_S *pstDstRoi, SVP_BLOB_S *pstClassRoiNum, HI_FLOAT f32PrintResultThresh)
+{
+    HI_U32 i;
+    HI_U32 j;
+    HI_U32 u32RoiNumBias = 0;
+    HI_U32 u32ScoreBias;
+    HI_U32 u32BboxBias;
+    HI_FLOAT f32Score;
+    HI_S32* ps32Score = SAMPLE_SVP_NNIE_CONVERT_64BIT_ADDR(HI_S32, pstDstScore->u64VirAddr);
+    HI_S32* ps32Roi = SAMPLE_SVP_NNIE_CONVERT_64BIT_ADDR(HI_S32, pstDstRoi->u64VirAddr);
+    HI_S32* ps32ClassRoiNum = SAMPLE_SVP_NNIE_CONVERT_64BIT_ADDR(HI_S32, pstClassRoiNum->u64VirAddr);
+    HI_U32 u32ClassNum = pstClassRoiNum->unShape.stWhc.u32Width;
+    HI_S32 s32XMin;
+    HI_S32 s32YMin;
+    HI_S32 s32XMax;
+    HI_S32 s32YMax;
+
+    /* print result, this sample has 21 classes:
+     class 0:background     class 1:plane           class 2:bicycle
+     class 3:bird           class 4:boat            class 5:bottle
+     class 6:bus            class 7:car             class 8:cat
+     class 9:chair          class10:cow             class11:diningtable
+     class 12:dog           class13:horse           class14:motorbike
+     class 15:person        class16:pottedplant     class17:sheep
+     class 18:sofa          class19:train           class20:tvmonitor */
+    u32RoiNumBias += ps32ClassRoiNum[0];
+    for (i = 1; i < u32ClassNum; i++) {
+        u32ScoreBias = u32RoiNumBias;
+        u32BboxBias = u32RoiNumBias * SAMPLE_SVP_NNIE_COORDI_NUM;
+        // if the confidence score greater than result threshold, the result will be printed
+        if ((HI_FLOAT)ps32Score[u32ScoreBias] / SAMPLE_SVP_NNIE_QUANT_BASE >=
+            f32PrintResultThresh && ps32ClassRoiNum[i] != 0) {
+            LOGD("yolo1_face detect %d\n", (int)ps32ClassRoiNum[i]);
+        }
+        for (j = 0; j < (HI_U32)ps32ClassRoiNum[i]; j++) {
+            f32Score = (HI_FLOAT)ps32Score[u32ScoreBias + j] / SAMPLE_SVP_NNIE_QUANT_BASE;
+            if (f32Score < f32PrintResultThresh) {
+                break;
+            }
+            s32XMin = ps32Roi[u32BboxBias + j*SAMPLE_SVP_NNIE_COORDI_NUM];
+            s32YMin = ps32Roi[u32BboxBias + j*SAMPLE_SVP_NNIE_COORDI_NUM + 1];
+            s32XMax = ps32Roi[u32BboxBias + j*SAMPLE_SVP_NNIE_COORDI_NUM + 2]; // 2锛扮涓缁
+            s32YMax = ps32Roi[u32BboxBias + j*SAMPLE_SVP_NNIE_COORDI_NUM + 3]; // 3: 扮涓缁
+            LOGD("yolo1_face: %f, {%d, %d, %d, %d}\n", f32Score, s32XMin, s32YMin, s32XMax, s32YMax);
+        }
+        u32RoiNumBias += ps32ClassRoiNum[i];
+    }
+}
+
+/*
+    璁＄涓寮U8C3 image
+*/
+int Yolo1CalImg(SAMPLE_SVP_NNIE_CFG_S* self,
+    const IVE_IMAGE_S *img, float thresh, DetectObjInfo resBuf[], int resSize, int* resLen)
+{
+    thresh = thresh < 0 ? 0.025f : thresh;
+    SAMPLE_SVP_NNIE_INPUT_DATA_INDEX_S stInputDataIdx = {0};
+    SAMPLE_SVP_NNIE_PROCESS_SEG_INDEX_S stProcSegIdx = {0};
+    HI_S32 s32Ret;
+
+    self->pszPic = NULL;
+    stInputDataIdx.u32SegIdx = 0;
+    stInputDataIdx.u32NodeIdx = 0;
+
+    s32Ret = FillNnieByImg(self, &s_stYolov1NnieParam, 0, 0, img);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, FAIL_0, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_SVP_NNIE_FillSrcData failed!\n");
+
+    // NNIE process(process the 0-th segment)
+    stProcSegIdx.u32SegIdx = 0;
+    s32Ret = SAMPLE_SVP_NNIE_Forward(&s_stYolov1NnieParam, &stInputDataIdx, &stProcSegIdx, HI_TRUE);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, FAIL_0, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_SVP_NNIE_Forward failed!\n");
+
+    // software process
+    // if user has changed net struct, please make sure SAMPLE_SVP_NNIE_Yolov1_GetResult
+    // function input datas are correct
+    s32Ret = SAMPLE_SVP_NNIE_Yolov1_GetResult(&s_stYolov1NnieParam, &s_stYolov1SoftwareParam);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, FAIL_0, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_SVP_NNIE_Yolov1_GetResult failed!\n");
+
+    Yolo1FetchRes(&s_stYolov1SoftwareParam.stDstScore,
+        &s_stYolov1SoftwareParam.stDstRoi, &s_stYolov1SoftwareParam.stClassRoiNum,
+        thresh, resBuf, resSize, resLen);
+    return 0;
+
+    FAIL_0:
+        return -1;
+}
+
+
+/******************************************************************************
+* function : Yolov2 software deinit
+******************************************************************************/
+static HI_S32 SAMPLE_SVP_NNIE_Yolov2_SoftwareDeinit(SAMPLE_SVP_NNIE_YOLOV2_SOFTWARE_PARAM_S* pstSoftWareParam)
+{
+    HI_S32 s32Ret = HI_SUCCESS;
+    SAMPLE_SVP_CHECK_EXPR_RET(NULL == pstSoftWareParam, HI_INVALID_VALUE, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error, pstSoftWareParam can't be NULL!\n");
+    if (pstSoftWareParam->stGetResultTmpBuf.u64PhyAddr != 0 && pstSoftWareParam->stGetResultTmpBuf.u64VirAddr != 0) {
+        SAMPLE_SVP_MMZ_FREE(pstSoftWareParam->stGetResultTmpBuf.u64PhyAddr,
+            pstSoftWareParam->stGetResultTmpBuf.u64VirAddr);
+        pstSoftWareParam->stGetResultTmpBuf.u64PhyAddr = 0;
+        pstSoftWareParam->stGetResultTmpBuf.u64VirAddr = 0;
+        pstSoftWareParam->stDstRoi.u64PhyAddr = 0;
+        pstSoftWareParam->stDstRoi.u64VirAddr = 0;
+        pstSoftWareParam->stDstScore.u64PhyAddr = 0;
+        pstSoftWareParam->stDstScore.u64VirAddr = 0;
+        pstSoftWareParam->stClassRoiNum.u64PhyAddr = 0;
+        pstSoftWareParam->stClassRoiNum.u64VirAddr = 0;
+    }
+    return s32Ret;
+}
+
+/******************************************************************************
+* function : Yolov2 Deinit
+******************************************************************************/
+static HI_S32 SAMPLE_SVP_NNIE_Yolov2_Deinit(SAMPLE_SVP_NNIE_PARAM_S *pstNnieParam,
+    SAMPLE_SVP_NNIE_YOLOV2_SOFTWARE_PARAM_S* pstSoftWareParam, SAMPLE_SVP_NNIE_MODEL_S *pstNnieModel)
+{
+    HI_S32 s32Ret = HI_SUCCESS;
+    /* hardware deinit */
+    if (pstNnieParam != NULL) {
+        s32Ret = SAMPLE_COMM_SVP_NNIE_ParamDeinit(pstNnieParam);
+        SAMPLE_SVP_CHECK_EXPR_TRACE(HI_SUCCESS != s32Ret, SAMPLE_SVP_ERR_LEVEL_ERROR,
+            "Error,SAMPLE_COMM_SVP_NNIE_ParamDeinit failed!\n");
+    }
+    /* software deinit */
+    if (pstSoftWareParam != NULL) {
+        s32Ret = SAMPLE_SVP_NNIE_Yolov2_SoftwareDeinit(pstSoftWareParam);
+        SAMPLE_SVP_CHECK_EXPR_TRACE(HI_SUCCESS != s32Ret, SAMPLE_SVP_ERR_LEVEL_ERROR,
+            "Error,SAMPLE_SVP_NNIE_Yolov2_SoftwareDeinit failed!\n");
+    }
+    /* model deinit */
+    if (pstNnieModel != NULL) {
+        s32Ret = SAMPLE_COMM_SVP_NNIE_UnloadModel(pstNnieModel);
+        SAMPLE_SVP_CHECK_EXPR_TRACE(HI_SUCCESS != s32Ret, SAMPLE_SVP_ERR_LEVEL_ERROR,
+            "Error,SAMPLE_COMM_SVP_NNIE_UnloadModel failed!\n");
+    }
+    return s32Ret;
+}
+
+/******************************************************************************
+* function : Yolov2 software para init
+******************************************************************************/
+static HI_S32 SAMPLE_SVP_NNIE_Yolov2_SoftwareInit(SAMPLE_SVP_NNIE_CFG_S* pstCfg,
+    SAMPLE_SVP_NNIE_PARAM_S *pstNnieParam, SAMPLE_SVP_NNIE_YOLOV2_SOFTWARE_PARAM_S* pstSoftWareParam)
+{
+    HI_S32 s32Ret;
+    HI_U32 u32ClassNum = 0;
+    HI_U32 u32BboxNum;
+    HI_U32 u32TotalSize = 0;
+    HI_U32 u32DstRoiSize;
+    HI_U32 u32DstScoreSize;
+    HI_U32 u32ClassRoiNumSize;
+    HI_U32 u32TmpBufTotalSize;
+    HI_U64 u64PhyAddr = 0;
+    HI_U8* pu8VirAddr = NULL;
+
+    pstSoftWareParam->u32OriImHeight = pstNnieParam->astSegData[0].astSrc[0].unShape.stWhc.u32Height;
+    pstSoftWareParam->u32OriImWidth = pstNnieParam->astSegData[0].astSrc[0].unShape.stWhc.u32Width;
+    pstSoftWareParam->u32BboxNumEachGrid = 5;
+    pstSoftWareParam->u32ClassNum = 1;
+    pstSoftWareParam->u32GridNumHeight = 12;
+    pstSoftWareParam->u32GridNumWidth = 20;
+    pstSoftWareParam->u32NmsThresh = (HI_U32)(0.3f*SAMPLE_SVP_NNIE_QUANT_BASE);
+    pstSoftWareParam->u32ConfThresh = (HI_U32)(0.25f*SAMPLE_SVP_NNIE_QUANT_BASE);
+    pstSoftWareParam->u32MaxRoiNum = 10;
+    pstSoftWareParam->af32Bias[0] = 0.52;
+    pstSoftWareParam->af32Bias[1] = 0.61;
+    pstSoftWareParam->af32Bias[2] = 1.05;
+    pstSoftWareParam->af32Bias[3] = 1.12;
+    pstSoftWareParam->af32Bias[4] = 1.85;
+    pstSoftWareParam->af32Bias[5] = 2.05;
+    pstSoftWareParam->af32Bias[6] = 4.63;
+    pstSoftWareParam->af32Bias[7] = 4.49;
+    pstSoftWareParam->af32Bias[8] = 7.15;
+    pstSoftWareParam->af32Bias[9] = 7.56;
+
+    /* Malloc assist buffer memory */
+    u32ClassNum = pstSoftWareParam->u32ClassNum + 1;
+    u32BboxNum = pstSoftWareParam->u32BboxNumEachGrid*pstSoftWareParam->u32GridNumHeight*
+        pstSoftWareParam->u32GridNumWidth;
+    u32TmpBufTotalSize = SAMPLE_SVP_NNIE_Yolov2_GetResultTmpBuf(pstNnieParam, pstSoftWareParam);
+    u32DstRoiSize = SAMPLE_SVP_NNIE_ALIGN16(u32ClassNum*u32BboxNum*sizeof(HI_U32)*SAMPLE_SVP_NNIE_COORDI_NUM);
+    u32DstScoreSize = SAMPLE_SVP_NNIE_ALIGN16(u32ClassNum*u32BboxNum*sizeof(HI_U32));
+    u32ClassRoiNumSize = SAMPLE_SVP_NNIE_ALIGN16(u32ClassNum*sizeof(HI_U32));
+    u32TotalSize = u32TotalSize+u32DstRoiSize+u32DstScoreSize+u32ClassRoiNumSize + u32TmpBufTotalSize;
+    s32Ret = SAMPLE_COMM_SVP_MallocCached("SAMPLE_YOLOV2_INIT", NULL, (HI_U64*)&u64PhyAddr,
+        (void**)&pu8VirAddr,u32TotalSize);
+    SAMPLE_SVP_CHECK_EXPR_RET(HI_SUCCESS != s32Ret, s32Ret, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,Malloc memory failed!\n");
+    memset(pu8VirAddr, 0, u32TotalSize);
+    SAMPLE_COMM_SVP_FlushCache(u64PhyAddr, (void*)pu8VirAddr, u32TotalSize);
+
+   /* set each tmp buffer addr */
+    pstSoftWareParam->stGetResultTmpBuf.u64PhyAddr = u64PhyAddr;
+    pstSoftWareParam->stGetResultTmpBuf.u64VirAddr = (HI_U64)((HI_UL)pu8VirAddr);
+
+    /* set result blob */
+    pstSoftWareParam->stDstRoi.enType = SVP_BLOB_TYPE_S32;
+    pstSoftWareParam->stDstRoi.u64PhyAddr = u64PhyAddr + u32TmpBufTotalSize;
+    pstSoftWareParam->stDstRoi.u64VirAddr = (HI_U64)((HI_UL)pu8VirAddr + u32TmpBufTotalSize);
+    pstSoftWareParam->stDstRoi.u32Stride = SAMPLE_SVP_NNIE_ALIGN16(u32ClassNum*
+        u32BboxNum*sizeof(HI_U32)*SAMPLE_SVP_NNIE_COORDI_NUM);
+    pstSoftWareParam->stDstRoi.u32Num = 1;
+    pstSoftWareParam->stDstRoi.unShape.stWhc.u32Chn = 1;
+    pstSoftWareParam->stDstRoi.unShape.stWhc.u32Height = 1;
+    pstSoftWareParam->stDstRoi.unShape.stWhc.u32Width = u32ClassNum*
+        u32BboxNum*SAMPLE_SVP_NNIE_COORDI_NUM;
+
+    pstSoftWareParam->stDstScore.enType = SVP_BLOB_TYPE_S32;
+    pstSoftWareParam->stDstScore.u64PhyAddr = u64PhyAddr+u32TmpBufTotalSize + u32DstRoiSize;
+    pstSoftWareParam->stDstScore.u64VirAddr = (HI_U64)((HI_UL)pu8VirAddr+u32TmpBufTotalSize + u32DstRoiSize);
+    pstSoftWareParam->stDstScore.u32Stride = SAMPLE_SVP_NNIE_ALIGN16(u32ClassNum*
+        u32BboxNum*sizeof(HI_U32));
+    pstSoftWareParam->stDstScore.u32Num = 1;
+    pstSoftWareParam->stDstScore.unShape.stWhc.u32Chn = 1;
+    pstSoftWareParam->stDstScore.unShape.stWhc.u32Height = 1;
+    pstSoftWareParam->stDstScore.unShape.stWhc.u32Width = u32ClassNum*u32BboxNum;
+
+    pstSoftWareParam->stClassRoiNum.enType = SVP_BLOB_TYPE_S32;
+    pstSoftWareParam->stClassRoiNum.u64PhyAddr = u64PhyAddr + u32TmpBufTotalSize+
+        u32DstRoiSize + u32DstScoreSize;
+    pstSoftWareParam->stClassRoiNum.u64VirAddr = (HI_U64)((HI_UL)pu8VirAddr + u32TmpBufTotalSize +
+        u32DstRoiSize + u32DstScoreSize);
+    pstSoftWareParam->stClassRoiNum.u32Stride = SAMPLE_SVP_NNIE_ALIGN16(u32ClassNum*sizeof(HI_U32));
+    pstSoftWareParam->stClassRoiNum.u32Num = 1;
+    pstSoftWareParam->stClassRoiNum.unShape.stWhc.u32Chn = 1;
+    pstSoftWareParam->stClassRoiNum.unShape.stWhc.u32Height = 1;
+    pstSoftWareParam->stClassRoiNum.unShape.stWhc.u32Width = u32ClassNum;
+
+    return s32Ret;
+}
+
+/******************************************************************************
+* function : Yolov1 init
+******************************************************************************/
+static HI_S32 SAMPLE_SVP_NNIE_Yolov2_ParamInit(SAMPLE_SVP_NNIE_CFG_S* pstCfg,
+    SAMPLE_SVP_NNIE_PARAM_S *pstNnieParam, SAMPLE_SVP_NNIE_YOLOV2_SOFTWARE_PARAM_S* pstSoftWareParam)
+{
+    HI_S32 s32Ret;
+    /* init hardware para */
+    s32Ret = SAMPLE_COMM_SVP_NNIE_ParamInit(pstCfg, pstNnieParam);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, INIT_FAIL_0, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error(%#x),SAMPLE_COMM_SVP_NNIE_ParamInit failed!\n", s32Ret);
+
+    /* init software para */
+    s32Ret = SAMPLE_SVP_NNIE_Yolov2_SoftwareInit(pstCfg, pstNnieParam,
+        pstSoftWareParam);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, INIT_FAIL_0, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error(%#x),SAMPLE_SVP_NNIE_Yolov1_SoftwareInit failed!\n", s32Ret);
+    return s32Ret;
+INIT_FAIL_0:
+    s32Ret = SAMPLE_SVP_NNIE_Yolov2_Deinit(pstNnieParam, pstSoftWareParam,NULL);
+    SAMPLE_SVP_CHECK_EXPR_RET(HI_SUCCESS != s32Ret, s32Ret, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error(%#x),SAMPLE_SVP_NNIE_Yolov1_Deinit failed!\n", s32Ret);
+    return HI_FAILURE;
+
+}
+
+/******************************************************************************
+* function : creat yolo2 model basad mode file
+******************************************************************************/
+int Yolo2Create(SAMPLE_SVP_NNIE_CFG_S **model, const char* modelFile)
+{
+    SAMPLE_SVP_NNIE_CFG_S *self;
+    HI_U32 u32PicNum = 1;
+    HI_S32 s32Ret;
+
+    self = (SAMPLE_SVP_NNIE_CFG_S*)malloc(sizeof(*self));
+    assert(self);
+    memset(self, 0x00, sizeof(*self));
+
+    // Set configuration parameter
+    self->pszPic = NULL;
+    self->u32MaxInputNum = u32PicNum; // max input image num in each batch
+    self->u32MaxRoiNum = 0;
+    self->aenNnieCoreId[0] = SVP_NNIE_ID_0; // set NNIE core
+ 
+    // Yolov2 Load model
+    SAMPLE_SVP_TRACE_INFO("Yolov2 Load model!\n");
+    s32Ret = SAMPLE_COMM_SVP_NNIE_LoadModel((char*)modelFile, &s_stYolov2Model);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, YOLOV2_FAIL_0, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error, SAMPLE_COMM_SVP_NNIE_LoadModel failed!\n");
+
+    /* Yolov2 parameter initialization */
+    /* Yolov2 software parameters are set in SAMPLE_SVP_NNIE_Yolov2_SoftwareInit,
+      if user has changed net struct, please make sure the parameter settings in
+      SAMPLE_SVP_NNIE_Yolov2_SoftwareInit function are correct */
+    SAMPLE_SVP_TRACE_INFO("Yolov2 parameter initialization!\n");
+    s_stYolov2NnieParam.pstModel = &s_stYolov2Model.stModel;
+    s32Ret = SAMPLE_SVP_NNIE_Yolov2_ParamInit(self, &s_stYolov2NnieParam, &s_stYolov2SoftwareParam);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, YOLOV2_FAIL_0, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_SVP_NNIE_Yolov2_ParamInit failed!\n");
+
+    // model important info
+    LOGI("model.base={ type=%x, frmNum=%u, chnNum=%u, w=%u, h=%u, stride=%u }\n",
+        s_stYolov2NnieParam.astSegData[0].astSrc[0].enType,
+        s_stYolov2NnieParam.astSegData[0].astSrc[0].u32Num,
+        s_stYolov2NnieParam.astSegData[0].astSrc[0].unShape.stWhc.u32Chn,
+        s_stYolov2NnieParam.astSegData[0].astSrc[0].unShape.stWhc.u32Width,
+        s_stYolov2NnieParam.astSegData[0].astSrc[0].unShape.stWhc.u32Height,
+        s_stYolov2NnieParam.astSegData[0].astSrc[0].u32Stride);
+    LOGI("model.soft={ class=%u, ori.w=%u, ori.h=%u, bnum=%u, grid.w=%u, grid.h=%u, nmsThresh=%u, confThresh=%u, u32MaxRoiNum=%u }\n",
+        s_stYolov2SoftwareParam.u32ClassNum,
+        s_stYolov2SoftwareParam.u32OriImWidth,
+        s_stYolov2SoftwareParam.u32OriImHeight,
+        s_stYolov2SoftwareParam.u32BboxNumEachGrid,
+        s_stYolov2SoftwareParam.u32GridNumWidth,
+        s_stYolov2SoftwareParam.u32GridNumHeight,
+        s_stYolov2SoftwareParam.u32NmsThresh,
+        s_stYolov2SoftwareParam.u32ConfThresh,
+        s_stYolov2SoftwareParam.u32MaxRoiNum);
+
+    *model = self;
+    return 0;
+
+    YOLOV2_FAIL_0:
+        LOGI("Yolo2Create SAMPLE_SVP_NNIE_Yolov2_Deinit\n");
+        SAMPLE_SVP_NNIE_Yolov2_Deinit(&s_stYolov2NnieParam, &s_stYolov2SoftwareParam, &s_stYolov2Model);
+        *model = NULL;
+        return -1;
+}
+
+/******************************************************************************
+* function : destory yolo2 model
+******************************************************************************/
+void Yolo2Destory(SAMPLE_SVP_NNIE_CFG_S *self)
+{
+    SAMPLE_SVP_NNIE_Yolov2_Deinit(&s_stYolov2NnieParam, &s_stYolov2SoftwareParam, &s_stYolov2Model);
+    SAMPLE_COMM_SVP_CheckSysExit();
+    free(self);
+}
+
+/******************************************************************************
+* function : fetch result
+******************************************************************************/
+static void Yolo2FetchRes(
+    SVP_BLOB_S *pstDstScore, SVP_BLOB_S *pstDstRoi, SVP_BLOB_S *pstClassRoiNum, 
+    HI_FLOAT f32PrintResultThresh,
+    DetectObjInfo resBuf[], int resSize, int* resLen)
+{
+    HI_U32 i;
+    HI_U32 j;
+    HI_U32 u32RoiNumBias = 0;
+    HI_U32 u32ScoreBias = 0;
+    HI_U32 u32BboxBias = 0;
+    HI_FLOAT f32Score = 0.0f;
+    HI_S32* ps32Score = SAMPLE_SVP_NNIE_CONVERT_64BIT_ADDR(HI_S32,pstDstScore->u64VirAddr);
+    HI_S32* ps32Roi = SAMPLE_SVP_NNIE_CONVERT_64BIT_ADDR(HI_S32,pstDstRoi->u64VirAddr);
+    HI_S32* ps32ClassRoiNum = SAMPLE_SVP_NNIE_CONVERT_64BIT_ADDR(HI_S32,pstClassRoiNum->u64VirAddr);
+    HI_U32 u32ClassNum = pstClassRoiNum->unShape.stWhc.u32Width;
+
+    assert(u32ClassNum == 2);
+    assert(resSize > 0);
+    int resId = 0;
+    *resLen = 0;
+    memset(resBuf, 0x00, resSize * sizeof(resBuf[0]));
+
+    u32RoiNumBias += ps32ClassRoiNum[0];
+    for (i = 1; i < u32ClassNum; i++) {
+        u32ScoreBias = u32RoiNumBias;
+        u32BboxBias = u32RoiNumBias * SAMPLE_SVP_NNIE_COORDI_NUM;
+        /* if the confidence score greater than result threshold, the result will be printed */
+        if((HI_FLOAT)ps32Score[u32ScoreBias] / SAMPLE_SVP_NNIE_QUANT_BASE >=
+            f32PrintResultThresh && ps32ClassRoiNum[i] != 0) {
+        }
+        for (j = 0; j < (HI_U32)ps32ClassRoiNum[i]; j++) {
+            f32Score = (HI_FLOAT)ps32Score[u32ScoreBias + j] / SAMPLE_SVP_NNIE_QUANT_BASE;
+            if (f32Score < f32PrintResultThresh) {
+                LOGI("f32Score:%.2f\n", f32Score);
+                break;
+            }
+            if (resId >= resSize) {
+                LOGE("yolo2 resBuf full\n");
+                break;
+            }
+            resBuf[resId].cls = 1; // class 1
+            resBuf[resId].score = f32Score;
+
+            RectBox *box = &resBuf[resId].box;
+            box->xmin = ps32Roi[u32BboxBias + j * SAMPLE_SVP_NNIE_COORDI_NUM];
+            box->ymin = ps32Roi[u32BboxBias + j * SAMPLE_SVP_NNIE_COORDI_NUM + 1];
+            box->xmax = ps32Roi[u32BboxBias + j * SAMPLE_SVP_NNIE_COORDI_NUM + 2];
+            box->ymax = ps32Roi[u32BboxBias + j * SAMPLE_SVP_NNIE_COORDI_NUM + 3];
+            if (box->xmin >= box->xmax || box->ymin >= box->ymax) {
+                LOGD("yolo1_orig: {%d, %d, %d, %d}, %f, discard for coord ERR\n", 
+                    box->xmin, box->ymin, box->xmax, box->ymax, f32Score);
+            } else {
+                LOGD("yolo1_orig: {%d, %d, %d, %d}, %f\n", 
+                    box->xmin, box->ymin, box->xmax, box->ymax, f32Score);
+                resId++;
+            }
+        }
+        u32RoiNumBias += ps32ClassRoiNum[i];
+    }
+
+    *resLen = resId;
+}
+
+/******************************************************************************
+* function : cal U8C3 image
+******************************************************************************/
+int Yolo2CalImg(SAMPLE_SVP_NNIE_CFG_S* self, 
+    const IVE_IMAGE_S *img, float thresh, DetectObjInfo resBuf[], int resSize, int* resLen)
+{
+    thresh = thresh < 0 ? 0.025f : thresh;
+    SAMPLE_SVP_NNIE_INPUT_DATA_INDEX_S stInputDataIdx = {0};
+    SAMPLE_SVP_NNIE_PROCESS_SEG_INDEX_S stProcSegIdx = {0};
+    HI_S32 s32Ret;
+
+    // Fill src data
+    self->pszPic = NULL;
+    stInputDataIdx.u32SegIdx = 0;
+    stInputDataIdx.u32NodeIdx = 0;
+
+    s32Ret = FillNnieByImg(self, &s_stYolov2NnieParam, 0, 0, img);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, YOLOV2_FAIL_0,SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_SVP_NNIE_FillSrcData failed!\n");
+
+    // NNIE process(process the 0-th segment)
+    stProcSegIdx.u32SegIdx = 0;
+    s32Ret = SAMPLE_SVP_NNIE_Forward(&s_stYolov2NnieParam, &stInputDataIdx, &stProcSegIdx,HI_TRUE);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret, YOLOV2_FAIL_0, SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_SVP_NNIE_Forward failed!\n");
+    
+    /* Software process */
+    /* if user has changed net struct, please make sure SAMPLE_SVP_NNIE_Yolov2_GetResult
+     function input datas are correct */
+    s32Ret = SAMPLE_SVP_NNIE_Yolov2_GetResult(&s_stYolov2NnieParam,&s_stYolov2SoftwareParam);
+    SAMPLE_SVP_CHECK_EXPR_GOTO(HI_SUCCESS != s32Ret,YOLOV2_FAIL_0,SAMPLE_SVP_ERR_LEVEL_ERROR,
+        "Error,SAMPLE_SVP_NNIE_Yolov2_GetResult failed!\n");
+
+    Yolo2FetchRes(&s_stYolov2SoftwareParam.stDstScore,
+        &s_stYolov2SoftwareParam.stDstRoi, &s_stYolov2SoftwareParam.stClassRoiNum,
+        thresh, resBuf, resSize, resLen);
+    return 0;
+
+    YOLOV2_FAIL_0:
+        return -1;
+}
\ 浠跺熬娌℃㈣绗
diff -urpBN hiopenais/src/plug_demo/nnie_sample_plug/nnie_sample_plug.h hiopenais_modify/src/plug_demo/nnie_sample_plug/nnie_sample_plug.h
--- hiopenais/src/plug_demo/nnie_sample_plug/nnie_sample_plug.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/plug_demo/nnie_sample_plug/nnie_sample_plug.h	2021-07-01 19:01:32.000000000 -0700
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef NNIE_SAMPLE_PLUG_H
+#define NNIE_SAMPLE_PLUG_H
+
+#include <stdint.h>
+#include "hi_type.h"
+#include "sample_comm_nnie.h"
+#include "mpp_help.h"
+#include "ai_plug.h"
+
+#ifdef __cplusplus
+extern "C"{
+#endif /* __cplusplus */
+
+/******************************************************************************
+    补充的类型
+******************************************************************************/
+/**
+    识别的数字的信息.
+*/
+typedef struct RecogNumInfo {
+    uint32_t num; // 识别的数字值，0~9
+    uint32_t score; // 数字的可信度得分，其取值范围由具体的模型定义
+}   RecogNumInfo;
+
+/**
+    检测到的物体的信息.
+*/
+typedef struct DetectObjInfo {
+    int cls; // 物体的类别，>0的整数
+    RectBox box; // 物体的矩形区域(像素)
+    float score; // 物体的可信度得分
+}   DetectObjInfo;
+
+/******************************************************************************
+    将计算结果打包为约定格式的JSON的工具函数.
+******************************************************************************/
+char* DetectObjsToJson(const DetectObjInfo items[], int itemNum, int* resBytes);
+
+/******************************************************************************
+    nnie sample to HiOpenAIS plugs
+******************************************************************************/
+/*
+    create CNN model based mode file
+*/
+int CnnCreate(SAMPLE_SVP_NNIE_CFG_S **model, const char* modelFile);
+
+/*
+    destroy CNN model
+*/
+void CnnDestroy(SAMPLE_SVP_NNIE_CFG_S *self);
+
+/*
+    计算一张U8C1 image
+*/
+int CnnCalU8c1Img(SAMPLE_SVP_NNIE_CFG_S* self,
+    const IVE_IMAGE_S *img, RecogNumInfo resBuf[], int resSize, int* resLen);
+
+/*
+    计算一张U8C1 file
+*/
+int CnnCalU8c1File(SAMPLE_SVP_NNIE_CFG_S* self, const char* picFileName);
+
+/**
+    load model函数类型.
+*/
+typedef int (*LoadModelFunc)(SAMPLE_SVP_NNIE_MODEL_S *model, const char* modelFile);
+
+/*
+    create rfcn model based mode file
+*/
+int RfcnCreate(SAMPLE_SVP_NNIE_CFG_S **model, const char* modelFile, LoadModelFunc loadFunc);
+
+/*
+    destroy rfcn model
+*/
+void RfcnDestroy(SAMPLE_SVP_NNIE_CFG_S *self);
+
+/*
+    计算一张U8C3 image
+*/
+int RfcnCalImg(SAMPLE_SVP_NNIE_CFG_S* self,
+    const IVE_IMAGE_S *img, float thresh, DetectObjInfo resBuf[], int resSize, int* resLen);
+
+/*
+    create yolo1 model based mode file
+*/
+int Yolo1Create(SAMPLE_SVP_NNIE_CFG_S **model, const char* modelFile);
+
+/*
+    destroy yolo1 model
+*/
+void Yolo1Destroy(SAMPLE_SVP_NNIE_CFG_S *self);
+
+/*
+    计算一张image
+*/
+int Yolo1CalImg(SAMPLE_SVP_NNIE_CFG_S* self,
+    const IVE_IMAGE_S *img, float thresh, DetectObjInfo resBuf[], int resSize, int* resLen);
+
+
+/*
+    create yolo2 model based mode file
+*/
+int Yolo2Create(SAMPLE_SVP_NNIE_CFG_S **model, const char* modelFile);
+
+/*
+    destory yolo2 model
+*/
+void Yolo2Destory(SAMPLE_SVP_NNIE_CFG_S *self);
+
+/*
+    cal U8C3 image
+*/
+int Yolo2CalImg(SAMPLE_SVP_NNIE_CFG_S* self,
+    const IVE_IMAGE_S *img, float thresh, DetectObjInfo resBuf[], int resSize, int* resLen);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __NNIE_SAMPLE_PLUG_H */
diff -urpBN hiopenais/src/plug_demo/tennis_detect/tennis_detect.cpp hiopenais_modify/src/plug_demo/tennis_detect/tennis_detect.cpp
--- hiopenais/src/plug_demo/tennis_detect/tennis_detect.cpp	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/plug_demo/tennis_detect/tennis_detect.cpp	2021-06-01 04:56:20.000000000 -0700
@@ -0,0 +1,266 @@
+#include <iostream>
+#include <opencv2/core.hpp>
+#include <opencv2/highgui.hpp>
+#include <opencv2/imgproc.hpp>
+
+#include "hi_ext_util.h"
+#include "mpp_help.h"
+#include "ai_plug.h"
+
+#include "sample_comm_nnie.h"
+#include "nnie_sample_plug.h"
+
+using namespace std;
+using namespace cv;
+
+#define PLUG_UUID          "\"hi.tennis_detect\""
+#define PLUG_DESC          "\"缃妫娴(浼缁绠瀛)\""  // UTF8 encode
+
+#define FRM_WIDTH          640
+#define FRM_HEIGHT         480
+#define TENNIS_OBJ_MAX     256
+#define DRAW_RETC_THICK    2
+
+static OsdSet* g_osdsTennis = NULL;
+static int g_osd0Tennis = -1;
+
+static const char TENNIS_DETECT[] = "{"
+    "\"uuid\": " PLUG_UUID ","
+    "\"desc\": " PLUG_DESC ","
+    "\"frmWidth\": " HI_TO_STR(FRM_WIDTH) ","
+    "\"frmHeight\": " HI_TO_STR(FRM_HEIGHT) ","
+    "\"butt\": 0"
+"}";
+
+static const char* TennisDetectProf(void)
+{
+    return TENNIS_DETECT;
+}
+
+static int TennisDetectLoad(uintptr_t* model, OsdSet* osds)
+{
+    HI_S32 ret = 1;
+
+    g_osdsTennis = osds;
+    HI_ASSERT(g_osdsTennis);
+    g_osd0Tennis = OsdsCreateRgn(g_osdsTennis);
+    HI_ASSERT(g_osd0Tennis >= 0);
+    *model = 1;
+    LOGI("TennisDetectLoad success\n");
+	
+	return ret;
+}
+
+static int TennisDetectUnload(uintptr_t model)
+{
+    (void)model;
+    OsdsClear(g_osdsTennis);
+	
+    return HI_SUCCESS;
+}
+
+typedef struct tagIPC_IMAGE{
+    HI_U64 u64PhyAddr;
+    HI_U64 u64VirAddr;
+    HI_U32 u32Width;
+    HI_U32 u32Height;
+} IPC_IMAGE;
+
+HI_S32 yuvFrame2rgb(VIDEO_FRAME_INFO_S *srcFrame, IPC_IMAGE *dstImage)
+{
+    IVE_HANDLE hIveHandle;
+    IVE_SRC_IMAGE_S pstSrc;
+    IVE_DST_IMAGE_S pstDst;
+    IVE_CSC_CTRL_S stCscCtrl;
+    HI_S32 s32Ret = 0;
+    stCscCtrl.enMode = IVE_CSC_MODE_PIC_BT709_YUV2RGB; //IVE_CSC_MODE_VIDEO_BT601_YUV2RGB;
+    pstSrc.enType = IVE_IMAGE_TYPE_YUV420SP;
+    pstSrc.au64VirAddr[0] = srcFrame->stVFrame.u64VirAddr[0];
+    pstSrc.au64VirAddr[1] = srcFrame->stVFrame.u64VirAddr[1];
+    pstSrc.au64VirAddr[2] = srcFrame->stVFrame.u64VirAddr[2];
+ 
+    pstSrc.au64PhyAddr[0] = srcFrame->stVFrame.u64PhyAddr[0];
+    pstSrc.au64PhyAddr[1] = srcFrame->stVFrame.u64PhyAddr[1];
+    pstSrc.au64PhyAddr[2] = srcFrame->stVFrame.u64PhyAddr[2];
+ 
+    pstSrc.au32Stride[0] = srcFrame->stVFrame.u32Stride[0];
+    pstSrc.au32Stride[1] = srcFrame->stVFrame.u32Stride[1];
+    pstSrc.au32Stride[2] = srcFrame->stVFrame.u32Stride[2];
+ 
+    pstSrc.u32Width = srcFrame->stVFrame.u32Width;
+    pstSrc.u32Height = srcFrame->stVFrame.u32Height;
+ 
+    pstDst.enType = IVE_IMAGE_TYPE_U8C3_PACKAGE;
+    pstDst.u32Width = pstSrc.u32Width;
+    pstDst.u32Height = pstSrc.u32Height;
+    pstDst.au32Stride[0] = pstSrc.au32Stride[0];
+    pstDst.au32Stride[1] = 0;
+    pstDst.au32Stride[2] = 0;
+
+    s32Ret = HI_MPI_SYS_MmzAlloc_Cached(&pstDst.au64PhyAddr[0], (void **)&pstDst.au64VirAddr[0],
+        "User", HI_NULL, pstDst.u32Height*pstDst.au32Stride[0] * 3);
+    if (HI_SUCCESS != s32Ret) {       
+        HI_MPI_SYS_MmzFree(pstDst.au64PhyAddr[0], (void *)pstDst.au64VirAddr[0]);
+        LOGE("HI_MPI_SYS_MmzFree err\n");
+        return s32Ret;
+    }
+
+    s32Ret = HI_MPI_SYS_MmzFlushCache(pstDst.au64PhyAddr[0], (void *)pstDst.au64VirAddr[0],
+        pstDst.u32Height*pstDst.au32Stride[0]*3);
+    if (HI_SUCCESS != s32Ret) {       
+        HI_MPI_SYS_MmzFree(pstDst.au64PhyAddr[0], (void *)pstDst.au64VirAddr[0]);
+        return s32Ret;
+    }
+    memset((void *)pstDst.au64VirAddr[0], 0, pstDst.u32Height*pstDst.au32Stride[0]*3);
+    HI_BOOL bInstant = HI_TRUE;
+
+    s32Ret = HI_MPI_IVE_CSC(&hIveHandle, &pstSrc, &pstDst, &stCscCtrl, bInstant);
+    if(HI_SUCCESS != s32Ret) {       
+        HI_MPI_SYS_MmzFree(pstDst.au64PhyAddr[0], (void *)pstDst.au64VirAddr[0]);
+        return s32Ret;
+    }
+
+    if (HI_TRUE == bInstant) {
+        HI_BOOL bFinish = HI_TRUE;
+        HI_BOOL bBlock = HI_TRUE;
+        s32Ret = HI_MPI_IVE_Query(hIveHandle, &bFinish, bBlock);
+        while (HI_ERR_IVE_QUERY_TIMEOUT == s32Ret) {
+            usleep(100);
+            s32Ret = HI_MPI_IVE_Query(hIveHandle,&bFinish,bBlock);
+        }
+    }
+    dstImage->u64PhyAddr = pstDst.au64PhyAddr[0];
+    dstImage->u64VirAddr = pstDst.au64VirAddr[0];
+    dstImage->u32Width = pstDst.u32Width;
+    dstImage->u32Height = pstDst.u32Height;
+
+    return HI_SUCCESS;
+}
+
+HI_S32 frame2Mat(VIDEO_FRAME_INFO_S *srcFrame, Mat &dstMat)
+{
+    HI_U32 w = srcFrame->stVFrame.u32Width;
+    HI_U32 h = srcFrame->stVFrame.u32Height;
+    int bufLen = w * h * 3;
+    HI_U8 *srcRGB = NULL;
+    IPC_IMAGE dstImage;
+    if (yuvFrame2rgb(srcFrame, &dstImage) != HI_SUCCESS) {
+        LOGE("yuvFrame2rgb err\n");
+        return HI_FAILURE;
+    }
+    srcRGB = (HI_U8 *)dstImage.u64VirAddr;
+    dstMat.create(h, w, CV_8UC3);
+    memcpy(dstMat.data, srcRGB, bufLen * sizeof(HI_U8));
+    HI_MPI_SYS_MmzFree(dstImage.u64PhyAddr, (void *)&(dstImage.u64VirAddr));
+    return HI_SUCCESS;
+}
+
+/**
+    灏璁＄缁涓resJson.
+*/
+HI_CHAR* TennisDetectToJson(const RectBox items[], HI_S32 itemNum, int* resBytes)
+{
+    HI_S32 jsonSize = TINY_BUF_SIZE + itemNum * TINY_BUF_SIZE; // 姣涓itemsize涓TINY_BUF_SIZE
+    HI_CHAR *jsonBuf = (HI_CHAR*)malloc(jsonSize);
+    HI_ASSERT(jsonBuf);
+    HI_S32 offset = 0;
+
+    offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1, "[");
+    for (HI_S32 i = 0; i < itemNum; i++) {
+        const RectBox *item = &items[i];
+        offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1,
+            "%s { \"object xmin\": %d, \"ymin\": %d, \"xmax\": %d, \"ymax\": %d }",
+            (i == 0 ? "\n  " : ", "), (uint)item->xmin, (uint)item->ymin, (uint)item->xmax, (uint)item->ymax);
+        HI_ASSERT(offset < jsonSize);
+    }
+    offset += snprintf_s(jsonBuf + offset, jsonSize - offset, jsonSize - offset - 1, "]");
+    HI_ASSERT(offset < jsonSize);
+    
+    if (resBytes) {
+        *resBytes = offset;
+    }
+    return jsonBuf;
+}
+
+static int TennisDetectCal(uintptr_t model,
+    VIDEO_FRAME_INFO_S *srcFrm, VIDEO_FRAME_INFO_S *dstFrm, HI_CHAR** resJson)
+{
+    (void)model;
+    int ret = 0;
+    RectBox boxs[TENNIS_OBJ_MAX] = {0};
+    int j = 0;
+
+    Mat image;
+    frame2Mat(srcFrm, image);
+    if (image.size == 0) {
+        LOGD("image is null\n");
+        return HI_FAILURE;
+    }
+
+    Mat src = image;
+    Mat src1 = src.clone();
+    Mat dst, edge, gray, hsv;
+
+    dst.create(src1.size(), src1.type()); // 寤轰src绫诲澶у╅(dst)
+    // imwrite("image.jpg", src1);
+
+    // cvtColor绠瀛ㄤ灏惧浠涓涓棰茬┖磋浆㈠板涓涓棰茬┖寸杞
+    cvtColor(src1, hsv, COLOR_BGR2HSV); // 灏捐浆涓HSV惧
+
+    // 瀵hsv惧杩琛浜煎澶锛杩灏缁胯茶浜煎锛璇ュ版规姹杩琛璋
+    inRange(hsv, Scalar(31, 82, 68), Scalar(65, 248, 255), gray);
+
+    // ╃canny绠瀛杩琛杈圭妫娴
+    Canny(gray, gray, 3, 9, 3);
+    vector<vector<Point>> contours;
+    findContours(gray, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE, Point());
+    LOGI("contours.size():%d\n", contours.size());
+
+    for (int i = 0; i < (int)contours.size(); i++) {
+        if (contours.size() > 30) {
+            continue;
+        }
+
+        Rect ret1 = boundingRect(Mat(contours[i]));
+        ret1.x -= 5;
+        ret1.y -= 5;
+        ret1.width += 10;
+        ret1.height += 10;
+
+        if ((ret1.width > 20) && (ret1.height > 20)) {
+            LOGD("ret x:%d, y:%d, width:%d, height:%d\n", ret1.x, ret1.y, ret1.width, ret1.height);
+            boxs[j].xmin = ret1.x * 2;
+            boxs[j].ymin = (int)(ret1.y * 1.5);
+            boxs[j].xmax = boxs[j].xmin + ret1.width * 2;
+            boxs[j].ymax = boxs[j].ymin + (int)ret1.height * 1.5;
+            j++;
+        }
+        LOGD("dstfrm width:%d, Height:%d\n", dstFrm->stVFrame.u32Width, dstFrm->stVFrame.u32Height);
+	}
+
+    // 璁＄缁涓resJson
+    *resJson = TennisDetectToJson(boxs, j, NULL);
+
+    if (j > 0 && j <= 25) {
+        LOGI("box num:%d\n", j);
+        MppFrmDrawRects(dstFrm, boxs, j, RGB888_RED, DRAW_RETC_THICK);
+    }
+
+    return ret;
+}
+
+static const AiPlug G_TENNIS_DETECT_ITF = {
+    .Prof = TennisDetectProf,
+    .Load = TennisDetectLoad,
+    .Unload = TennisDetectUnload,
+    .Cal = TennisDetectCal,
+};
+
+const AiPlug* AiPlugItf(uint32_t* magic)
+{
+    if (magic) {
+        *magic = AI_PLUG_MAGIC;
+    }
+
+    return (AiPlug*)&G_TENNIS_DETECT_ITF;
+}
diff -urpBN hiopenais/src/plug_demo/yolov2_hand_detect/yolov2_hand_detect.c hiopenais_modify/src/plug_demo/yolov2_hand_detect/yolov2_hand_detect.c
--- hiopenais/src/plug_demo/yolov2_hand_detect/yolov2_hand_detect.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/plug_demo/yolov2_hand_detect/yolov2_hand_detect.c	2021-10-20 04:47:34.220773427 -0700
@@ -0,0 +1,166 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <errno.h>
+
+#include "sample_comm_nnie.h"
+#include "nnie_sample_plug.h"
+
+#include "hi_ext_util.h"
+#include "mpp_help.h"
+#include "ai_plug.h"
+
+#define PLUG_UUID          "\"hi.yolov2_hand_detect\""
+#define PLUG_DESC          "\"ㄦ娴(yolov2)\""     // UTF8 encode
+
+#define FRM_WIDTH          640
+#define FRM_HEIGHT         384
+#define MODEL_FILE_HAND    "./plugs/darknetYolo.wk" // darknet framework wk model
+
+#define THRESH_MIN         0.25
+#define DETECT_OBJ_MAX     32 // todo:need test
+#define PIRIOD_NUM_MAX     49 // Logs are printed when the number of targets is detected
+#define DRAW_RETC_THICK    2  // Draw the width of the line
+
+static uintptr_t g_handModel = 0;
+
+static const char YOLO2_FD_PROF[] = "{"
+    "\"uuid\": " PLUG_UUID ","
+    "\"desc\": " PLUG_DESC ","
+    "\"frmWidth\": " HI_TO_STR(FRM_WIDTH) ","
+    "\"frmHeight\": " HI_TO_STR(FRM_HEIGHT) ","
+    "\"butt\": 0"
+"}";
+
+static const char* Yolo2FdProf(void)
+{
+    return YOLO2_FD_PROF;
+}
+
+static HI_S32 Yolo2FdLoad(uintptr_t* model, OsdSet* osds)
+{
+    SAMPLE_SVP_NNIE_CFG_S *self = NULL;
+    HI_S32 ret;
+
+    ret = Yolo2Create(&self, MODEL_FILE_HAND);
+    *model = ret < 0 ? 0 : (uintptr_t)self;
+    LOGI("Yolo2FdLoad ret:%d\n", ret);
+    return ret;
+}
+
+HI_S32 HandDetectInit()
+{
+    return Yolo2FdLoad(&g_handModel, NULL);
+}
+
+static HI_S32 Yolo2FdUnload(uintptr_t model)
+{
+    Yolo2Destory((SAMPLE_SVP_NNIE_CFG_S*)model);
+    return 0;
+}
+
+HI_S32 HandDetectExit()
+{
+    return Yolo2FdUnload(g_handModel);
+}
+
+//NNIEㄧュｅ芥
+static HI_S32 Yolo2FdCal(uintptr_t model,
+    VIDEO_FRAME_INFO_S *srcFrm, VIDEO_FRAME_INFO_S *dstFrm, HI_CHAR** resJson)
+{
+    SAMPLE_SVP_NNIE_CFG_S *self = (SAMPLE_SVP_NNIE_CFG_S*)model; // reference to SDK sample_comm_nnie.h
+    IVE_IMAGE_S img; // referece to SDK hi_comm_ive.h
+    DetectObjInfo objs[DETECT_OBJ_MAX] = {0};
+    RectBox boxs[DETECT_OBJ_MAX] = {0};
+    int objNum;
+    int ret;
+
+    // performance statistical variable
+    static int64_t yuv2RgbCost = 0;
+    static int64_t calCost = 0;
+    static int piriodNum = 0;
+    int64_t begTime;
+
+    // YUV to RGB
+    begTime = HiClockMs();
+    ret = FrmToOrigImg((VIDEO_FRAME_INFO_S*)srcFrm, &img);
+    HI_EXP_RET(ret != HI_SUCCESS, ret, "hand_detect_cal FAIL, for YUV2RGB FAIL, ret=%#x\n", ret);
+    yuv2RgbCost += (HiClockMs() - begTime);
+
+    // calculate
+    begTime = HiClockMs();
+    ret = Yolo2CalImg(self, &img, THRESH_MIN, objs, HI_ARRAY_SIZE(objs), &objNum);
+    IveImgDestroy(&img);
+    HI_EXP_RET(ret < 0, ret, "hand_detect_cal FAIL, for cal FAIL, ret=%d\n", ret);
+    calCost += (HiClockMs() - begTime);
+    LOGI("objNum:%d\n", objNum);
+    for (int i = 0; i < objNum; i++) {
+        RectBox *box = &objs[i].box;
+        RectBoxTran(box, FRM_WIDTH, FRM_HEIGHT,
+            dstFrm->stVFrame.u32Width, dstFrm->stVFrame.u32Height);
+        LOGI("yolo2_out: {%d, %d, %d, %d}\n",
+            box->xmin, box->ymin, box->xmax, box->ymax);
+
+
+        boxs[i] = *box;
+    }
+
+    // The result of the package calculation is resJSON
+    *resJson = DetectObjsToJson(objs, objNum, NULL);
+
+    // Log performance statistics
+    if (++piriodNum > PIRIOD_NUM_MAX) {
+        LOGD("yolo: num=%d, pcvt=%jd, pcal=%jd\n",
+            piriodNum, yuv2RgbCost / piriodNum, calCost / piriodNum);
+        yuv2RgbCost = 0;
+        calCost = 0;
+        piriodNum = 0;
+    }
+
+    // When an object is detected, a rectangle is drawn in the DSTFRM
+    if (objNum > 0) {
+        MppFrmDrawRects(dstFrm, boxs, objNum, RGB888_RED, DRAW_RETC_THICK);
+    }
+
+    return ret;
+}
+
+static HI_S32 HandDetect(uintptr_t model, IVE_IMAGE_S *srcYuv, DetectObjInfo boxs[])
+{
+    SAMPLE_SVP_NNIE_CFG_S *self = (SAMPLE_SVP_NNIE_CFG_S*)model;
+    int objNum;
+    int ret;
+    ret = Yolo2CalImg(self, srcYuv, THRESH_MIN, boxs, DETECT_OBJ_MAX, &objNum);
+    HI_EXP_RET(ret < 0, ret, "Hand detect Yolo2CalImg FAIL, for cal FAIL\n");
+
+    return objNum;
+}
+
+HI_S32 HandDetectCal(IVE_IMAGE_S *srcYuv, DetectObjInfo resArr[])
+{
+    int ret;
+    ret = HandDetect(g_handModel, srcYuv, resArr);
+    return ret;
+}
+
+static const AiPlug G_HAND_DETECT_ITF = {
+    .Prof = Yolo2FdProf,
+    .Load = Yolo2FdLoad,
+    .Unload = Yolo2FdUnload,
+    .Cal = Yolo2FdCal,
+};
\ 浠跺熬娌℃㈣绗
diff -urpBN hiopenais/src/plug_demo/yolov2_hand_detect/yolov2_hand_detect.h hiopenais_modify/src/plug_demo/yolov2_hand_detect/yolov2_hand_detect.h
--- hiopenais/src/plug_demo/yolov2_hand_detect/yolov2_hand_detect.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/plug_demo/yolov2_hand_detect/yolov2_hand_detect.h	2021-06-30 23:36:59.000000000 -0700
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef YOLOV2_HAND_DETECT_H
+#define YOLOV2_HAND_DETECT_H
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern HI_S32 HandDetectInit();
+extern HI_S32 HandDetectExit();
+extern HI_S32 HandDetectCal(IVE_IMAGE_S *srcYuv, DetectObjInfo resArr[]);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // YOLOV2_HAND_DETECT_H
\ 浠跺熬娌℃㈣绗
diff -urpBN hiopenais/src/uvc_dev/frm_store.c hiopenais_modify/src/uvc_dev/frm_store.c
--- hiopenais/src/uvc_dev/frm_store.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/uvc_dev/frm_store.c	2021-03-30 02:35:25.000000000 -0700
@@ -0,0 +1,199 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#include "hi_debug.h"
+#include "frm_store.h"
+
+/**
+    av cache data member.
+*/
+struct frm_store_t {
+    struct list_head free_list; // free node list
+    struct list_head cache_que; // cached queue
+    struct list_head use_que; // using and waiting tx queue
+
+    size_t node_size; // node size，检验用
+    int node_num; // 创建的node的数量，校验用
+};
+
+/**
+    创建frm_store.
+*/
+frm_store_t* frm_store_create(size_t node_size, int node_num)
+{
+    frm_store_t *self = NULL;
+
+    self = (frm_store_t*)malloc(sizeof(*self));
+    HI_ASSERT(self);
+    if (memset_s(self, sizeof(*self), 0, sizeof(*self)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    INIT_LIST_HEAD(&self->free_list);
+    INIT_LIST_HEAD(&self->cache_que);
+    INIT_LIST_HEAD(&self->use_que);
+    self->node_size = node_size;
+    self->node_num = node_num;
+
+    for (int i = 0; i < node_num; i++) {
+        frm_node_t *node = MemBlkNew(node_size);
+        if (!node) {
+            HI_ASSERT(0);
+        }
+        node->index = i;
+        list_add_tail(&node->lnode, &self->free_list);
+    }
+    return self;
+}
+
+/**
+    销毁frm_store.
+*/
+void frm_store_destroy(frm_store_t* self)
+{
+    frm_node_t *node = NULL;
+    int num = 0;
+
+    frm_store_clear(self); // 将所有node都释放回free_list中
+    while ((node = frm_store_alloc(self)) != NULL) {
+        MemBlkDelete(node);
+        num++;
+    }
+
+    if (num != self->node_num) {
+        LOGE("frm_store_destroy with wrong num, orig=%d, now=%d\n", self->node_num, num);
+    }
+    free(self);
+}
+
+/**
+    从任意list中get node.
+*/
+static frm_node_t* frm_store_any_get(struct list_head* list)
+{
+    frm_node_t *node = NULL;
+
+    if (list_empty(list)) {
+        return NULL;
+    }
+
+    node = list_entry(list->next, frm_node_t, lnode);
+    list_del(&node->lnode);
+    return node;
+}
+
+/**
+    将所有node复位到空闲状态.
+*/
+void frm_store_clear(frm_store_t* self)
+{
+    frm_node_t *node = NULL;
+
+    while ((node = frm_store_any_get(&self->use_que)) != NULL) {
+        frm_store_free(self, node);
+    }
+    while ((node = frm_store_any_get(&self->cache_que)) != NULL) {
+        frm_store_free(self, node);
+    }
+    int ret = list_size(&self->free_list);
+    HI_ASSERT(ret == self->node_num);
+}
+
+/**
+    分配空闲的node.
+*/
+frm_node_t* frm_store_alloc(frm_store_t* self)
+{
+    frm_node_t *node = frm_store_any_get(&self->free_list);
+    if (node) {
+        HI_ASSERT(node->len == 0 && node->size == self->node_size);
+    }
+    return node;
+}
+
+/**
+    释放node到空闲队列中.
+*/
+void frm_store_free(frm_store_t* self, frm_node_t* node)
+{
+    HI_ASSERT(node->size == self->node_size);
+
+    node->offset = 0;
+    node->len = 0;
+    list_add(&node->lnode, &self->free_list); // 添加到头部，使得最近使用过的node会更有机会被再次使用
+}
+
+/**
+    将node添加到cache队列末尾.
+*/
+void frm_store_cache_put(frm_store_t* self, frm_node_t* node)
+{
+    list_add_tail(&node->lnode, &self->cache_que); // 注意要加到末尾，这是有顺序的
+}
+
+/**
+    从cache队列中获取cache的node.
+*/
+frm_node_t* frm_store_cache_get(frm_store_t* self)
+{
+    return frm_store_any_get(&self->cache_que);
+}
+
+/**
+    将node添加到use队列中.
+*/
+void frm_store_useque_put(frm_store_t* self, frm_node_t* node)
+{
+    list_add_tail(&node->lnode, &self->use_que); // 注意最好加到末尾，保持顺序
+}
+
+/**
+    从use队列中获取指定index的node.
+*/
+frm_node_t* frm_store_useque_get(frm_store_t* self, int index)
+{
+    frm_node_t *node = NULL;
+    struct list_head *cur = NULL;
+    struct list_head *next = NULL;
+
+    list_for_each_safe(cur, next, &self->use_que) {
+        node = list_entry(cur, frm_node_t, lnode);
+        if (index == node->index) {
+            list_del(cur);
+            return node;
+        }
+    }
+    return NULL;
+}
+
+/**
+    获取use队列中的node数.
+*/
+int frm_store_useque_size(frm_store_t* self)
+{
+    return list_size(&self->use_que);
+}
+
+/**
+    获得总的node数量.
+*/
+int frm_store_node_num(frm_store_t* self)
+{
+    return self->node_num;
+}
+
diff -urpBN hiopenais/src/uvc_dev/frm_store.h hiopenais_modify/src/uvc_dev/frm_store.h
--- hiopenais/src/uvc_dev/frm_store.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/uvc_dev/frm_store.h	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AV_FRM_STORE_H
+#define AV_FRM_STORE_H
+
+#include <stdint.h>
+#include <stdlib.h>
+
+#include "hi_misc_util.h"
+#include "hi_dbg_log.h"
+#include "securec.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    av node type.
+*/
+typedef MemBlk frm_node_t;
+
+/**
+    av node store.
+*/
+typedef struct frm_store_t frm_store_t;
+
+/**
+    创建frm_store_t.
+
+    根据参数指定的size和num创建node，并添加到空闲队列中
+*/
+frm_store_t* frm_store_create(size_t node_size, int node_num);
+
+/**
+    销毁frm_store_t.
+*/
+void frm_store_destroy(frm_store_t* self);
+
+/**
+    将所有队列中的node移动到free列表，复位到空闲状态.
+*/
+void frm_store_clear(frm_store_t* self);
+
+/**
+    分配空闲的node.
+
+    从空闲队列中分配node。
+*/
+frm_node_t* frm_store_alloc(frm_store_t* self);
+
+/**
+    释放node到空闲队列中.
+
+    从任意类型队列中获取的node，均可通过此函数将其释放到空闲队列中。
+*/
+void frm_store_free(frm_store_t* self, frm_node_t* node);
+
+/**
+    将node添加到cache队列的末尾.
+
+    user通过alloc分配到node，并做相应处理(如填充数据后)，调用此函数将其添加到cache队列中。
+*/
+void frm_store_cache_put(frm_store_t* self, frm_node_t* node);
+
+/**
+    从cache队列中获取cache的node.
+*/
+frm_node_t* frm_store_cache_get(frm_store_t* self);
+
+/**
+    将node添加到use队列的末尾.
+
+    user从cache队列中get到node，并将buf提交给UVC/UAC后，调用此函数将其添加到wait队列中。
+*/
+void frm_store_useque_put(frm_store_t* self, frm_node_t* node);
+
+/**
+    从use队列中获取指定index的node.
+*/
+frm_node_t* frm_store_useque_get(frm_store_t* self, int index);
+
+/**
+    获取use队列中的node数.
+*/
+int frm_store_useque_size(frm_store_t* self);
+
+/**
+    获得总的node数量.
+*/
+int frm_store_node_num(frm_store_t* self);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // AV_FRM_STORE_H
diff -urpBN hiopenais/src/uvc_dev/usb_video.h hiopenais_modify/src/uvc_dev/usb_video.h
--- hiopenais/src/uvc_dev/usb_video.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/uvc_dev/usb_video.h	2021-03-29 04:19:04.000000000 -0700
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __LINUX_USB_VIDEO_H
+#define __LINUX_USB_VIDEO_H
+
+#include <stdint.h>
+#include <linux/types.h>
+
+#define UVC_VC_SETCUR_COMPLETE 0xff
+
+/*
+ * Video Class-specific Request Codes, UVC spec. 1.5, section A.8
+ */
+#define UVC_RC_SETCUR            0x01
+#define UVC_RC_SETCUR_ALL        0x11
+#define UVC_RC_GETCUR            0x81
+#define UVC_RC_GETMIN            0x82
+#define UVC_RC_GETMAX            0x83
+#define UVC_RC_GETRES            0x84
+#define UVC_RC_GETLEN            0x85
+#define UVC_RC_GETINFO           0x86
+#define UVC_RC_GETDEF            0x87
+#define UVC_RC_GETCUR_ALL        0x91
+#define UVC_RC_GETMIN_ALL        0x92
+#define UVC_RC_GETMAX_ALL        0x93
+#define UVC_RC_GETRES_ALL        0x94
+#define UVC_RC_GETDEF_ALL        0x95
+
+typedef struct _uvcx_base_ctrl_t {
+    uint16_t selector;
+    uint16_t index;
+} __attribute__ ((__packed__)) uvcx_base_ctrl_t;
+
+typedef struct uvcx_camera_stream_t {
+    uint16_t format;
+    uint16_t resolution;
+} __attribute__ ((__packed__)) uvcx_camera_stream_t;
+
+#endif /* __LINUX_USB_VIDEO_H */
diff -urpBN hiopenais/src/uvc_dev/uvc_def.h hiopenais_modify/src/uvc_dev/uvc_def.h
--- hiopenais/src/uvc_dev/uvc_def.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/uvc_dev/uvc_def.h	2021-03-30 02:38:59.000000000 -0700
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __UVC_DEF_H
+#define __UVC_DEF_H
+
+#include <stdint.h>
+
+#define v4l2_fourcc(a, b, c, d) \
+    ((__u32)(a) | ((__u32)(b) << 8) | ((__u32)(c) << 16) | ((__u32)(d) << 24))
+
+#define V4L2_PIX_FMT_YUYV v4l2_fourcc('Y', 'U', 'Y', 'V') // 16  YUV 4:2:2
+#define V4L2_PIX_FMT_YUV420 v4l2_fourcc('Y', 'U', '1', '2') // 16  YUV 4:2:0
+#define V4L2_PIX_FMT_NV12 v4l2_fourcc('N', 'V', '1', '2') // 16  YUV 4:2:0
+#define V4L2_PIX_FMT_MJPEG v4l2_fourcc('M', 'J', 'P', 'G') // Motion-JPEG
+#define V4L2_PIX_FMT_JPEG v4l2_fourcc('J', 'P', 'E', 'G') // JFIF JPEG
+#define V4L2_PIX_FMT_DV v4l2_fourcc('d', 'v', 's', 'd') // 1394
+#define V4L2_PIX_FMT_MPEG v4l2_fourcc('M', 'P', 'E', 'G') // MPEG-1/2/4 Multiplexed
+#define V4L2_PIX_FMT_H264 v4l2_fourcc('H', '2', '6', '4') // H264 with start codes
+#define V4L2_PIX_FMT_H264_NO_SC v4l2_fourcc('A', 'V', 'C', '1') // H264 without start codes
+#define V4L2_PIX_FMT_H264_MVC v4l2_fourcc('M', '2', '6', '4') // H264 MVC
+#define V4L2_PIX_FMT_H263 v4l2_fourcc('H', '2', '6', '3') // H263
+#define V4L2_PIX_FMT_MPEG1 v4l2_fourcc('M', 'P', 'G', '1') // MPEG-1 ES
+#define V4L2_PIX_FMT_MPEG2 v4l2_fourcc('M', 'P', 'G', '2') // MPEG-2 ES
+#define V4L2_PIX_FMT_MPEG4 v4l2_fourcc('M', 'P', 'G', '4') // MPEG-4 ES
+#define V4L2_PIX_FMT_XVID v4l2_fourcc('X', 'V', 'I', 'D') // Xvid
+#define V4L2_PIX_FMT_VC1_ANNEX_G v4l2_fourcc('V', 'C', '1', 'G') // SMPTE 421M Annex G compliant stream
+#define V4L2_PIX_FMT_VC1_ANNEX_L v4l2_fourcc('V', 'C', '1', 'L') // SMPTE 421M Annex L compliant stream
+#define V4L2_PIX_FMT_VP8 v4l2_fourcc('V', 'P', '8', '0') // VP8
+
+#endif // __UVC_DEF_H
+
diff -urpBN hiopenais/src/uvc_dev/uvc_dev.c hiopenais_modify/src/uvc_dev/uvc_dev.c
--- hiopenais/src/uvc_dev/uvc_dev.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/uvc_dev/uvc_dev.c	2021-03-30 03:12:27.000000000 -0700
@@ -0,0 +1,1285 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/select.h>
+
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include <limits.h>
+#include <errno.h>
+#include <linux/usb/ch9.h>
+
+#include "hi_ext_util.h"
+#include "hi_app_base.h"
+#include "video.h"
+#include "histream.h"
+#include "uvc_strm.h"
+#include "uvc_def.h"
+#include "uvc_dev.h"
+
+// 修改为动态获取UVC接口ID
+// modified for support windows
+#define UVC_CTRL_ITF_DEF        2 // 0
+#define UVC_STRM_ITF_DEF        3 // 1
+
+#if 1 // 复制于此的V4L2相关定义
+
+#define VIDIOC_S_FMT _IOWR('V', 5, struct v4l2_format)
+#define VIDIOC_REQBUFS _IOWR('V', 8, struct v4l2_requestbuffers)
+#define VIDIOC_QUERYBUF _IOWR('V', 9, struct v4l2_buffer)
+#define VIDIOC_QUERYCAP _IOR('V', 0, struct v4l2_capability)
+#define VIDIOC_STREAMOFF _IOW('V', 19, int)
+#define VIDIOC_QBUF _IOWR('V', 15, struct v4l2_buffer)
+#define VIDIOC_S_CTRL _IOWR('V', 28, struct v4l2_control)
+#define VIDIOC_S_DV_TIMINGS _IOWR('V', 87, struct v4l2_dv_timings)
+#define VIDIOC_G_DV_TIMINGS _IOWR('V', 88, struct v4l2_dv_timings)
+#define VIDIOC_DQEVENT _IOR('V', 89, struct v4l2_event)
+#define VIDIOC_SUBSCRIBE_EVENT _IOW('V', 90, struct v4l2_event_subscription)
+#define VIDIOC_UNSUBSCRIBE_EVENT _IOW('V', 91, struct v4l2_event_subscription)
+#define VIDIOC_STREAMON _IOW('V', 18, int)
+#define VIDIOC_DQBUF _IOWR('V', 17, struct v4l2_buffer)
+
+#define UVCIOC_SEND_RESPONSE _IOW('U', 1, struct uvc_request_data)
+
+#define V4L2_EVENT_PRIVATE_START 0x08000000
+#define UVC_EVENT_FIRST (V4L2_EVENT_PRIVATE_START + 0)
+#define UVC_EVENT_CONNECT (V4L2_EVENT_PRIVATE_START + 0)
+#define UVC_EVENT_DISCONNECT (V4L2_EVENT_PRIVATE_START + 1)
+#define UVC_EVENT_STREAMON (V4L2_EVENT_PRIVATE_START + 2)
+#define UVC_EVENT_STREAMOFF (V4L2_EVENT_PRIVATE_START + 3)
+#define UVC_EVENT_SETUP (V4L2_EVENT_PRIVATE_START + 4)
+#define UVC_EVENT_DATA (V4L2_EVENT_PRIVATE_START + 5)
+#define UVC_EVENT_LAST (V4L2_EVENT_PRIVATE_START + 5)
+
+#define TRANSFER_SIZE  3072
+#define BMFRAMING_INFO 3
+#define UVC_SET_CUR_RESP_LEN 34
+#define UVC_GET_LEN_RESP_LEN 2
+#define OFSSET_EIGHT_BITS    8
+#define MAX_CACHE_NUM  8
+
+#endif // 1
+
+#define clamp(val, min, max) ({                \
+        typeof(val)__val = (val);              \
+        typeof(min)__min = (min);              \
+        typeof(max)__max = (max);              \
+        (void) (&__val == &__min);             \
+        (void) (&__val == &__max);             \
+        __val = __val < __min ? __min : __val; \
+        __val > __max ? __max : __val; })
+
+struct uvc_frame_info {
+    unsigned int width;
+    unsigned int height;
+    unsigned int intervals[8];
+};
+
+struct uvc_format_info {
+    unsigned int                 fcc;
+    const struct uvc_frame_info* frames;
+};
+
+static const struct uvc_frame_info uvc_frames_mjpeg[] = {
+    { 640, 360, { 333333, 0 }, },
+    { 1280, 720, { 333333, 0 }, },
+    { 1920, 1080, { 333333, 0 }, },
+    { 2592, 1944, { 333333, 0 }, },
+    {    0,    0, {		0,         }, },
+};
+
+#if 1
+static const struct uvc_frame_info uvc_frames_h264[] = {
+    {  640,  360, {333333,       0 }, },
+    { 1280,  720, {333333,		0  }, },
+    { 1920, 1080, {333333,       0 }, },
+    { 2592, 1944, {333333, 0 }, },
+    {    0,    0, {		0,         }, },
+};
+#endif // 0
+
+#if 1
+static const struct uvc_frame_info uvc_frames_yuyv[] = {
+    { 1280, 720, {333333, 0 }, },
+    { 1280,  720, {333333,		0  }, },
+    { 1920, 1080, {333333,       0 }, },
+    { 2592, 1944, {333333, 0 }, },
+    {    0,    0, {		0,         }, },
+};
+#endif // 0
+
+static const struct uvc_format_info uvc_formats[] = {
+    { V4L2_PIX_FMT_YUYV,  uvc_frames_yuyv  },
+    { V4L2_PIX_FMT_MJPEG, uvc_frames_mjpeg },
+    { V4L2_PIX_FMT_H264,  uvc_frames_h264  },
+};
+
+/*************************************************************************************************
+    UVC event process, 基于uvc_app sample略作修改
+    阅读HiOpenAIS时，可不用细读这些实现。
+*************************************************************************************************/
+#define SP_UVC_EVTS
+
+/*
+    main function前向申明
+*/
+static void uvc_start_strm(uvc_dev_ext_t* dev);
+static void uvc_stop_strm(uvc_dev_ext_t* dev);
+
+const char* uvc_code_to_str(int c)
+{
+    if (c == 0x01) {
+        return "SET_CUR";
+    } else if (c == 0x81) {
+        return "GET_CUR";
+    } else if (c == 0x82) {
+        return "GET_MIN";
+    } else if (c == 0x83) {
+        return "GET_MAX";
+    } else if (c == 0x84) {
+        return "GET_RES";
+    } else if (c == 0x85) {
+        return "GET_LEN";
+    } else if (c == 0x86) {
+        return "GET_INFO";
+    } else if (c == 0x87) {
+        return "GET_DEF";
+    } else {
+        return "UNKNOW";
+    }
+}
+
+const char *uvc_itfcs_to_str(int c)
+{
+    if (c == 0x01) {
+        return "PROB_CONTROL";
+    } else if (c == 0x02) {
+        return "COMMIT_CONTROL";
+    } else {
+        return "UNKOWN";
+    }
+}
+
+static const char* uvc_pixfmt_to_str(unsigned int format)
+{
+    switch (format) {
+        case V4L2_PIX_FMT_H264:
+            return "H264";
+            break;
+
+        case V4L2_PIX_FMT_MJPEG:
+            return "MJPEG";
+            break;
+
+        case V4L2_PIX_FMT_YUYV:
+            return "YUYV";
+            break;
+
+        case V4L2_PIX_FMT_YUV420:
+            return "YUV420";
+            break;
+
+        default:
+            return "unknown format";
+            break;
+    }
+}
+
+static int uvc_set_pixfmt(struct uvc_device_ext* dev)
+{
+    struct v4l2_format fmt;
+    int ret;
+
+    if (memset_s(&fmt, sizeof fmt, 0, sizeof fmt) != EOK) {
+        HI_ASSERT(0);
+    }
+    fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+    fmt.fmt.pix.width = dev->width;
+    fmt.fmt.pix.height = dev->height;
+    fmt.fmt.pix.pixelformat = dev->fcc;
+    fmt.fmt.pix.field = V4L2_FIELD_NONE;
+
+    if ((dev->fcc == V4L2_PIX_FMT_MJPEG) || (dev->fcc == V4L2_PIX_FMT_H264)) {
+        fmt.fmt.pix.sizeimage = dev->imgsize;
+    }
+
+    if ((ret = ioctl(dev->fd, VIDIOC_S_FMT, &fmt)) < 0) {
+        LOGE("Unable to set format: %s (%d).\n", strerror(errno), errno);
+    }
+    return ret;
+}
+
+static void uvc_fill_strm_ctrl(struct uvc_device_ext* dev,
+    struct uvc_streaming_control* ctrl, int iframe, int iformat)
+{
+    const struct uvc_format_info* format = NULL;
+    const struct uvc_frame_info* frame = NULL;
+    unsigned int nframes;
+
+    if (iformat < 0) {
+        iformat = HI_ARRAY_SIZE(uvc_formats) + iformat;
+    }
+
+    if ((iformat < 0) || (iformat >= (int)HI_ARRAY_SIZE(uvc_formats))) {
+        return;
+    }
+
+    format = &uvc_formats[iformat];
+    nframes = 0;
+
+    while (format->frames[nframes].width != 0) {
+        ++nframes;
+    }
+
+    if (iframe < 0) {
+        iframe = nframes + iframe;
+    }
+    if ((iframe < 0) || (iframe >= (int)nframes)) {
+        return;
+    }
+    frame = &format->frames[iframe];
+
+    if (memset_s(ctrl, sizeof(*ctrl), 0, sizeof(*ctrl)) != EOK) {
+        HI_ASSERT(0);
+    }
+    ctrl->bmHint = 1;
+    ctrl->bFormatIndex = iformat + 1; // 1 is yuv ,2 is mjpeg
+    ctrl->bFrameIndex = iframe + 1; // 360 1 720 2
+    ctrl->dwFrameInterval = frame->intervals[0]; // dui ying di ji ge zhenlv
+
+    switch (format->fcc) {
+    case V4L2_PIX_FMT_YUYV:
+    case V4L2_PIX_FMT_YUV420:
+        ctrl->dwMaxVideoFrameSize = frame->width * frame->height * 2; // 2: width*height*2
+        break;
+
+    case V4L2_PIX_FMT_MJPEG:
+    case V4L2_PIX_FMT_H264:
+
+        ctrl->dwMaxVideoFrameSize = dev->imgsize;
+        break;
+    default:
+        break;
+    }
+
+    if (dev->bulk) {
+        ctrl->dwMaxPayloadTransferSize = dev->bulk_size; // this should be filled by the driver.
+    } else {
+        ctrl->dwMaxPayloadTransferSize = TRANSFER_SIZE;
+    }
+    ctrl->bmFramingInfo = BMFRAMING_INFO;
+    ctrl->bPreferedVersion = 1;
+    ctrl->bMaxVersion = 1;
+}
+
+static void uvc_set_probe_status(struct uvc_device_ext* dev, int cs, int req)
+{
+    if (cs == 0x01) {
+        switch (req) {
+            case 0x01:
+                dev->probe_status.set = 1;
+                break;
+            case 0x81:
+                dev->probe_status.get = 1;
+                break;
+            case 0x82:
+                dev->probe_status.min = 1;
+                break;
+            case 0x83:
+                dev->probe_status.max = 1;
+                break;
+            case 0x84:
+                break;
+            case 0x85:
+                break;
+            case 0x86:
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+static int uvc_chk_probe_status(struct uvc_device_ext* dev)
+{
+    if ((dev->probe_status.get == 1) &&
+        (dev->probe_status.set == 1) &&
+        (dev->probe_status.min == 1) &&
+        (dev->probe_status.max == 1)) {
+        return 1;
+    }
+    LOGW("the probe status is not correct...\n");
+    return 0;
+}
+
+static void uvc_proc_itf_ctrl_ext(uvc_dev_ext_t *dev, struct uvc_request_data *data)
+{
+    switch (dev->unit_id) {
+        case 1:
+            histream_event_it_data_ext(dev, dev->unit_id, dev->control, data);
+            break;
+        case 2: // 2:unit_id is 2
+            histream_event_pu_data_ext(dev->unit_id, dev->control, data);
+            break;
+        case 10: // 10:unit_id is 10
+            histream_event_eu_h264_data(dev->unit_id, dev->control, data);
+            break;
+        case UNIT_XU_HICAMERA:
+            histream_event_xu_data(dev->unit_id, dev->control, data);
+            break;
+        default:
+            break;
+    }
+}
+
+static void uvc_evt_undef_ctrl(uvc_dev_ext_t *dev,
+    uint8_t req, uint8_t cs, struct uvc_request_data *resp)
+{
+    switch (cs) {
+    case UVC_VC_REQUEST_ERROR_CODE_CONTROL:
+        resp->length = dev->request_error_code.length;
+        resp->data[0] = dev->request_error_code.data[0];
+        break;
+    default:
+        dev->request_error_code.length = 1;
+        dev->request_error_code.data[0] = 0x06;
+        break;
+    }
+}
+
+static void uvc_evts_proc_std(struct uvc_device_ext* dev,
+    struct usb_ctrlrequest* ctrl, struct uvc_request_data* resp)
+{
+    LOGI("UVC: std req\n");
+    (void)dev;
+    (void)ctrl;
+    (void)resp;
+}
+
+static void uvc_evts_proc_ctrl(struct uvc_device_ext* dev,
+    uint8_t req, uint8_t unit_id, uint8_t cs, struct uvc_request_data* data, struct uvc_request_data* resp)
+{
+    switch (unit_id) {
+        case 0:
+            uvc_evt_undef_ctrl(dev, req, cs, resp);
+            break;
+        case 1:
+            histream_event_it_control_ext(dev, req, unit_id, cs, resp);
+            break;
+        case 2:  // 2:unit_id is 2
+            histream_event_pu_control_ext(dev, req, unit_id, cs, resp);
+            break;
+        case 10: // 10:unit_id is 10
+            histream_event_eu_h264_control(req, unit_id, cs, resp);
+            break;
+        case UNIT_XU_HICAMERA:
+            histream_event_xu_camera_control(dev, req, unit_id, cs, data, resp);
+            break;
+        default:
+            dev->request_error_code.length = 1;
+            dev->request_error_code.data[0] = 0x06;
+    }
+}
+
+static void uvc_evts_proc_strm(struct uvc_device_ext* dev,
+    uint8_t req, uint8_t cs, struct uvc_request_data* resp)
+{
+    struct uvc_streaming_control* ctrl = NULL;
+
+    if ((cs != UVC_VS_PROBE_CONTROL) && (cs != UVC_VS_COMMIT_CONTROL)) {
+        return;
+    }
+
+    ctrl = (struct uvc_streaming_control*)&resp->data;
+    resp->length = sizeof(*ctrl);
+
+    // request
+    switch (req) {
+        // 0x01
+        case UVC_SET_CUR:
+            dev->control = cs;
+            resp->length = UVC_SET_CUR_RESP_LEN;
+            break;
+
+        // 0x81
+        case UVC_GET_CUR:
+            if (cs == UVC_VS_PROBE_CONTROL) {
+                    *ctrl = dev->probe;
+                } else {
+                    *ctrl = dev->commit;
+            }
+            break;
+
+        // 0x82
+        case UVC_GET_MIN:
+
+        // 0x83
+        case UVC_GET_MAX:
+
+        // 0x87
+        case UVC_GET_DEF:
+            uvc_fill_strm_ctrl(dev, ctrl, req == UVC_GET_MAX ? -1 : 0, req == UVC_GET_MAX ? -1 : 0);
+            break;
+
+        // 0x84
+        case UVC_GET_RES:
+            if (memset_s(ctrl, sizeof(*ctrl), 0, sizeof(*ctrl)) != EOK) {
+                    HI_ASSERT(0);
+            }
+            break;
+
+        // 0x85
+        case UVC_GET_LEN:
+            resp->data[0] = 0x00;
+            resp->data[1] = 0x22;
+            resp->length = UVC_GET_LEN_RESP_LEN;
+            break;
+
+        // 0x86
+        case UVC_GET_INFO:
+            resp->data[0] = 0x03;
+            resp->length = 1;
+            break;
+        default:
+            break;
+    }
+}
+
+static void uvc_evts_proc_class(struct uvc_device_ext* dev,
+    struct usb_ctrlrequest* ctrl, struct uvc_request_data* data, struct uvc_request_data* resp)
+{
+    unsigned char probe_status = 1;
+
+    if (probe_status) {
+        unsigned char type = ctrl->bRequestType & USB_RECIP_MASK;
+        switch (type) {
+        case USB_RECIP_INTERFACE:
+                uvc_set_probe_status(dev, (ctrl->wValue >> 8), ctrl->bRequest); // 8: 右移8位
+            break;
+        case USB_RECIP_DEVICE:
+                LOGI("UVC: request type :DEVICE\n");
+            break;
+        case USB_RECIP_ENDPOINT:
+                LOGI("UVC: request type :ENDPOINT\n");
+            break;
+        case USB_RECIP_OTHER:
+                LOGI("UVC: request type :OTHER\n");
+            break;
+        default:
+            break;
+        }
+    }
+
+    if ((ctrl->bRequestType & USB_RECIP_MASK) != USB_RECIP_INTERFACE) {
+        return;
+    }
+
+    // save unit id, interface id and control selector
+    dev->control = (ctrl->wValue >> OFSSET_EIGHT_BITS);
+    dev->unit_id = ((ctrl->wIndex & 0xff00) >> OFSSET_EIGHT_BITS);
+    dev->interface_id = (ctrl->wIndex & 0xff);
+
+    if ((ctrl->wIndex & 0xff) == dev->ctrl_itf) {
+        uvc_evts_proc_ctrl(dev, ctrl->bRequest, (ctrl->wIndex & 0xff00) >> OFSSET_EIGHT_BITS,
+            ctrl->wValue >> OFSSET_EIGHT_BITS, data, resp);
+    } else if ((ctrl->wIndex & 0xff) == dev->strm_itf) {
+        uvc_evts_proc_strm(dev, ctrl->bRequest, ctrl->wValue >> OFSSET_EIGHT_BITS, resp);
+    }
+}
+
+static void uvc_evts_proc_setup(struct uvc_device_ext* dev,
+    struct usb_ctrlrequest* ctrl, struct uvc_request_data* data, struct uvc_request_data* resp)
+{
+    dev->control = 0;
+    dev->unit_id = 0;
+    // modified for windows support
+    dev->interface_id = dev->ctrl_itf;
+
+    switch (ctrl->bRequestType & USB_TYPE_MASK) {
+    case USB_TYPE_STANDARD:
+            uvc_evts_proc_std(dev, ctrl, resp);
+        break;
+    case USB_TYPE_CLASS:
+            uvc_evts_proc_class(dev, ctrl, data, resp);
+            break;
+
+        default:
+            break;
+    }
+}
+
+static void uvc_evts_proc_data(struct uvc_device_ext* dev, struct uvc_request_data* data)
+{
+    struct uvc_streaming_control* target = NULL;
+    struct uvc_streaming_control* ctrl = NULL;
+    const struct uvc_format_info* format = NULL;
+    const struct uvc_frame_info* frame = NULL;
+    const unsigned int* interval = NULL;
+    unsigned int iformat, iframe;
+    unsigned int nframes;
+
+    if ((dev->unit_id != 0) && (dev->interface_id == dev->ctrl_itf)) {
+        return uvc_proc_itf_ctrl_ext(dev, data);
+    }
+
+    switch (dev->control) {
+        case UVC_VS_PROBE_CONTROL:
+            target = &dev->probe;
+            break;
+
+        case UVC_VS_COMMIT_CONTROL:
+            target = &dev->commit;
+            break;
+        default:
+            LOGW("setting unknown control, len=%d\n", data->length);
+            return;
+    }
+
+    ctrl = (struct uvc_streaming_control*)&data->data;
+    iformat = clamp((unsigned int)ctrl->bFormatIndex, 1U, (unsigned int)HI_ARRAY_SIZE(uvc_formats));
+    format = &uvc_formats[iformat - 1];
+    nframes = 0;
+    while (format->frames[nframes].width != 0) {
+        ++nframes;
+    }
+
+    iframe = clamp((unsigned int)ctrl->bFrameIndex, 1U, nframes);
+    frame = &format->frames[iframe - 1];
+    interval = frame->intervals;
+
+    while ((interval[0] < ctrl->dwFrameInterval) && interval[1]) {
+        ++interval;
+    }
+
+    target->bFormatIndex = iformat;
+    target->bFrameIndex = iframe;
+
+    switch (format->fcc) {
+        case V4L2_PIX_FMT_YUYV:
+            target->dwMaxVideoFrameSize = frame->width * frame->height * 2; // 2: Multiplied 2
+            break;
+        case V4L2_PIX_FMT_YUV420:
+            target->dwMaxVideoFrameSize = frame->width * frame->height * 1.5; // 1.5: Multiplied 1.5
+            break;
+
+        case V4L2_PIX_FMT_MJPEG:
+        case V4L2_PIX_FMT_H264:
+            if (dev->imgsize == 0) {
+                LOGW("MJPEG requested and no image loaded.\n");
+            }
+            target->dwMaxVideoFrameSize = dev->imgsize;
+            break;
+        default:
+            break;
+    }
+
+    target->dwFrameInterval = *interval;
+
+    if ((dev->control == UVC_VS_COMMIT_CONTROL) && uvc_chk_probe_status(dev)) {
+        dev->fcc    = format->fcc;
+        dev->width  = frame->width;
+        dev->height = frame->height;
+        uvc_set_pixfmt(dev);
+        LOGI("UVC: set dev: format='%s', width=%u, height=%u, fmtId=%u, frmId=%u\n",
+            uvc_pixfmt_to_str(dev->fcc), dev->width, dev->height, iformat - 1, iframe - 1);
+        if (dev->bulk != 0) {
+            uvc_start_strm(dev);
+        }
+    }
+
+    if (dev->control == UVC_VS_COMMIT_CONTROL) {
+        if (memset_s(&dev->probe_status, sizeof (dev->probe_status), 0, sizeof (dev->probe_status)) != EOK) {
+            HI_ASSERT(0);
+        }
+    }
+}
+
+static void uvc_evts_proc(struct uvc_device_ext* dev)
+{
+    struct v4l2_event v4l2_event;
+    struct uvc_event* uvc_event = (struct uvc_event*)(void*)&v4l2_event.u.data;
+    struct uvc_request_data resp;
+    int ret;
+
+    ret = ioctl(dev->fd, VIDIOC_DQEVENT, &v4l2_event);
+    if (ret < 0) {
+        LOGE("VIDIOC_DQEVENT failed: %s (%d)\n", strerror(errno), errno);
+        return;
+    }
+
+    if (memset_s(&resp, sizeof resp, 0, sizeof resp) != EOK) {
+        HI_ASSERT(0);
+    }
+    resp.length = -EL2HLT;
+
+    switch (v4l2_event.type) {
+        // 0x08000000
+    case UVC_EVENT_CONNECT:
+            LOGW("handle connect event \n");
+        return;
+        // 0x08000001
+    case UVC_EVENT_DISCONNECT:
+            LOGW("handle disconnect event\n");
+        return;
+        // 0x08000004   UVC class
+    case UVC_EVENT_SETUP:
+            uvc_evts_proc_setup(dev, &uvc_event->req, &uvc_event->data, &resp);
+        break;
+        // 0x08000005
+    case UVC_EVENT_DATA:
+            uvc_evts_proc_data(dev, &uvc_event->data);
+        return;
+        // 0x08000002
+    case UVC_EVENT_STREAMON:
+            LOGI("UVC: UVC_EVENT_STREAMON\n");
+            if (!dev->bulk) {
+                uvc_start_strm(dev);
+            }
+        return;
+        // 0x08000003
+    case UVC_EVENT_STREAMOFF:
+            LOGI("UVC: UVC_EVENT_STREAMOFF\n");
+            if (!dev->bulk) {
+                uvc_stop_strm(dev);
+            }
+        return;
+    default:
+        break;
+    }
+
+    ret = ioctl(dev->fd, UVCIOC_SEND_RESPONSE, &resp);
+    if (ret < 0) {
+        LOGE("UVCIOC_S_EVENT failed: %s (%d)\n", strerror(errno), errno);
+        return;
+    }
+}
+
+static void uvc_evts_init(struct uvc_device_ext* dev)
+{
+    struct v4l2_event_subscription sub;
+
+    uvc_fill_strm_ctrl(dev, &dev->probe, 0, 0);
+    uvc_fill_strm_ctrl(dev, &dev->commit, 0, 0);
+
+    if (dev->bulk) {
+        dev->probe.dwMaxPayloadTransferSize  = dev->bulk_size;
+        dev->commit.dwMaxPayloadTransferSize = dev->bulk_size;
+    }
+
+    if (memset_s(&sub, sizeof sub, 0, sizeof sub) != EOK) {
+        HI_ASSERT(0);
+    }
+    sub.type = UVC_EVENT_SETUP;
+    ioctl(dev->fd, VIDIOC_SUBSCRIBE_EVENT, &sub);
+    sub.type = UVC_EVENT_DATA;
+    ioctl(dev->fd, VIDIOC_SUBSCRIBE_EVENT, &sub);
+    sub.type = UVC_EVENT_STREAMON;
+    ioctl(dev->fd, VIDIOC_SUBSCRIBE_EVENT, &sub);
+    sub.type = UVC_EVENT_STREAMOFF;
+    ioctl(dev->fd, VIDIOC_SUBSCRIBE_EVENT, &sub);
+}
+
+/*************************************************************************************************
+    main
+*************************************************************************************************/
+#define SP_UVC_MAIN
+
+/**
+    uvc stream状态
+
+    目前了解到linux uvc api在启动stream时存在一些限制，需要注意
+    *   需要填满发送队列后，才能trun stream on。否则后续不能顺畅发送。待查实。
+    *   此后，还需要至少发送一帧数据才能让stream真正ready，否则host端可能会认为没有ready。
+    *   另外，stream start后，user应尽快发送数据，否则数秒后，驱动将crash。待查实。
+
+    此状态定义用来处理(绕开)上列问题，UvcDevT::streaming使用此状态定义。
+*/
+typedef enum uvc_strm_stat {
+    UVC_STRM_OFF = 0, // stream off
+    UVC_STRM_INIT = 1, // 等待初始frame填充发送队列
+    UVC_STRM_ON = 2, // 已turn stream on，还需要1帧frame
+    UVC_STRM_READY = 3, // 已ready
+    UVC_STRM_BUTT
+}   uvc_strm_stat_t;
+
+/**
+    uvc_strm_stat name
+*/
+const char* g_uvcStrmStatS[] = {
+    "STRM_OFF",
+    "STRM_INIT",
+    "STRM_ON",
+    "STRM_READY",
+    "?"
+};
+
+/**
+    配置常量
+*/
+#define UVC_DEV_FILE_DEF        "/dev/video0" // 默认的设备文件名
+#define UVC_BULK_MODE_DEF       0 // 默认的bulk mode
+#define UVC_CACHE_NUM_DEF       4 // 默认的帧发送缓冲的数目
+#define UVC_IMG_SIZE_DEF        1843200 // default image size
+#define UVC_BULK_SIZE_DEF       1843200 // default image size on bulk mode
+#define MAX_UVC_IMG_SIZE_DEF    7372800 // max image size
+#define UVC_TRC_INTVAL_DEF      (-1) // 默认的trace统计信息的时间间隔(ms), -1表示不trace
+
+/*
+    前向申明.
+*/
+static void uvc_on_data_fd(void* user, int fd, uint32_t evts);
+
+/**
+    初始化piriod统计信息.
+*/
+static void uvc_piriod_init(uvc_dev_ext_t* dev)
+{
+    dev->prev_out_time = HiClockMs();
+    dev->piriod_beg_time = HiClockMs();
+    dev->piriod_out_num = 0;
+    dev->piriod_lost_num = 0;
+}
+
+/**
+    piriod统计信息处理.
+*/
+static void uvc_piriod_proc(uvc_dev_ext_t* dev)
+{
+    int64_t piriod_time = HiClockMs() - dev->piriod_beg_time;
+    if (dev->trc_intval >= 0 && piriod_time >= dev->trc_intval) {
+        LOGI("UVC[%jd]: p=%jd, piv=%jd, ok=%d, lost=%d\n",
+            dev->frame_out_num, piriod_time,
+            (dev->piriod_out_num > 0 ? piriod_time / dev->piriod_out_num : -1),
+            dev->piriod_out_num, dev->piriod_lost_num);
+        uvc_piriod_init(dev);
+    } else {
+        dev->prev_out_time = HiClockMs();
+    }
+}
+
+/**
+    修改stream状态.
+*/
+static void uvc_chg_stat(uvc_dev_ext_t* dev, uvc_strm_stat_t strm_stat)
+{
+    HI_ASSERT(dev->strm_stat >= UVC_STRM_OFF && dev->strm_stat < UVC_STRM_BUTT);
+    HI_ASSERT(strm_stat >= UVC_STRM_OFF && strm_stat < UVC_STRM_BUTT);
+
+    LOGI("UVC: stat %s => %s\n", g_uvcStrmStatS[dev->strm_stat], g_uvcStrmStatS[strm_stat]);
+    dev->strm_stat = strm_stat;
+}
+
+/**
+    请求驱动分配buf.
+    封装对ioctl(VIDIOC_REQBUFS)的调用。
+*/
+static int uvc_req_bufs(uvc_dev_ext_t* dev, int nbufs)
+{
+    struct v4l2_requestbuffers rb;
+    int ret;
+
+    dev->nbufs = 0;
+
+    if (memset_s(&rb, sizeof rb, 0, sizeof rb) != EOK) {
+        HI_ASSERT(0);
+    }
+    rb.count = nbufs;
+    rb.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+    rb.memory = V4L2_MEMORY_USERPTR;
+    ret = ioctl(dev->fd, VIDIOC_REQBUFS, &rb);
+    if (ret < 0) {
+        LOGE("ioctl(VIDIOC_REQBUFS) FAIL, nbufs=%d, err='%s, %d'\n", nbufs, strerror(errno), errno);
+        return ret;
+    }
+
+    dev->nbufs = rb.count;
+    LOGD("ioctl(VIDIOC_REQBUFS) %u bufs\n", dev->nbufs);
+    return 0;
+}
+
+/**
+    将node.buf中的内容填充到v4l2buf中.
+
+    @param io_type定义见enum v4l2_buf_type，对于UVC/UAC，为V4L2_BUF_TYPE_VIDEO_OUTPUT,
+    对于音视频俘获设备，为V4L2_BUF_TYPE_VIDEO_CAPTURE。
+*/
+void uvc_fnode_to_v4l2(frm_node_t* self, struct v4l2_buffer* v4l2, uint32_t io_type)
+{
+    if (memset_s(v4l2, sizeof(*v4l2), 0, sizeof(*v4l2)) != EOK) {
+        HI_ASSERT(0);
+    }
+    v4l2->index = self->index;
+    v4l2->type = io_type;
+    v4l2->memory = V4L2_MEMORY_USERPTR;
+
+    v4l2->m.userptr = (unsigned long)self->data;
+    v4l2->length = self->size;
+    v4l2->bytesused = self->len;
+}
+
+/**
+    尝试执行一次发送操作.
+
+    发送操作指将对象维持的发送队列中的frame添加到设备缓冲中。
+
+    在两种情况下可执行此操作，
+    *   当user提交了(通过uvc_tx_frm)待发送数据时，可尝试发送一次。
+    *   当监视到data_fd有信号时，在dqbuf后，可尝试发送一次。
+*/
+static int uvc_try_tx_frm(uvc_dev_ext_t* dev)
+{
+    struct v4l2_buffer buf;
+    frm_node_t *node = NULL;
+    int ret;
+
+    // 从对象维持的发送cache中获取一帧
+    node = frm_store_cache_get(dev->frm_store);
+    if (!node) {
+        return -1;
+    }
+
+    // 统计信息处理
+    uvc_piriod_proc(dev);
+
+    // 尝试将node添加到驱动的发送缓冲中
+    uvc_fnode_to_v4l2(node, &buf, V4L2_BUF_TYPE_VIDEO_OUTPUT);
+    if ((ret = ioctl(dev->fd, VIDIOC_QBUF, &buf)) < 0) {
+        // 这里discard该node，而不put回cache队列，
+        // 因为frm_store的总的node数量与向驱动申请的buf数量完全相同，这里不应该出错
+        LOGE("ioctl(VIDIOC_QBUF) FAIL, discard, err='%s, %d'\n", strerror(errno), errno);
+        frm_store_free(dev->frm_store, node);
+        dev->piriod_lost_num++;
+        return ret;
+    }
+
+    // QBUF OK
+    frm_store_useque_put(dev->frm_store, node); // 将node添加到wait队列
+    dev->piriod_out_num++; // 统计信息
+    dev->frame_out_num++;
+
+    // 以下为特别处理，以绕开目前的buf问题，待确认 ...
+    if (dev->strm_stat == UVC_STRM_READY) {
+        return 0;
+    } else if (dev->strm_stat == UVC_STRM_INIT &&
+        dev->frame_out_num == frm_store_node_num(dev->frm_store)) {
+        // 等所有buf均初始填满后，再trun stream on
+        LOGI("UVC: ioctl(STREAM_ON)\n");
+        int type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+        if ((ret = ioctl(dev->fd, VIDIOC_STREAMON, &type)) < 0) {
+            LOGE("ioctl(VIDIOC_STREAMON) FAIL: err='%s, %d'\n", strerror(errno), errno);
+            return ret;
+        }
+        uvc_chg_stat(dev, UVC_STRM_ON);
+
+        // 临时处理，以产生OUT事件，有可能是驱动对epoll支持故障
+        if (EmAddFd(dev->evt_mon, dev->data_fd, FDE_OUT | FDE_ET, uvc_on_data_fd, dev) < 0) {
+            HI_ASSERT(0);
+        }
+    } else if (dev->strm_stat == UVC_STRM_ON &&
+        dev->frame_out_num > frm_store_node_num(dev->frm_store)) {
+        // UVC_STRM_ON => UVC_STRM_READY
+        uvc_chg_stat(dev, UVC_STRM_READY);
+    }
+    return 0;
+}
+
+/**
+    处理驱动已完成的发送.
+    当data_fd有信号时执行。
+*/
+static int uvc_proc_dev_out(uvc_dev_ext_t* dev)
+{
+    struct v4l2_buffer buf;
+    int dque_num = 0;
+    int ret;
+
+    LOGD("uvc_proc_dev_out\n");
+
+    // 将已经发送的buf从驱动中dequeue
+    while (1) {
+        if (memset_s(&buf, sizeof buf, 0, sizeof buf) != EOK) {
+            HI_ASSERT(0);
+        }
+        buf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+        buf.memory = V4L2_MEMORY_USERPTR;
+        if ((ret = ioctl(dev->data_fd, VIDIOC_DQBUF, &buf)) < 0) {
+            if (errno == EAGAIN || errno == EWOULDBLOCK) {
+                if (dque_num == 0) {
+                    LOGW("ioctl(VIDIOC_DQBUF) ret EAGAIN, but sig recv\n");
+                }
+                // 临时处理，以再次能产生OUT事件，有可能是驱动对epoll支持故障
+                if (EmDelFd(dev->evt_mon, dev->data_fd) < 0) {
+                    HI_ASSERT(0);
+                }
+                if (EmAddFd(dev->evt_mon, dev->data_fd, FDE_OUT | FDE_ET, uvc_on_data_fd, dev) < 0) {
+                    HI_ASSERT(0);
+                }
+                break;
+            }
+            LOGW("ioctl(VIDIOC_DQBUF) FAIL, err='%s, %d'\n", strerror(errno), errno);
+            return ret;
+        }
+
+        HI_ASSERT(buf.index < dev->nbufs);
+        dque_num++;
+
+        // 从wait队列中get index对应的node，并将其free
+        frm_node_t *node = frm_store_useque_get(dev->frm_store, buf.index);
+        HI_ASSERT(node); // 若driver故障，此assert会检测到
+        frm_store_free(dev->frm_store, node);
+    }
+
+    // 触发发送
+    while (uvc_try_tx_frm(dev) == 0) {}
+    return 0;
+}
+
+/**
+    监视到data级事件.
+    处理stream data out事件。
+*/
+static void uvc_on_data_fd(void* user, int fd, uint32_t evts)
+{
+    uvc_dev_ext_t *dev = (uvc_dev_ext_t*)user;
+    HI_ASSERT(dev && fd == dev->data_fd);
+
+    // 若产生ERR事件，忽略，dev fd应该也会监视到，由其负责处理
+    if ((evts & FDE_ERR)) {
+        LOGE("detect data-fd 'ERR', fd=%d, evts=%X\n", fd, evts);
+    }
+
+    // buf可写
+    if (evts & FDE_OUT) {
+        LOGD("detect data-fd OUT, fd=%d\n", fd);
+        if (dev->strm_stat != UVC_STRM_OFF) {
+            if (uvc_proc_dev_out(dev) < 0) {
+                LOGE("uvc_data_thrd proc DQUE FAIL, quit the thrd\n");
+            }
+        } else {
+            LOGW("UVC: ignore data-fd OUT evt, for not in strm\n");
+        }
+    }
+
+    // 未知且未处理事件
+    if (evts & ~(FDE_OUT | FDE_ERR)) {
+        LOGE("UVC: detect un-handle data-fd evts, fd=%d, evts=%X\n", fd, evts);
+    }
+}
+
+/**
+    监视到设备级事件.
+*/
+static void uvc_on_dev_fd(void* user, int fd, uint32_t evts)
+{
+    uvc_dev_ext_t *dev = (uvc_dev_ext_t*)user;
+    HI_ASSERT(dev && fd == dev->fd);
+
+    // 经确认，select的excepts对应于PRI，同时ERR也会产生
+    if ((evts & FDE_PRI)) {
+        LOGD("detect dev-fd 'PRI', fd=%d, evts=%X\n", fd, evts);
+        uvc_evts_proc(dev);
+    } else if ((evts & FDE_ERR)) { // 无FDE_PRI的ERR应该是产生错误了
+        LOGE("detect dev-fd 'ERR', fd=%d, evts=%X\n", fd, evts);
+    }
+
+    // 未知且未处理事件
+    if (evts & ~(FDE_ERR | FDE_PRI)) {
+        LOGE("detect un-handle dev-fd evts, fd=%d, evts=%X\n", fd, evts);
+    }
+}
+
+/**
+    终止当前stream.
+
+    此函数由设备级事件处理触发。
+    当host端close UVC时，本端设备事件处理模块会检测到相应事件，并调用此函数。
+*/
+static void uvc_stop_strm(uvc_dev_ext_t* dev)
+{
+    LOGI("UVC: stop strm ...\n");
+    if (dev->strm_stat == UVC_STRM_OFF) {
+        LOGW("UVC: stop strm discard, for not in strm\n");
+        return;
+    }
+
+    uvc_chg_stat(dev, UVC_STRM_OFF);
+    EmDelFd(dev->evt_mon, dev->data_fd); // 有可能data_fd没有add而失败，OK
+
+    dev->prev_out_time = -1;
+    dev->frame_out_num = 0;
+
+    int type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+    int ret = ioctl(dev->fd, VIDIOC_STREAMOFF, &type);
+    if (ret < 0) {
+        LOGE("ioctl(STREAMOFF) FAIL, err='%s, %d'\n", strerror(errno), errno);
+        }
+
+    histream_shutdown_ext();
+    frm_store_clear(dev->frm_store);
+    LOGI("UVC: UVC: stop strm done\n");
+}
+
+/**
+    启动stream.
+
+    此函数由设备级事件处理触发。
+    当host端open UVC时，本端设备事件处理模块会检测到相应事件，并调用此函数。
+*/
+static void uvc_start_strm(uvc_dev_ext_t* dev)
+{
+    encoder_property p;
+
+    LOGI("UVC: start strm ...\n");
+    if (dev->strm_stat != UVC_STRM_OFF) {
+        LOGW("UVC: start strm discard, for in strm\n");
+        uvc_stop_strm(dev);
+    }
+
+    p.format = dev->fcc;
+    p.width = dev->width;
+    p.height = dev->height;
+    p.compsite = 0;
+
+    frm_store_clear(dev->frm_store);
+    uvc_req_bufs(dev, frm_store_node_num(dev->frm_store));
+
+    histream_set_enc_property_ext(&p);
+    histream_startup_ext(); // 目前没有检测并处理失败
+
+    dev->frame_out_num = 0;
+    uvc_piriod_init(dev);
+
+    uvc_chg_stat(dev, UVC_STRM_INIT);
+    LOGI("UVC: start strm done\n");
+}
+
+/**
+    打开UVC设备.
+*/
+static int uvc_open_dev(const char* devname)
+{
+    struct v4l2_capability cap;
+    int fd = -1;
+    int ret;
+    char st_path[PATH_MAX] = {0};
+    if (!realpath(devname, st_path)) {
+        LOGE("dev path (%s) is not exist", devname);
+        HI_ASSERT(0);
+    }
+    LOGI("uvc creat standard file:%s\n", st_path);
+
+    fd = open(st_path, O_RDWR | O_NONBLOCK);
+    if (fd < 0) {
+        LOGE("open '%s' FAIL, err='%s, %d'\n", st_path, strerror(errno), errno);
+        return -errno;
+    }
+
+    ret = ioctl(fd, VIDIOC_QUERYCAP, &cap);
+    if (ret < 0) {
+        LOGE("ioctl(VIDIOC_QUERYCAP) FAIL, err='%s, %d'\n", strerror(errno), errno);
+        goto FAIL;
+    }
+
+    /*
+    V4L2_CAP_VIDEO_CAPTURE 0x00000001 support video Capture interface.
+    V4L2_CAP_VIDEO_OUTPUT 0x00000002 support video output interface.
+    V4L2_CAP_VIDEO_OVERLAY 0x00000004 support video cover interface.
+    V4L2_CAP_VBI_CAPTURE 0x00000010 Original VBI Capture interface.
+    V4L2_CAP_VBI_OUTPUT 0x00000020 Original VBI Output interface.
+    V4L2_CAP_SLICED_VBI_CAPTURE 0x00000040 Sliced VBI Capture interface.
+    V4L2_CAP_SLICED_VBI_OUTPUT 0x00000080 Sliced VBI Output interface.
+    V4L2_CAP_RDS_CAPTURE 0x00000100 undefined
+    */
+    if (!(cap.capabilities & 0x00000002)) {
+        LOGE("'%s' not V4L2_CAP_VIDEO_OUTPUT dev\n", st_path);
+        ret = -1;
+        goto FAIL;
+    }
+
+    LOGI("UVC '%s' opened, cap=0x%04x, card='%s', bus='%s'\n",
+        st_path, cap.capabilities, cap.card, cap.bus_info);
+    return fd;
+
+    FAIL:
+        if (close(fd) < 0) {
+            HI_ASSERT(0);
+        }
+        return ret;
+}
+
+/**
+    创建uvc_dev_ext_t对象.
+*/
+int uvc_create(uvc_dev_ext_t** uvc_dev, const char *dev_file, const char* cfg_sect)
+{
+    HI_ASSERT(uvc_dev);
+    HI_ASSERT(dev_file || cfg_sect);
+    *uvc_dev = NULL;
+    uvc_dev_ext_t* dev = NULL;
+    int fd;
+
+    // fetch config
+    dev_file = dev_file ? dev_file : SectGetCfgStr(cfg_sect, "dev_file", UVC_DEV_FILE_DEF);
+    int ctrl_itf = SectGetCfgInt(cfg_sect, "ctrl_itf", UVC_CTRL_ITF_DEF);
+    int strm_itf = SectGetCfgInt(cfg_sect, "strm_itf", UVC_STRM_ITF_DEF);
+    int cache_num = SectGetCfgInt(cfg_sect, "cache_num", UVC_CACHE_NUM_DEF);
+    // cache_num若为负数，按照默认的值取，因内存有限，若大于等于8按照8来取
+    if (cache_num <= 0) {
+        cache_num = UVC_CACHE_NUM_DEF;
+    }
+    if (cache_num >= MAX_CACHE_NUM) {
+        cache_num = MAX_CACHE_NUM;
+    }
+    int imgsize = SectGetCfgInt(cfg_sect, "img_size", UVC_IMG_SIZE_DEF);
+    // imgsize若配置为负数，按照默认的值取，因内存有限，若大于等于默认值4倍，按照默认值4倍来取
+    if (imgsize <= 0) {
+        imgsize = UVC_IMG_SIZE_DEF;
+    }
+    if (imgsize >= MAX_UVC_IMG_SIZE_DEF) {
+        imgsize = MAX_UVC_IMG_SIZE_DEF;
+    }
+    int bulk = SectGetCfgInt(cfg_sect, "bulk_mode", UVC_BULK_MODE_DEF);
+    int bulk_size = SectGetCfgInt(cfg_sect, "bulk_size", UVC_BULK_SIZE_DEF);
+    long trc_intval = SectGetCfgInt(cfg_sect, "trc_intval", UVC_TRC_INTVAL_DEF);
+    LOGI("UVC: dev='%s', %s.opts={ctrl_itf: %d, strm_itf: %d, "
+        "\n    cache_num: %d, image_size: %d, bulk_mode: %d, bulk_size: %d, trc_intval: %ld}\n",
+        dev_file, (cfg_sect ? cfg_sect : "def"), ctrl_itf, strm_itf,
+        cache_num, imgsize, bulk, bulk_size, trc_intval);
+
+    fd = uvc_open_dev(dev_file);
+    if (fd < 0) {
+        return fd;
+    }
+
+    dev = (uvc_dev_ext_t*)malloc(sizeof(*dev));
+    HI_ASSERT(dev);
+    if (memset_s(dev, sizeof(*dev), 0, sizeof(*dev)) != EOK) {
+        HI_ASSERT(0);
+    }
+
+    dev->fd = fd;
+
+    dev->ctrl_itf = ctrl_itf;
+    dev->strm_itf = strm_itf;
+    dev->imgsize = imgsize;
+    dev->bulk = bulk;
+    dev->bulk_size = bulk_size;
+    dev->frm_store = frm_store_create((size_t)dev->imgsize, cache_num);
+    HI_ASSERT(dev->frm_store);
+    dev->trc_intval = trc_intval;
+
+    // added for windows support
+    dev->interface_id = dev->ctrl_itf;
+
+    dev->frame_out_num = 0;
+
+    uvc_evts_init(dev);
+
+    dev->data_fd = dup(dev->fd);
+    HI_ASSERT(dev->data_fd >= 0);
+
+    dev->evt_mon = MainEvtMon();
+
+    // NOTE: 这里用水平触发，否则事件处理中必须循环get事件，不然会丢失重要事件，导致streamoff异常
+    if (EmAddFd(dev->evt_mon, dev->fd, FDE_PRI, uvc_on_dev_fd, dev) < 0) {
+        HI_ASSERT(0);
+    }
+
+    *uvc_dev = dev;
+    return 0;
+}
+
+/**
+    销毁uvc_dev_ext_t对象.
+*/
+void uvc_destroy(uvc_dev_ext_t* dev)
+{
+    LOGI("UVC: destroy ...\n");
+    HI_ASSERT(dev);
+
+    if (dev->strm_stat != UVC_STRM_OFF) {
+        uvc_stop_strm(dev);
+    }
+
+    HI_ASSERT(dev->frm_store);
+    frm_store_destroy(dev->frm_store);
+
+    close(dev->data_fd);
+    close(dev->fd);
+
+    free(dev);
+    LOGI("UVC: destroy done\n");
+}
+
+/**
+    发送一帧数据.
+*/
+int uvc_tx_frm(uvc_dev_ext_t* dev, MemBlk *frm)
+{
+    HI_ASSERT(dev && frm);
+    pthread_t ret = pthread_self();
+    pthread_t res = EmThrdId(dev->evt_mon);
+    HI_ASSERT(ret == res);
+
+    if (dev->strm_stat == UVC_STRM_OFF) {
+        LOGW("uvc_tx_frm discard, for not in strm\n");
+        frm_store_free(dev->frm_store, frm);
+        return -1;
+    }
+
+    // 添加到store的cache中，而不是驱动的发送队列中
+    frm_store_cache_put(dev->frm_store, frm);
+    uvc_try_tx_frm(dev);
+    return 0;
+}
+
+/**
+    分配一个用以存储一帧数据的buf.
+*/
+MemBlk* uvc_alloc_buf(uvc_dev_ext_t* dev)
+{
+    HI_ASSERT(dev);
+    MemBlk *node = NULL;
+
+    if (dev->strm_stat == UVC_STRM_OFF) {
+        LOGW("uvc_alloc_buf discard, for not in strm\n");
+        return NULL;
+    }
+
+    node = frm_store_alloc(dev->frm_store);
+    if (!node) {
+        LOGE("uvc_alloc_buf FAIL, for no idle node\n");
+    }
+    return node;
+}
+
+/**
+    查询stream是否ready.
+*/
+bool uvc_strm_ready(uvc_dev_ext_t* self)
+{
+    return self->strm_stat == UVC_STRM_READY;
+}
+
diff -urpBN hiopenais/src/uvc_dev/uvc_dev.h hiopenais_modify/src/uvc_dev/uvc_dev.h
--- hiopenais/src/uvc_dev/uvc_dev.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/uvc_dev/uvc_dev.h	2021-03-29 04:19:03.000000000 -0700
@@ -0,0 +1,124 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __UVC_DEV_H__
+#define __UVC_DEV_H__
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <linux/ioctl.h>
+#include <linux/types.h>
+#include <linux/usb/ch9.h>
+
+#include "uvc_gadgete.h"
+
+#include "frm_store.h"
+#include "evt_mon.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+    UVC device.
+    表示一个slave端的UVC接口。
+    基于uvc_app sample修改。
+*/
+typedef struct uvc_device_ext {
+    int fd; // UVC device fd
+
+    int data_fd; // 指示有数据以发送的fd
+    frm_store_t *frm_store; // frame buffer store
+    EvtMon *evt_mon; // MainEvtMon()快捷变量
+    int strm_stat; // stream状态，状态码定义在uvc_strm_stat_t中
+
+    int ctrl_itf; // UVC control interface ID
+    int strm_itf; // UVC streaming interface ID
+
+    long trc_intval; // trace间隔, -1表示不trace
+    int64_t frame_out_num; // strm start后累计输出的frame数目
+    int64_t prev_out_time; // 上次输出frame的时间
+    int64_t piriod_beg_time; // 期间开始时间(ms)
+    int piriod_out_num; // 期间输出的帧数
+    int piriod_lost_num; // 期间丢帧数
+
+    /*
+        以下为uvc_app sample的成员
+    */
+    struct uvc_streaming_control probe;
+    struct uvc_streaming_control commit;
+    int control;
+    int unit_id;
+    int interface_id;
+    unsigned int fcc;
+    unsigned int width;
+    unsigned int height;
+    unsigned int nbufs;
+    unsigned int bulk;
+    uint8_t color;
+    unsigned int imgsize;
+    unsigned int bulk_size;
+    uvc_probe_t probe_status;
+
+    // USB speed specific
+    int mult;
+    int burst;
+    int maxpkt;
+    enum usb_device_speed speed;
+
+    struct uvc_request_data request_error_code;
+}uvc_dev_ext_t;
+
+/**
+    创建uvc_dev_ext_t对象.
+*/
+int uvc_create(uvc_dev_ext_t** uvc_dev, const char *dev_file, const char* cfg_sect);
+
+/**
+    销毁uvc_dev_ext_t对象.
+*/
+void uvc_destroy(uvc_dev_ext_t* self);
+
+/**
+    发送一帧数据.
+
+    @param frm 是通过uvc_alloc_buf()申请得到的。uvc_dec_t维持了内部的缓冲，
+    user在调用uvc_tx_frm()前，必须先调用uvc_alloc_buf()申请帧缓冲，
+    填充缓冲后，才能调用uvc_tx_frm()发送。
+
+    无论返回成功与否，user均不能再使用@param frm，即@param frm由uvc_tx_frm负责回收。
+*/
+int uvc_tx_frm(uvc_dev_ext_t* self, MemBlk* frm);
+
+/**
+    分配一个用以存储一帧数据的buf.
+    user调用此函数成功申请到缓冲后，必须调用uvc_tx_frm()，uvc_dev_ext_t未提供释放接口。
+    因此user在使用时只能当确有帧数据需要发送时，才能调用此函数申请。
+*/
+MemBlk* uvc_alloc_buf(uvc_dev_ext_t* dev);
+
+/**
+    查询stream是否ready.
+
+    仅当向uvc device发送了queue_size + 1的frame后，uvc的stream才被实际触发打开。
+    这是uvc device目前实现的一个限制。
+*/
+bool uvc_strm_ready(uvc_dev_ext_t* self);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __UVC_DEV_H__
diff -urpBN hiopenais/src/uvc_dev/uvc_strm.c hiopenais_modify/src/uvc_dev/uvc_strm.c
--- hiopenais/src/uvc_dev/uvc_strm.c	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/uvc_dev/uvc_strm.c	2021-03-30 03:11:38.000000000 -0700
@@ -0,0 +1,869 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <stdint.h>
+#include <stdbool.h>
+
+#include "hi_ext_util.h"
+#include "usb_video.h"
+#include "uvc_dev.h"
+#include "uvc_strm.h"
+
+#define UVC_RC_SETCUR_LEN 8
+#define UVC_RC_GETMIN_LEN 4
+#define UVC_RC_GETLEN_LEN 2
+
+static struct histream_ext g_hiStream = {
+    .mpi_sc_ops = NULL,
+    .mpi_pu_ops = NULL,
+    .mpi_it_ops = NULL,
+    .mpi_eu_ops = NULL,
+    .streaming = 0,
+    .exposure_auto_stall = 0,
+    .brightness_stall = 0,
+
+    .cmd_proc = NULL,
+    .strm_off_proc = NULL,
+};
+
+static histream_ext *get_histream()
+{
+    return &g_hiStream;
+}
+
+/*******************************************************
+ *	Histream Processing Unit Operation Functions
+ *******************************************************/
+static void _histream_pu_brightness_ctrl(struct uvc_device_ext *dev, uint8_t req, struct uvc_request_data *resp)
+{
+    uint16_t v = 50;
+
+    if (get_histream()->streaming == 1) {
+        if (get_histream()->mpi_pu_ops &&
+            get_histream()->mpi_pu_ops->brightness_get) {
+            v = get_histream()->mpi_pu_ops->brightness_get();
+        }
+    }
+
+    switch (req) {
+        case UVC_SET_CUR:
+            resp->length = 2; // 2: UVC_SET_CUR_RESP_LEN
+            dev->request_error_code.data[0] = 0x00;
+            dev->request_error_code.length = 1;
+            break;
+        case UVC_GET_CUR:
+            if (get_histream()->brightness_stall) {
+                resp->length = -EL2HLT;
+                dev->request_error_code.data[0] = 0x04;
+                dev->request_error_code.length = 1;
+                get_histream()->brightness_stall = 0;
+            } else {
+                resp->length = 2; // 2: UVC_GET_CUR_RESP_LEN
+                resp->data[0] = (v & 0xff);
+                resp->data[1] = ((v >> 8) & 0xff); // 8锛崇?8浣?
+                dev->request_error_code.data[0] = 0x00;
+                dev->request_error_code.length = 1;
+            }
+            break;
+        case UVC_GET_MIN:
+            resp->length = 2; // 2: UVC_GET_MIN_RESP_LEN
+            resp->data[0] = 0x00;
+            dev->request_error_code.data[0] = 0x00;
+            dev->request_error_code.length = 1;
+            break;
+        case UVC_GET_MAX:
+            resp->length = 2; // 2: UVC_GET_MAX_RESP_LEN
+            resp->data[0] = 0x64;
+            dev->request_error_code.data[0] = 0x00;
+            dev->request_error_code.length = 1;
+            break;
+        case UVC_GET_DEF:
+            resp->length = 2; // 2: UVC_GET_DEF_RESP_LEN
+            resp->data[0] = 0x32;
+            dev->request_error_code.data[0] = 0x00;
+            dev->request_error_code.length = 1;
+            break;
+        case UVC_GET_RES:
+            resp->data[0] = 0x01;
+            resp->length = 2; // 2: UVC_GET_RES_RESP_LEN
+            dev->request_error_code.data[0] = 0x00;
+            dev->request_error_code.length = 1;
+            break;
+        case UVC_GET_INFO:
+            resp->data[0] = 0x03;
+            resp->length = 1;
+            dev->request_error_code.data[0] = 0x00;
+            dev->request_error_code.length = 1;
+            break;
+        default:
+            resp->length = -EL2HLT;
+            dev->request_error_code.data[0] = 0x07;
+            dev->request_error_code.length = 1;
+            break;
+    }
+}
+
+static void _histream_pu_brightness_set_ext(struct uvc_request_data *data)
+{
+    uint16_t v;
+
+    v = data->data[0] + (data->data[1] << 8); // 8: 左移8位
+    if (v > 0x64) {
+        get_histream()->brightness_stall = 1;
+    }
+
+    if (get_histream()->mpi_pu_ops &&
+        get_histream()->mpi_pu_ops->brightness_set) {
+        get_histream()->mpi_pu_ops->brightness_set(v);
+    }
+}
+
+void _histream_pu_contrast_ctrl_ext(struct uvc_device_ext *dev, uint8_t req, struct uvc_request_data *resp)
+{
+    switch (req) {
+        case UVC_SET_CUR:
+            resp->length = 2; // 2: UVC_SET_CUR_RESP_LEN
+            break;
+        case UVC_GET_CUR:
+            dev->request_error_code.data[0] = 0x06;
+            dev->request_error_code.length = 1;
+            break;
+        case UVC_GET_MIN:
+            resp->length = 2; // 2: UVC_GET_MIN_RESP_LEN
+            resp->data[0] = 0x00;
+            resp->data[1] = 0x00;
+            break;
+        case UVC_GET_MAX:
+            resp->length = 2; // 2: UVC_GET_MAX_RESP_LEN
+            resp->data[0] = 0x64;
+            resp->data[1] = 0x00;
+            break;
+        case UVC_GET_LEN:
+            resp->data[0] = 0x02;
+            resp->data[1] = 0x00;
+            resp->length = 2; // 2: UVC_GET_LEB_RESP_LEN
+            break;
+        case UVC_GET_INFO:
+            resp->data[0] = 0x03;
+            resp->length = 1;
+            break;
+        default:
+            resp->length = -EL2HLT;
+            dev->request_error_code.data[0] = 0x07;
+            dev->request_error_code.length = 1;
+            break;
+    }
+}
+
+static void _histream_pu_contrast_set_ext(struct uvc_request_data *data)
+{
+    uint16_t v;
+
+    if (get_histream()->streaming != 1) {
+        return;
+    }
+
+    v = data->data[0] + (data->data[1] << 8); // 8:左移8位
+
+    if (get_histream()->mpi_pu_ops &&
+        get_histream()->mpi_pu_ops->contrast_set) {
+        get_histream()->mpi_pu_ops->contrast_set(v);
+    }
+}
+
+void _histream_pu_hue_ctrl_ext(struct uvc_device_ext *dev, uint8_t req, struct uvc_request_data *resp)
+{
+    switch (req) {
+        case UVC_SET_CUR:
+            resp->length = 2; // 2: UVC_SET_CUR_RESP_LEN
+            break;
+        case UVC_GET_CUR:
+            dev->request_error_code.data[0] = 0x06;
+            dev->request_error_code.length = 1;
+            break;
+        case UVC_GET_MIN:
+            resp->length = 2; // 2: UVC_GET_MIN_RESP_LEN
+            resp->data[0] = 0x00;
+            resp->data[1] = 0x00;
+            break;
+        case UVC_GET_MAX:
+            resp->length = 2; // 2: UVC_GET_MAX_RESP_LEN
+            resp->data[0] = 0x64;
+            resp->data[1] = 0x00;
+            break;
+        case UVC_GET_LEN:
+            resp->data[0] = 0x02;
+            resp->data[1] = 0x00;
+            resp->length = 2; // 2: UVC_GET_LEN_RESP_LEN
+            break;
+        case UVC_GET_INFO:
+            resp->data[0] = 0x03;
+            resp->length = 1;
+            break;
+        default:
+            resp->length = -EL2HLT;
+            dev->request_error_code.data[0] = 0x07;
+            dev->request_error_code.length = 1;
+            break;
+    }
+}
+
+static void _histream_pu_hue_set_ext(struct uvc_request_data *data)
+{
+    uint16_t v;
+
+    if (get_histream()->streaming != 1) {
+        return;
+    }
+
+    v = data->data[0] + (data->data[1] << 8); // 8:左移8位
+
+    if (get_histream()->mpi_pu_ops &&
+        get_histream()->mpi_pu_ops->hue_set) {
+        get_histream()->mpi_pu_ops->hue_set(v);
+    }
+}
+
+void _histream_pu_power_line_frequency_ctrl_ext(struct uvc_device_ext *dev, uint8_t req, struct uvc_request_data *resp)
+{
+    switch (req) {
+        case UVC_SET_CUR:
+            resp->length = 1;
+            break;
+        case UVC_GET_CUR:
+            dev->request_error_code.data[0] = 0x06;
+            dev->request_error_code.length = 1;
+            break;
+        case UVC_GET_DEF:
+            resp->length = 1;
+            resp->data[0] = 0x1;
+            break;
+        case UVC_GET_INFO:
+            resp->data[0] = 0x03;
+            resp->length = 1;
+            break;
+        default:
+            resp->length = -EL2HLT;
+            dev->request_error_code.data[0] = 0x07;
+            dev->request_error_code.length = 1;
+            break;
+    }
+}
+
+static void _histream_pu_power_line_frequency_set_ext(struct uvc_request_data *data)
+{
+    uint8_t v;
+
+    if (get_histream()->streaming != 1) {
+        return;
+    }
+
+    v = data->data[0];
+
+    if (get_histream()->mpi_pu_ops &&
+        get_histream()->mpi_pu_ops->power_line_frequency_set) {
+        get_histream()->mpi_pu_ops->power_line_frequency_set(v);
+    }
+}
+
+void _histream_pu_saturation_ctrl_ext(struct uvc_device_ext *dev, uint8_t req, struct uvc_request_data *resp)
+{
+    switch (req) {
+        case UVC_SET_CUR:
+            resp->length = 2; // 2: UVC_SET_CUR_RESP_LEN
+            break;
+        case UVC_GET_CUR:
+            dev->request_error_code.data[0] = 0x06;
+            dev->request_error_code.length = 1;
+            break;
+        case UVC_GET_MIN:
+            resp->length = 2; // 2: UVC_GET_MIN_RESP_LEN
+            resp->data[0] = 0x00;
+            resp->data[1] = 0x00;
+            break;
+        case UVC_GET_MAX:
+            resp->length = 2; // 2: UVC_GET_MAX_RESP_LEN
+            resp->data[0] = 0x64;
+            resp->data[1] = 0x00;
+            break;
+        case UVC_GET_LEN:
+            resp->data[0] = 0x02;
+            resp->data[1] = 0x00;
+            resp->length = 2; // 2: UVC_GET_LEN_RESP_LEN
+            break;
+        case UVC_GET_INFO:
+            resp->data[0] = 0x03;
+            resp->length = 1;
+            break;
+        default:
+            resp->length = -EL2HLT;
+            dev->request_error_code.data[0] = 0x07;
+            dev->request_error_code.length = 1;
+            break;
+    }
+}
+
+static void _histream_pu_saturation_set_ext(struct uvc_request_data *data)
+{
+    uint16_t v;
+
+    if (get_histream()->streaming != 1) {
+        return;
+    }
+
+    v = data->data[0] + (data->data[1] << 8); // 8:左移8位
+
+    if (get_histream()->mpi_pu_ops &&
+        get_histream()->mpi_pu_ops->saturation_set) {
+        get_histream()->mpi_pu_ops->saturation_set(v);
+    }
+}
+
+void _histream_pu_white_balance_temperature_auto_ctrl_ext(struct uvc_device_ext *dev,
+    uint8_t req, struct uvc_request_data *resp)
+{
+    switch (req) {
+        case UVC_SET_CUR:
+            resp->length = 1;
+            break;
+        case UVC_GET_CUR:
+            dev->request_error_code.data[0] = 0x06;
+            dev->request_error_code.length = 1;
+            break;
+        case UVC_GET_DEF:
+            resp->length = 1;
+            resp->data[0] = 0x1;
+            break;
+        case UVC_GET_INFO:
+            resp->data[0] = 0x03;
+            resp->length = 1;
+            break;
+        default:
+            resp->length = -EL2HLT;
+            dev->request_error_code.data[0] = 0x07;
+            dev->request_error_code.length = 1;
+            break;
+    }
+}
+
+static void _histream_pu_white_balance_temperature_auto_set_ext(struct uvc_request_data *data)
+{
+    uint8_t v;
+
+    if (get_histream()->streaming != 1) {
+        return;
+    }
+
+    v = data->data[0];
+
+    if (get_histream()->mpi_pu_ops &&
+        get_histream()->mpi_pu_ops->white_balance_temperature_auto_set) {
+        get_histream()->mpi_pu_ops->white_balance_temperature_auto_set(v);
+    }
+}
+
+void _histream_pu_white_balance_temperature_ctrl_ext(struct uvc_device_ext *dev,
+    uint8_t req, struct uvc_request_data *resp)
+{
+    switch (req) {
+        case UVC_SET_CUR:
+            resp->length = 2; // 2: UVC_SET_CUR_RESP_LEN
+            break;
+        case UVC_GET_CUR:
+            dev->request_error_code.data[0] = 0x06;
+            dev->request_error_code.length = 1;
+            break;
+        case UVC_GET_MIN:
+            resp->length = 2; // 2: UVC_GET_MIN_RESP_LEB
+            resp->data[0] = 1500&0xff; // 1500: constant
+            resp->data[1] = 1500 / 256; // 1500: constant, 256: constant
+            break;
+        case UVC_GET_MAX:
+            resp->length = 2; // 2: UVC_GET_MAX_RESP_LEN
+            resp->data[0] = 15000&0xff; // 15000: constant
+            resp->data[1] = 15000 / 256; // 15000: constant, 256: constant
+            break;
+        case UVC_GET_LEN:
+            resp->data[0] = 0x02;
+            resp->data[1] = 0x00;
+            resp->length = 2; // 2: UVC_GET_LEN_RESP_LEN
+            break;
+        case UVC_GET_INFO:
+            resp->data[0] = 0x03;
+            resp->length = 1;
+            break;
+        default:
+            resp->length = -EL2HLT;
+            dev->request_error_code.data[0] = 0x07;
+            dev->request_error_code.length = 1;
+            break;
+    }
+}
+
+static void _histream_pu_white_balance_temperature_set_ext(struct uvc_request_data *data)
+{
+    uint16_t v;
+
+    if (get_histream()->streaming != 1) {
+        return;
+    }
+
+    v = data->data[0] + (data->data[1] << 8); // 8:左移8位
+
+    if (get_histream()->mpi_pu_ops &&
+        get_histream()->mpi_pu_ops->white_balance_temperature_set) {
+        get_histream()->mpi_pu_ops->white_balance_temperature_set(v);
+    }
+}
+
+void histream_event_pu_control_ext(struct uvc_device_ext *dev,
+                               uint8_t req,
+                               uint8_t unit_id,
+                               uint8_t cs,
+                               struct uvc_request_data* resp)
+{
+    if (unit_id != 2) { // 2: uint_id value
+        return;
+    }
+
+    switch (cs) {
+        case UVC_PU_BRIGHTNESS_CONTROL:
+            _histream_pu_brightness_ctrl(dev, req, resp);
+            break;
+        case UVC_PU_HUE_CONTROL:
+            _histream_pu_hue_ctrl_ext(dev, req, resp);
+            break;
+        case UVC_PU_CONTRAST_CONTROL:
+            _histream_pu_contrast_ctrl_ext(dev, req, resp);
+            break;
+        case UVC_PU_SATURATION_CONTROL:
+            _histream_pu_saturation_ctrl_ext(dev, req, resp);
+            break;
+        case UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL:
+        case UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
+        case UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
+        case UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
+        case UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
+        default:
+            resp->length = -EL2HLT;
+            dev->request_error_code.data[0] = 0x06;
+            dev->request_error_code.length = 1;
+            break;
+    }
+}
+
+void histream_event_pu_data_ext(int unit_id, int control, struct uvc_request_data *data)
+{
+    if (unit_id != 2) { // 2: the number of unit_id
+        return;
+    }
+
+    switch (control) {
+        case UVC_PU_BRIGHTNESS_CONTROL:
+            return _histream_pu_brightness_set_ext(data);
+        case UVC_PU_CONTRAST_CONTROL:
+            return _histream_pu_contrast_set_ext(data);
+        case UVC_PU_HUE_CONTROL:
+            return _histream_pu_hue_set_ext(data);
+        case UVC_PU_SATURATION_CONTROL:
+            return _histream_pu_saturation_set_ext(data);
+        case UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
+            return _histream_pu_white_balance_temperature_auto_set_ext(data);
+        case UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
+            return _histream_pu_white_balance_temperature_set_ext(data);
+        case UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
+            return _histream_pu_power_line_frequency_set_ext(data);
+        default:
+            break;
+    }
+}
+
+/* Histream Processing Unit Operation Functions End */
+
+/*******************************************************
+ *	Histream Input Terminal Operation Functions
+ *******************************************************/
+static void _histream_it_exposure_auto_mode_ctrl(struct uvc_device_ext*       dev,
+        uint8_t req,
+        struct uvc_request_data *resp)
+{
+    uint8_t v = 0x04;
+
+    if (get_histream()->streaming == 1) {
+        if (get_histream()->mpi_it_ops &&
+            get_histream()->mpi_it_ops->exposure_auto_mode_get) {
+            v = get_histream()->mpi_it_ops->exposure_auto_mode_get();
+        }
+    }
+
+    switch (req) {
+        case UVC_SET_CUR:
+            resp->data[0] = 0x0;
+            resp->length = 1;
+            dev->request_error_code.data[0] = 0x00;
+            dev->request_error_code.length = 1;
+            break;
+        case UVC_GET_CUR:
+            if (get_histream()->exposure_auto_stall) {
+                dev->request_error_code.data[0] = 0x04;
+                dev->request_error_code.length = 1;
+                get_histream()->exposure_auto_stall = 0;
+            } else {
+                resp->data[0] = v;
+                resp->length = 1;
+                dev->request_error_code.data[0] = 0x00;
+                dev->request_error_code.length = 1;
+            }
+            break;
+        case UVC_GET_RES:
+            resp->data[0] = 0x05;
+            resp->length = 1;
+            dev->request_error_code.data[0] = 0x00;
+            dev->request_error_code.length = 1;
+            break;
+        case UVC_GET_DEF:
+            resp->data[0] = 0x04;
+            resp->length = 1;
+            dev->request_error_code.data[0] = 0x00;
+            dev->request_error_code.length = 1;
+            break;
+        case UVC_GET_INFO:
+            resp->data[0] = 0x3;
+            resp->length = 1;
+            dev->request_error_code.data[0] = 0x00;
+            dev->request_error_code.length = 1;
+            break;
+        default:
+            resp->length = -EL2HLT;
+            dev->request_error_code.data[0] = 0x07;
+            dev->request_error_code.length = 1;
+            break;
+    }
+}
+
+static void _histream_it_exposure_auto_mode_set(struct uvc_device_ext* dev, struct uvc_request_data *data)
+{
+    uint8_t v;
+
+    if (get_histream()->streaming != 1) {
+        return;
+    }
+
+    v = data->data[0];
+    switch (v) {
+    case 0x01:
+    case 0x02:
+    case 0x04:
+    case 0x08:
+        get_histream()->exposure_auto_stall = 0;
+        break;
+    default:
+        get_histream()->exposure_auto_stall = 1;
+        return;
+    }
+    if (get_histream()->mpi_it_ops &&
+        get_histream()->mpi_it_ops->exposure_auto_mode_set) {
+        get_histream()->mpi_it_ops->exposure_auto_mode_set(v);
+    }
+}
+
+static void _histream_it_exposure_ansolute_time_ctrl(struct uvc_device_ext*       dev,
+        uint8_t                  req,
+        struct uvc_request_data *resp)
+{
+    uint32_t v = 2000;
+
+    if (get_histream()->streaming == 1) {
+        if (get_histream()->mpi_it_ops &&
+            get_histream()->mpi_it_ops->exposure_ansolute_time_get) {
+            v = get_histream()->mpi_it_ops->exposure_ansolute_time_get();
+        }
+    }
+    switch (req) {
+        case UVC_SET_CUR:
+            resp->length = 4; // 4: UVC_SET_CUR_RESP_LEN
+            resp->data[0] = 0x0;
+            break;
+        case UVC_GET_CUR:
+            resp->length = 4; // 4: UVC_GET_CUR_RESP_LEN
+            resp->data[0] = (v & 0xff);
+            resp->data[1] = ((v >> 8) & 0xff); // 8: 崇Щ8浣?
+            resp->data[2] = ((v >> 16) & 0xff); // 2: 扮涓, 16:崇Щ16浣?
+            resp->data[3] = ((v >> 24) & 0xff); // 3: 扮涓, 24: 崇Щ24浣?
+            break;
+        case UVC_GET_MAX:
+            resp->length = 4; // 4: UVC_GET_MAX_RESP_LEN
+            resp->data[0] = (2000)&0xff; // 2000: constant
+            resp->data[1] = (2000>>8)&0xff; // 2000: constant, 8: 崇Щ8浣?
+            resp->data[2] = 0x0; // 2: 扮涓
+            resp->data[3] = 0x0; // 3: 扮涓
+            break;
+        case UVC_GET_MIN:
+            resp->length = 4; // 4: UVC_GET_MIN_RESP_LEN
+            resp->data[0] = 0x0a;
+            resp->data[1] = 0x0;
+            resp->data[2] = 0x0; // 2: 扮涓
+            resp->data[3] = 0x0; // 3: 扮涓
+            break;
+        case UVC_GET_RES:
+            resp->data[0] = 0x0a;
+            resp->length = 4; // 4: UVC_GET_RES_RESP_LEN
+            break;
+        case UVC_GET_DEF:
+            resp->data[0] = 0x64;
+            resp->length = 4; // 4: UVC_GET_DEF_RESP_LEN
+            break;
+        case UVC_GET_INFO:
+            resp->data[0] = 0xf;
+            resp->length = 1;
+            break;
+        default:
+            resp->length = -EL2HLT;
+            dev->request_error_code.length = 1;
+            dev->request_error_code.data[0] = 0x07;
+            break;
+    }
+}
+
+static void _histream_it_exposure_absolute_time_set_ext(struct uvc_request_data *data)
+{
+    uint32_t v;
+
+    if (get_histream()->streaming != 1) {
+        return;
+    }
+    // 8:左移8位, 16:左移16位, 24:左移24位, 100:Multiplied 100, 3:数组下标
+    v = (data->data[0] + (data->data[1]<<8) + (data->data[2]<<16) + (data->data[3]<<24))*100;
+
+    if (get_histream()->mpi_it_ops &&
+        get_histream()->mpi_it_ops->exposure_ansolute_time_set) {
+        get_histream()->mpi_it_ops->exposure_ansolute_time_set(v);
+    }
+}
+
+void histream_event_it_control_ext(struct uvc_device_ext*       dev,
+                               uint8_t req,
+                               uint8_t unit_id,
+                               uint8_t cs,
+                               struct uvc_request_data* resp)
+{
+    if (unit_id != 1) {
+        return;
+    }
+
+    switch (cs) {
+        case UVC_CT_AE_MODE_CONTROL:
+            _histream_it_exposure_auto_mode_ctrl(dev, req, resp);
+            break;
+        case UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
+            _histream_it_exposure_ansolute_time_ctrl(dev, req, resp);
+            break;
+        case UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
+        case UVC_CT_AE_PRIORITY_CONTROL:
+        default:
+            resp->length = -EL2HLT;
+            dev->request_error_code.data[0] = 0x06;
+            dev->request_error_code.length = 1;
+            break;
+    }
+}
+
+void histream_event_it_data_ext(struct uvc_device_ext *dev, int unit_id, int control, struct uvc_request_data *data)
+{
+    if (unit_id != 1) {
+        return;
+    }
+
+    switch (control) {
+        case UVC_CT_AE_MODE_CONTROL:
+            _histream_it_exposure_auto_mode_set(dev, data);
+            break;
+        case UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
+            _histream_it_exposure_absolute_time_set_ext(data);
+            break;
+        default:
+            break;
+    }
+}
+
+/* Histream Input Terminal Operation Functions End */
+
+/* Histream Extension Unit H264 Operation Functions End */
+void histream_event_xu_data(int unit_id, int control, struct uvc_request_data *data)
+{
+    if (unit_id != UNIT_XU_HICAMERA) {
+        return;
+    }
+    if (!g_hiStream.cmd_proc) {
+        return;
+    }
+
+    int ret = g_hiStream.cmd_proc(
+        data->data, data->length, UVC_VC_SETCUR_COMPLETE, control);
+    if (ret < 0) {
+        LOGE("run_cmd_func return error!\n");
+    }
+}
+
+/*******************************************************
+ *  Histream Extension Unit Camera Operation Functions
+ *******************************************************/
+void histream_event_xu_camera_control (struct uvc_device_ext*    dev,
+                                       uint8_t req,
+                                       uint8_t unit_id,
+                                       uint8_t cs,
+                                       struct uvc_request_data* data,
+                                       struct uvc_request_data* resp)
+{
+    if (unit_id != UNIT_XU_HICAMERA) {
+        return;
+    }
+
+    int ret;
+    switch (req) {
+        case UVC_RC_SETCUR:
+            resp->length = UVC_RC_SETCUR_LEN;
+            break;
+        case UVC_RC_GETCUR:
+            if (!g_hiStream.cmd_proc) {
+                break;
+            }
+            ret = g_hiStream.cmd_proc(
+                resp->data, resp->length, UVC_VC_SETCUR_COMPLETE, dev->control);
+            if (ret < 0) {
+                LOGE("run_cmd_func return error!\n");
+            } else {
+                resp->length = ret;
+            }
+            break;
+        case UVC_RC_GETMIN:
+            resp->length = UVC_RC_GETMIN_LEN;
+            break;
+        case UVC_RC_GETLEN:
+            resp->data[0] = 0x08;
+            resp->data[1] = 0x00;
+            resp->length = UVC_RC_GETLEN_LEN;
+            break;
+        case UVC_RC_GETINFO:
+            resp->data[0] = 0x03;
+            resp->length = 1;
+            break;
+        default:
+            break;
+    }
+}
+
+/* Histream Extension Unit Camera Operation Functions End */
+
+/*******************************************************
+ *  Histream Stream Control Operation Functions
+ *******************************************************/
+int histream_init_ext(void)
+{
+    if (get_histream()->mpi_sc_ops &&
+        get_histream()->mpi_sc_ops->init) {
+        return get_histream()->mpi_sc_ops->init();
+    }
+
+    return 0;
+}
+
+int histream_startup_ext(void)
+{
+    int ret = 0;
+
+    if (get_histream()->mpi_sc_ops &&
+        get_histream()->mpi_sc_ops->startup) {
+        ret = get_histream()->mpi_sc_ops->startup();
+    }
+    if (ret == 0) {
+        get_histream()->streaming = 1;
+    }
+    return ret;
+}
+
+int histream_shutdown_ext(void)
+{
+    int ret = 0;
+
+    if (g_hiStream.strm_off_proc) {
+        g_hiStream.strm_off_proc();
+    }
+
+    if (get_histream()->mpi_sc_ops &&
+        get_histream()->mpi_sc_ops->shutdown) {
+        ret = get_histream()->mpi_sc_ops->shutdown();
+    }
+    if (ret == 0) {
+        get_histream()->streaming = 0;
+    }
+    return ret;
+}
+
+int histream_set_enc_property_ext(struct encoder_property *p)
+{
+    if (get_histream()->mpi_sc_ops &&
+        get_histream()->mpi_sc_ops->set_property) {
+        return get_histream()->mpi_sc_ops->set_property(p);
+    }
+    return 0;
+}
+
+int histream_set_enc_idr_ext(void)
+{
+    if (get_histream()->mpi_sc_ops &&
+        get_histream()->mpi_sc_ops->set_idr) {
+        return get_histream()->mpi_sc_ops->set_idr();
+    }
+    return 0;
+}
+
+int histream_register_mpi_ops_ext(struct stream_control_ops *sc_ops,
+                              struct processing_unit_ops *pu_ops,
+                              struct input_terminal_ops *it_ops,
+                              struct extension_unit_ops* eu_ops)
+{
+    get_histream()->mpi_sc_ops = sc_ops;
+    get_histream()->mpi_pu_ops = pu_ops;
+    get_histream()->mpi_it_ops = it_ops;
+    get_histream()->mpi_eu_ops = eu_ops;
+
+    return 0;
+}
+
+void release_histream_ext(histream_ext *stream)
+{
+}
+
+/**
+    注册UVC自定义命令处理函数.
+*/
+void histream_reg_cmd_proc(uvc_dev_ext_t* dev, histream_cmd_proc_t func)
+{
+    g_hiStream.cmd_proc = func;
+}
+
+/**
+    注册UVC自定义命令处理函数.
+*/
+void histream_reg_strm_off_proc(uvc_dev_ext_t* dev, histream_strm_off_proc_t func)
+{
+    g_hiStream.strm_off_proc = func;
+}
+
diff -urpBN hiopenais/src/uvc_dev/uvc_strm.h hiopenais_modify/src/uvc_dev/uvc_strm.h
--- hiopenais/src/uvc_dev/uvc_strm.h	1969-12-31 16:00:00.000000000 -0800
+++ hiopenais_modify/src/uvc_dev/uvc_strm.h	2021-03-30 03:09:15.000000000 -0700
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) 2021 HiSilicon (Shanghai) Technologies CO., LIMITED.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __HI_STREAM_H__
+#define __HI_STREAM_H__
+
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <errno.h>
+#include "histream.h"
+#include "hicamera.h"
+#include "uvc_dev.h"
+
+// temp moved from hi_ctrl.h
+// CTRL id
+#define HI_XUID_SET_RESET 0x01
+#define HI_XUID_SET_STREAM 0x02
+#define HI_XUID_SET_RESOLUTION 0x03
+#define HI_XUID_SET_IFRAME 0x04
+#define HI_XUID_SET_BITRATE 0x05
+#define HI_XUID_UPDATE_SYSTEM 0x06
+
+/**
+    UVC自定义命令处理函数类型.
+    用以解除与histreaming_control的相互依赖。
+*/
+typedef int (*histream_cmd_proc_t)(
+    __u8 *buf, unsigned int bufLength, unsigned int cmdtype, unsigned int cmd_id);
+
+/**
+    UVC stream off回调函数类型.
+    用以解除与uvc_histreaming的相互依赖。
+*/
+typedef void (*histream_strm_off_proc_t)(void);
+
+typedef struct histream_ext {
+    struct stream_control_ops *mpi_sc_ops;
+    struct processing_unit_ops *mpi_pu_ops;
+    struct input_terminal_ops *mpi_it_ops;
+    struct extension_unit_ops *mpi_eu_ops;
+    int streaming;
+    int exposure_auto_stall;
+    int brightness_stall;
+
+    histream_cmd_proc_t cmd_proc;
+    histream_strm_off_proc_t strm_off_proc;
+} histream_ext;
+
+/* media control functions */
+extern int histream_register_mpi_ops_ext(struct stream_control_ops *sc_ops,
+                              struct processing_unit_ops *pu_ops,
+                              struct input_terminal_ops *it_ops,
+                              struct extension_unit_ops* eu_ops);
+
+extern int histream_set_enc_property_ext(struct encoder_property *p);
+extern int histream_init_ext(void);
+extern int histream_shutdown_ext(void);
+extern int histream_startup_ext(void);
+
+extern void histream_event_pu_control_ext(struct uvc_device_ext *dev,
+                                      uint8_t req,
+                                      uint8_t unit_id,
+                                      uint8_t cs,
+                                      struct uvc_request_data* resp);
+
+extern void histream_event_it_control_ext(struct uvc_device_ext *dev,
+                                      uint8_t req,
+                                      uint8_t unit_id,
+                                      uint8_t cs,
+                                      struct uvc_request_data *resp);
+
+
+void histream_event_xu_camera_control (struct uvc_device_ext *dev, uint8_t req,
+        uint8_t unit_id,
+        uint8_t cs,
+        struct uvc_request_data* data,
+        struct uvc_request_data* resp);
+
+void histream_event_xu_data(int unit_id, int control, struct uvc_request_data *data);
+
+extern void histream_event_it_data_ext(struct uvc_device_ext *dev, int unit_id,
+    int control, struct uvc_request_data *data);
+
+extern int histream_set_enc_idr_ext(void);
+
+extern void histream_event_pu_data_ext(int unit_id, int control, struct uvc_request_data *data);
+
+/**
+    注册UVC自定义命令处理函数.
+*/
+void histream_reg_cmd_proc(uvc_dev_ext_t* dev, histream_cmd_proc_t func);
+
+/**
+    注册UVC自定义命令处理函数.
+*/
+void histream_reg_strm_off_proc(uvc_dev_ext_t* dev, histream_strm_off_proc_t func);
+
+#endif // __HI_STREAM_H__
+
